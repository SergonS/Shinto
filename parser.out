Grammar:

Rule 0     S' -> program
Rule 1     program -> PROG ID check_program ; gvars store_gvars functions gvars store_gvars main
Rule 2     gvars -> VAR datatype gvarids store_gtype ; gvars
Rule 3     gvars -> <empty>
Rule 4     gvarids -> ID
Rule 5     gvarids -> ID , gvarids
Rule 6     store_gvars -> <empty>
Rule 7     store_gtype -> <empty>
Rule 8     vars -> VAR datatype varids store_type ; vars
Rule 9     vars -> <empty>
Rule 10    varids -> ID darray
Rule 11    varids -> ID darray , varids
Rule 12    store_type -> <empty>
Rule 13    darray -> <empty>
Rule 14    darray -> [ INT ] twodarray
Rule 15    twodarray -> <empty>
Rule 16    twodarray -> [ INT ]
Rule 17    functions -> datatype FUNC ID ( params ) store_funcv store_params store_init_quad { vars store_local_vars funcontent } close_func functions
Rule 18    functions -> <empty>
Rule 19    funcontent -> <empty>
Rule 20    funcontent -> statement funcontent
Rule 21    params -> ID : datatype , params
Rule 22    params -> ID : datatype
Rule 23    params -> <empty>
Rule 24    main -> FUNC MAIN ( ) store_funcm { vars store_mainv maincontent }
Rule 25    maincontent -> <empty>
Rule 26    maincontent -> statement maincontent
Rule 27    statement -> loop unload_pv
Rule 28    statement -> input unload_pv
Rule 29    statement -> output unload_pv
Rule 30    statement -> ifelse unload_pv
Rule 31    statement -> returns unload_pv ;
Rule 32    statement -> expr ;
Rule 33    statement -> var_assign unload_pv
Rule 34    statement -> <empty>
Rule 35    statement -> statement statement
Rule 36    var_assign -> ID store_oper = expr ;
Rule 37    returns -> RETURN expr store_rquad
Rule 38    ifelse -> IF ( expr ) store_gotof { statement } ELSE store_endif { statement }
Rule 39    ifelse -> IF ( expr ) store_gotof { statement } store_endif
Rule 40    output -> OUTPUT ( expr outex ) ;
Rule 41    outex -> <empty>
Rule 42    outex -> , expr outex
Rule 43    input -> INPUT ( ID store_oper ) ;
Rule 44    loop -> WHILE store_jump ( expr ) store_gotof { statement } end_loop
Rule 45    expr -> arexp exprx
Rule 46    exprx -> <empty>
Rule 47    exprx -> exprop arexp
Rule 48    exprop -> OR
Rule 49    exprop -> EQEQ
Rule 50    exprop -> DIFF
Rule 51    exprop -> AND
Rule 52    exprop -> <
Rule 53    exprop -> LOETHAN
Rule 54    exprop -> >
Rule 55    exprop -> GOETHAN
Rule 56    arexp -> term arexpextra
Rule 57    arexp -> term
Rule 58    arexpextra -> <empty>
Rule 59    arexpextra -> - term arexpextra  [precedence=left, level=1]
Rule 60    arexpextra -> + term arexpextra  [precedence=left, level=1]
Rule 61    term -> factor termx
Rule 62    term -> factor
Rule 63    termx -> <empty>
Rule 64    termx -> / factor termx  [precedence=left, level=2]
Rule 65    termx -> * factor termx  [precedence=left, level=2]
Rule 66    factor -> element
Rule 67    factor -> ( store_op expr ) store_op
Rule 68    element -> callfunc store_oper
Rule 69    element -> compound store_oper
Rule 70    element -> const store_const
Rule 71    compound -> compoundx
Rule 72    compoundx -> ID store_oper
Rule 73    const -> STRING
Rule 74    const -> FLOAT
Rule 75    const -> INT
Rule 76    const -> FALSE
Rule 77    const -> TRUE
Rule 78    callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
Rule 79    callfuncpar -> <empty>
Rule 80    callfuncpar -> expr store_pquad callfuncparx
Rule 81    callfuncparx -> <empty>
Rule 82    callfuncparx -> , callfuncpar
Rule 83    datatype -> VOID
Rule 84    datatype -> D_BOOL
Rule 85    datatype -> D_STRING
Rule 86    datatype -> D_FLOAT
Rule 87    datatype -> D_INT
Rule 88    check_program -> <empty>
Rule 89    store_init_quad -> <empty>
Rule 90    store_funcm -> <empty>
Rule 91    store_funcv -> <empty>
Rule 92    store_params -> <empty>
Rule 93    store_local_vars -> <empty>
Rule 94    store_mainv -> <empty>
Rule 95    store_op -> <empty>
Rule 96    store_oper -> <empty>
Rule 97    store_const -> <empty>
Rule 98    unload_pv -> <empty>
Rule 99    store_rquad -> <empty>
Rule 100   close_func -> <empty>
Rule 101   store_endif -> <empty>
Rule 102   store_pquad -> <empty>
Rule 103   ver_params -> <empty>
Rule 104   verify_func -> <empty>
Rule 105   add_fstack -> <empty>
Rule 106   end_fstack -> <empty>
Rule 107   store_gosub -> <empty>
Rule 108   store_gotof -> <empty>
Rule 109   store_jump -> <empty>
Rule 110   end_loop -> <empty>

Unused terminals:

    COMMENT

Terminals, with rules where they appear:

(                    : 17 24 38 39 40 43 44 67 78
)                    : 17 24 38 39 40 43 44 67 78
*                    : 65
+                    : 60
,                    : 5 11 21 42 82
-                    : 59
/                    : 64
:                    : 21 22
;                    : 1 2 8 31 32 36 40 43
<                    : 52
=                    : 36
>                    : 54
AND                  : 51
COMMENT              : 
DIFF                 : 50
D_BOOL               : 84
D_FLOAT              : 86
D_INT                : 87
D_STRING             : 85
ELSE                 : 38
EQEQ                 : 49
FALSE                : 76
FLOAT                : 74
FUNC                 : 17 24
GOETHAN              : 55
ID                   : 1 4 5 10 11 17 21 22 36 43 72 78
IF                   : 38 39
INPUT                : 43
INT                  : 14 16 75
LOETHAN              : 53
MAIN                 : 24
OR                   : 48
OUTPUT               : 40
PROG                 : 1
RETURN               : 37
STRING               : 73
TRUE                 : 77
VAR                  : 2 8
VOID                 : 83
WHILE                : 44
[                    : 14 16
]                    : 14 16
error                : 
{                    : 17 24 38 38 39 44
}                    : 17 24 38 38 39 44

Nonterminals, with rules where they appear:

add_fstack           : 78
arexp                : 45 47
arexpextra           : 56 59 60
callfunc             : 68
callfuncpar          : 78 82
callfuncparx         : 80
check_program        : 1
close_func           : 17
compound             : 69
compoundx            : 71
const                : 70
darray               : 10 11
datatype             : 2 8 17 21 22
element              : 66
end_fstack           : 78
end_loop             : 44
expr                 : 32 36 37 38 39 40 42 44 67 80
exprop               : 47
exprx                : 45
factor               : 61 62 64 65
funcontent           : 17 20
functions            : 1 17
gvarids              : 2 5
gvars                : 1 1 2
ifelse               : 30
input                : 28
loop                 : 27
main                 : 1
maincontent          : 24 26
outex                : 40 42
output               : 29
params               : 17 21
program              : 0
returns              : 31
statement            : 20 26 35 35 38 38 39 44
store_const          : 70
store_endif          : 38 39
store_funcm          : 24
store_funcv          : 17
store_gosub          : 78
store_gotof          : 38 39 44
store_gtype          : 2
store_gvars          : 1 1
store_init_quad      : 17
store_jump           : 44
store_local_vars     : 17
store_mainv          : 24
store_op             : 67 67
store_oper           : 36 43 68 69 72
store_params         : 17
store_pquad          : 80
store_rquad          : 37
store_type           : 8
term                 : 56 57 59 60
termx                : 61 64 65
twodarray            : 14
unload_pv            : 27 28 29 30 31 33
var_assign           : 33
varids               : 8 11
vars                 : 8 17 24
ver_params           : 78
verify_func          : 78


state 0

    (0) S' -> . program
    (1) program -> . PROG ID check_program ; gvars store_gvars functions gvars store_gvars main
    PROG            shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .


state 2

    (1) program -> PROG . ID check_program ; gvars store_gvars functions gvars store_gvars main
    ID              shift and go to state 3


state 3

    (1) program -> PROG ID . check_program ; gvars store_gvars functions gvars store_gvars main
    (88) check_program -> .
    ;               reduce using rule 88 (check_program -> .)

    check_program                  shift and go to state 4

state 4

    (1) program -> PROG ID check_program . ; gvars store_gvars functions gvars store_gvars main
    ;               shift and go to state 5


state 5

    (1) program -> PROG ID check_program ; . gvars store_gvars functions gvars store_gvars main
    (2) gvars -> . VAR datatype gvarids store_gtype ; gvars
    (3) gvars -> .
  ! shift/reduce conflict for VAR resolved as shift
    VAR             shift and go to state 7
    VOID            reduce using rule 3 (gvars -> .)
    D_BOOL          reduce using rule 3 (gvars -> .)
    D_STRING        reduce using rule 3 (gvars -> .)
    D_FLOAT         reduce using rule 3 (gvars -> .)
    D_INT           reduce using rule 3 (gvars -> .)
    FUNC            reduce using rule 3 (gvars -> .)

    gvars                          shift and go to state 6

state 6

    (1) program -> PROG ID check_program ; gvars . store_gvars functions gvars store_gvars main
    (6) store_gvars -> .
    VOID            reduce using rule 6 (store_gvars -> .)
    D_BOOL          reduce using rule 6 (store_gvars -> .)
    D_STRING        reduce using rule 6 (store_gvars -> .)
    D_FLOAT         reduce using rule 6 (store_gvars -> .)
    D_INT           reduce using rule 6 (store_gvars -> .)
    VAR             reduce using rule 6 (store_gvars -> .)
    FUNC            reduce using rule 6 (store_gvars -> .)

    store_gvars                    shift and go to state 8

state 7

    (2) gvars -> VAR . datatype gvarids store_gtype ; gvars
    (83) datatype -> . VOID
    (84) datatype -> . D_BOOL
    (85) datatype -> . D_STRING
    (86) datatype -> . D_FLOAT
    (87) datatype -> . D_INT
    VOID            shift and go to state 10
    D_BOOL          shift and go to state 11
    D_STRING        shift and go to state 12
    D_FLOAT         shift and go to state 13
    D_INT           shift and go to state 14

    datatype                       shift and go to state 9

state 8

    (1) program -> PROG ID check_program ; gvars store_gvars . functions gvars store_gvars main
    (17) functions -> . datatype FUNC ID ( params ) store_funcv store_params store_init_quad { vars store_local_vars funcontent } close_func functions
    (18) functions -> .
    (83) datatype -> . VOID
    (84) datatype -> . D_BOOL
    (85) datatype -> . D_STRING
    (86) datatype -> . D_FLOAT
    (87) datatype -> . D_INT
    VAR             reduce using rule 18 (functions -> .)
    FUNC            reduce using rule 18 (functions -> .)
    VOID            shift and go to state 10
    D_BOOL          shift and go to state 11
    D_STRING        shift and go to state 12
    D_FLOAT         shift and go to state 13
    D_INT           shift and go to state 14

    functions                      shift and go to state 15
    datatype                       shift and go to state 16

state 9

    (2) gvars -> VAR datatype . gvarids store_gtype ; gvars
    (4) gvarids -> . ID
    (5) gvarids -> . ID , gvarids
    ID              shift and go to state 18

    gvarids                        shift and go to state 17

state 10

    (83) datatype -> VOID .
    ID              reduce using rule 83 (datatype -> VOID .)
    FUNC            reduce using rule 83 (datatype -> VOID .)
    ,               reduce using rule 83 (datatype -> VOID .)
    )               reduce using rule 83 (datatype -> VOID .)


state 11

    (84) datatype -> D_BOOL .
    ID              reduce using rule 84 (datatype -> D_BOOL .)
    FUNC            reduce using rule 84 (datatype -> D_BOOL .)
    ,               reduce using rule 84 (datatype -> D_BOOL .)
    )               reduce using rule 84 (datatype -> D_BOOL .)


state 12

    (85) datatype -> D_STRING .
    ID              reduce using rule 85 (datatype -> D_STRING .)
    FUNC            reduce using rule 85 (datatype -> D_STRING .)
    ,               reduce using rule 85 (datatype -> D_STRING .)
    )               reduce using rule 85 (datatype -> D_STRING .)


state 13

    (86) datatype -> D_FLOAT .
    ID              reduce using rule 86 (datatype -> D_FLOAT .)
    FUNC            reduce using rule 86 (datatype -> D_FLOAT .)
    ,               reduce using rule 86 (datatype -> D_FLOAT .)
    )               reduce using rule 86 (datatype -> D_FLOAT .)


state 14

    (87) datatype -> D_INT .
    ID              reduce using rule 87 (datatype -> D_INT .)
    FUNC            reduce using rule 87 (datatype -> D_INT .)
    ,               reduce using rule 87 (datatype -> D_INT .)
    )               reduce using rule 87 (datatype -> D_INT .)


state 15

    (1) program -> PROG ID check_program ; gvars store_gvars functions . gvars store_gvars main
    (2) gvars -> . VAR datatype gvarids store_gtype ; gvars
    (3) gvars -> .
    VAR             shift and go to state 7
    FUNC            reduce using rule 3 (gvars -> .)

    gvars                          shift and go to state 19

state 16

    (17) functions -> datatype . FUNC ID ( params ) store_funcv store_params store_init_quad { vars store_local_vars funcontent } close_func functions
    FUNC            shift and go to state 20


state 17

    (2) gvars -> VAR datatype gvarids . store_gtype ; gvars
    (7) store_gtype -> .
    ;               reduce using rule 7 (store_gtype -> .)

    store_gtype                    shift and go to state 21

state 18

    (4) gvarids -> ID .
    (5) gvarids -> ID . , gvarids
    ;               reduce using rule 4 (gvarids -> ID .)
    ,               shift and go to state 22


state 19

    (1) program -> PROG ID check_program ; gvars store_gvars functions gvars . store_gvars main
    (6) store_gvars -> .
    FUNC            reduce using rule 6 (store_gvars -> .)

    store_gvars                    shift and go to state 23

state 20

    (17) functions -> datatype FUNC . ID ( params ) store_funcv store_params store_init_quad { vars store_local_vars funcontent } close_func functions
    ID              shift and go to state 24


state 21

    (2) gvars -> VAR datatype gvarids store_gtype . ; gvars
    ;               shift and go to state 25


state 22

    (5) gvarids -> ID , . gvarids
    (4) gvarids -> . ID
    (5) gvarids -> . ID , gvarids
    ID              shift and go to state 18

    gvarids                        shift and go to state 26

state 23

    (1) program -> PROG ID check_program ; gvars store_gvars functions gvars store_gvars . main
    (24) main -> . FUNC MAIN ( ) store_funcm { vars store_mainv maincontent }
    FUNC            shift and go to state 28

    main                           shift and go to state 27

state 24

    (17) functions -> datatype FUNC ID . ( params ) store_funcv store_params store_init_quad { vars store_local_vars funcontent } close_func functions
    (               shift and go to state 29


state 25

    (2) gvars -> VAR datatype gvarids store_gtype ; . gvars
    (2) gvars -> . VAR datatype gvarids store_gtype ; gvars
    (3) gvars -> .
  ! shift/reduce conflict for VAR resolved as shift
    VAR             shift and go to state 7
    VOID            reduce using rule 3 (gvars -> .)
    D_BOOL          reduce using rule 3 (gvars -> .)
    D_STRING        reduce using rule 3 (gvars -> .)
    D_FLOAT         reduce using rule 3 (gvars -> .)
    D_INT           reduce using rule 3 (gvars -> .)
    FUNC            reduce using rule 3 (gvars -> .)

    gvars                          shift and go to state 30

state 26

    (5) gvarids -> ID , gvarids .
    ;               reduce using rule 5 (gvarids -> ID , gvarids .)


state 27

    (1) program -> PROG ID check_program ; gvars store_gvars functions gvars store_gvars main .
    $end            reduce using rule 1 (program -> PROG ID check_program ; gvars store_gvars functions gvars store_gvars main .)


state 28

    (24) main -> FUNC . MAIN ( ) store_funcm { vars store_mainv maincontent }
    MAIN            shift and go to state 31


state 29

    (17) functions -> datatype FUNC ID ( . params ) store_funcv store_params store_init_quad { vars store_local_vars funcontent } close_func functions
    (21) params -> . ID : datatype , params
    (22) params -> . ID : datatype
    (23) params -> .
    ID              shift and go to state 32
    )               reduce using rule 23 (params -> .)

    params                         shift and go to state 33

state 30

    (2) gvars -> VAR datatype gvarids store_gtype ; gvars .
    VOID            reduce using rule 2 (gvars -> VAR datatype gvarids store_gtype ; gvars .)
    D_BOOL          reduce using rule 2 (gvars -> VAR datatype gvarids store_gtype ; gvars .)
    D_STRING        reduce using rule 2 (gvars -> VAR datatype gvarids store_gtype ; gvars .)
    D_FLOAT         reduce using rule 2 (gvars -> VAR datatype gvarids store_gtype ; gvars .)
    D_INT           reduce using rule 2 (gvars -> VAR datatype gvarids store_gtype ; gvars .)
    VAR             reduce using rule 2 (gvars -> VAR datatype gvarids store_gtype ; gvars .)
    FUNC            reduce using rule 2 (gvars -> VAR datatype gvarids store_gtype ; gvars .)


state 31

    (24) main -> FUNC MAIN . ( ) store_funcm { vars store_mainv maincontent }
    (               shift and go to state 34


state 32

    (21) params -> ID . : datatype , params
    (22) params -> ID . : datatype
    :               shift and go to state 35


state 33

    (17) functions -> datatype FUNC ID ( params . ) store_funcv store_params store_init_quad { vars store_local_vars funcontent } close_func functions
    )               shift and go to state 36


state 34

    (24) main -> FUNC MAIN ( . ) store_funcm { vars store_mainv maincontent }
    )               shift and go to state 37


state 35

    (21) params -> ID : . datatype , params
    (22) params -> ID : . datatype
    (83) datatype -> . VOID
    (84) datatype -> . D_BOOL
    (85) datatype -> . D_STRING
    (86) datatype -> . D_FLOAT
    (87) datatype -> . D_INT
    VOID            shift and go to state 10
    D_BOOL          shift and go to state 11
    D_STRING        shift and go to state 12
    D_FLOAT         shift and go to state 13
    D_INT           shift and go to state 14

    datatype                       shift and go to state 38

state 36

    (17) functions -> datatype FUNC ID ( params ) . store_funcv store_params store_init_quad { vars store_local_vars funcontent } close_func functions
    (91) store_funcv -> .
    {               reduce using rule 91 (store_funcv -> .)

    store_funcv                    shift and go to state 39

state 37

    (24) main -> FUNC MAIN ( ) . store_funcm { vars store_mainv maincontent }
    (90) store_funcm -> .
    {               reduce using rule 90 (store_funcm -> .)

    store_funcm                    shift and go to state 40

state 38

    (21) params -> ID : datatype . , params
    (22) params -> ID : datatype .
    ,               shift and go to state 41
    )               reduce using rule 22 (params -> ID : datatype .)


state 39

    (17) functions -> datatype FUNC ID ( params ) store_funcv . store_params store_init_quad { vars store_local_vars funcontent } close_func functions
    (92) store_params -> .
    {               reduce using rule 92 (store_params -> .)

    store_params                   shift and go to state 42

state 40

    (24) main -> FUNC MAIN ( ) store_funcm . { vars store_mainv maincontent }
    {               shift and go to state 43


state 41

    (21) params -> ID : datatype , . params
    (21) params -> . ID : datatype , params
    (22) params -> . ID : datatype
    (23) params -> .
    ID              shift and go to state 32
    )               reduce using rule 23 (params -> .)

    params                         shift and go to state 44

state 42

    (17) functions -> datatype FUNC ID ( params ) store_funcv store_params . store_init_quad { vars store_local_vars funcontent } close_func functions
    (89) store_init_quad -> .
    {               reduce using rule 89 (store_init_quad -> .)

    store_init_quad                shift and go to state 45

state 43

    (24) main -> FUNC MAIN ( ) store_funcm { . vars store_mainv maincontent }
    (8) vars -> . VAR datatype varids store_type ; vars
    (9) vars -> .
    VAR             shift and go to state 47
    WHILE           reduce using rule 9 (vars -> .)
    INPUT           reduce using rule 9 (vars -> .)
    OUTPUT          reduce using rule 9 (vars -> .)
    IF              reduce using rule 9 (vars -> .)
    RETURN          reduce using rule 9 (vars -> .)
    ID              reduce using rule 9 (vars -> .)
    (               reduce using rule 9 (vars -> .)
    STRING          reduce using rule 9 (vars -> .)
    FLOAT           reduce using rule 9 (vars -> .)
    INT             reduce using rule 9 (vars -> .)
    FALSE           reduce using rule 9 (vars -> .)
    TRUE            reduce using rule 9 (vars -> .)
    }               reduce using rule 9 (vars -> .)

    vars                           shift and go to state 46

state 44

    (21) params -> ID : datatype , params .
    )               reduce using rule 21 (params -> ID : datatype , params .)


state 45

    (17) functions -> datatype FUNC ID ( params ) store_funcv store_params store_init_quad . { vars store_local_vars funcontent } close_func functions
    {               shift and go to state 48


state 46

    (24) main -> FUNC MAIN ( ) store_funcm { vars . store_mainv maincontent }
    (94) store_mainv -> .
    WHILE           reduce using rule 94 (store_mainv -> .)
    INPUT           reduce using rule 94 (store_mainv -> .)
    OUTPUT          reduce using rule 94 (store_mainv -> .)
    IF              reduce using rule 94 (store_mainv -> .)
    RETURN          reduce using rule 94 (store_mainv -> .)
    ID              reduce using rule 94 (store_mainv -> .)
    (               reduce using rule 94 (store_mainv -> .)
    STRING          reduce using rule 94 (store_mainv -> .)
    FLOAT           reduce using rule 94 (store_mainv -> .)
    INT             reduce using rule 94 (store_mainv -> .)
    FALSE           reduce using rule 94 (store_mainv -> .)
    TRUE            reduce using rule 94 (store_mainv -> .)
    }               reduce using rule 94 (store_mainv -> .)

    store_mainv                    shift and go to state 49

state 47

    (8) vars -> VAR . datatype varids store_type ; vars
    (83) datatype -> . VOID
    (84) datatype -> . D_BOOL
    (85) datatype -> . D_STRING
    (86) datatype -> . D_FLOAT
    (87) datatype -> . D_INT
    VOID            shift and go to state 10
    D_BOOL          shift and go to state 11
    D_STRING        shift and go to state 12
    D_FLOAT         shift and go to state 13
    D_INT           shift and go to state 14

    datatype                       shift and go to state 50

state 48

    (17) functions -> datatype FUNC ID ( params ) store_funcv store_params store_init_quad { . vars store_local_vars funcontent } close_func functions
    (8) vars -> . VAR datatype varids store_type ; vars
    (9) vars -> .
    VAR             shift and go to state 47
    WHILE           reduce using rule 9 (vars -> .)
    INPUT           reduce using rule 9 (vars -> .)
    OUTPUT          reduce using rule 9 (vars -> .)
    IF              reduce using rule 9 (vars -> .)
    RETURN          reduce using rule 9 (vars -> .)
    ID              reduce using rule 9 (vars -> .)
    (               reduce using rule 9 (vars -> .)
    STRING          reduce using rule 9 (vars -> .)
    FLOAT           reduce using rule 9 (vars -> .)
    INT             reduce using rule 9 (vars -> .)
    FALSE           reduce using rule 9 (vars -> .)
    TRUE            reduce using rule 9 (vars -> .)
    }               reduce using rule 9 (vars -> .)

    vars                           shift and go to state 51

state 49

    (24) main -> FUNC MAIN ( ) store_funcm { vars store_mainv . maincontent }
    (25) maincontent -> .
    (26) maincontent -> . statement maincontent
    (27) statement -> . loop unload_pv
    (28) statement -> . input unload_pv
    (29) statement -> . output unload_pv
    (30) statement -> . ifelse unload_pv
    (31) statement -> . returns unload_pv ;
    (32) statement -> . expr ;
    (33) statement -> . var_assign unload_pv
    (34) statement -> .
    (35) statement -> . statement statement
    (44) loop -> . WHILE store_jump ( expr ) store_gotof { statement } end_loop
    (43) input -> . INPUT ( ID store_oper ) ;
    (40) output -> . OUTPUT ( expr outex ) ;
    (38) ifelse -> . IF ( expr ) store_gotof { statement } ELSE store_endif { statement }
    (39) ifelse -> . IF ( expr ) store_gotof { statement } store_endif
    (37) returns -> . RETURN expr store_rquad
    (45) expr -> . arexp exprx
    (36) var_assign -> . ID store_oper = expr ;
    (56) arexp -> . term arexpextra
    (57) arexp -> . term
    (61) term -> . factor termx
    (62) term -> . factor
    (66) factor -> . element
    (67) factor -> . ( store_op expr ) store_op
    (68) element -> . callfunc store_oper
    (69) element -> . compound store_oper
    (70) element -> . const store_const
    (78) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (71) compound -> . compoundx
    (73) const -> . STRING
    (74) const -> . FLOAT
    (75) const -> . INT
    (76) const -> . FALSE
    (77) const -> . TRUE
    (72) compoundx -> . ID store_oper
  ! reduce/reduce conflict for } resolved using rule 25 (maincontent -> .)
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for OUTPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    }               reduce using rule 25 (maincontent -> .)
    WHILE           shift and go to state 62
    INPUT           shift and go to state 63
    OUTPUT          shift and go to state 65
    IF              shift and go to state 66
    RETURN          shift and go to state 67
    ID              shift and go to state 64
    (               shift and go to state 52
    STRING          shift and go to state 76
    FLOAT           shift and go to state 77
    INT             shift and go to state 78
    FALSE           shift and go to state 79
    TRUE            shift and go to state 80

    maincontent                    shift and go to state 53
    statement                      shift and go to state 54
    loop                           shift and go to state 55
    input                          shift and go to state 56
    output                         shift and go to state 57
    ifelse                         shift and go to state 58
    returns                        shift and go to state 59
    expr                           shift and go to state 60
    var_assign                     shift and go to state 61
    arexp                          shift and go to state 68
    term                           shift and go to state 69
    factor                         shift and go to state 70
    element                        shift and go to state 71
    callfunc                       shift and go to state 72
    compound                       shift and go to state 73
    const                          shift and go to state 74
    compoundx                      shift and go to state 75

state 50

    (8) vars -> VAR datatype . varids store_type ; vars
    (10) varids -> . ID darray
    (11) varids -> . ID darray , varids
    ID              shift and go to state 82

    varids                         shift and go to state 81

state 51

    (17) functions -> datatype FUNC ID ( params ) store_funcv store_params store_init_quad { vars . store_local_vars funcontent } close_func functions
    (93) store_local_vars -> .
    WHILE           reduce using rule 93 (store_local_vars -> .)
    INPUT           reduce using rule 93 (store_local_vars -> .)
    OUTPUT          reduce using rule 93 (store_local_vars -> .)
    IF              reduce using rule 93 (store_local_vars -> .)
    RETURN          reduce using rule 93 (store_local_vars -> .)
    ID              reduce using rule 93 (store_local_vars -> .)
    (               reduce using rule 93 (store_local_vars -> .)
    STRING          reduce using rule 93 (store_local_vars -> .)
    FLOAT           reduce using rule 93 (store_local_vars -> .)
    INT             reduce using rule 93 (store_local_vars -> .)
    FALSE           reduce using rule 93 (store_local_vars -> .)
    TRUE            reduce using rule 93 (store_local_vars -> .)
    }               reduce using rule 93 (store_local_vars -> .)

    store_local_vars               shift and go to state 83

state 52

    (67) factor -> ( . store_op expr ) store_op
    (95) store_op -> .
    (               reduce using rule 95 (store_op -> .)
    ID              reduce using rule 95 (store_op -> .)
    STRING          reduce using rule 95 (store_op -> .)
    FLOAT           reduce using rule 95 (store_op -> .)
    INT             reduce using rule 95 (store_op -> .)
    FALSE           reduce using rule 95 (store_op -> .)
    TRUE            reduce using rule 95 (store_op -> .)

    store_op                       shift and go to state 84

state 53

    (24) main -> FUNC MAIN ( ) store_funcm { vars store_mainv maincontent . }
    }               shift and go to state 85


state 54

    (26) maincontent -> statement . maincontent
    (35) statement -> statement . statement
    (25) maincontent -> .
    (26) maincontent -> . statement maincontent
    (27) statement -> . loop unload_pv
    (28) statement -> . input unload_pv
    (29) statement -> . output unload_pv
    (30) statement -> . ifelse unload_pv
    (31) statement -> . returns unload_pv ;
    (32) statement -> . expr ;
    (33) statement -> . var_assign unload_pv
    (34) statement -> .
    (35) statement -> . statement statement
    (44) loop -> . WHILE store_jump ( expr ) store_gotof { statement } end_loop
    (43) input -> . INPUT ( ID store_oper ) ;
    (40) output -> . OUTPUT ( expr outex ) ;
    (38) ifelse -> . IF ( expr ) store_gotof { statement } ELSE store_endif { statement }
    (39) ifelse -> . IF ( expr ) store_gotof { statement } store_endif
    (37) returns -> . RETURN expr store_rquad
    (45) expr -> . arexp exprx
    (36) var_assign -> . ID store_oper = expr ;
    (56) arexp -> . term arexpextra
    (57) arexp -> . term
    (61) term -> . factor termx
    (62) term -> . factor
    (66) factor -> . element
    (67) factor -> . ( store_op expr ) store_op
    (68) element -> . callfunc store_oper
    (69) element -> . compound store_oper
    (70) element -> . const store_const
    (78) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (71) compound -> . compoundx
    (73) const -> . STRING
    (74) const -> . FLOAT
    (75) const -> . INT
    (76) const -> . FALSE
    (77) const -> . TRUE
    (72) compoundx -> . ID store_oper
  ! reduce/reduce conflict for } resolved using rule 25 (maincontent -> .)
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for OUTPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    }               reduce using rule 25 (maincontent -> .)
    WHILE           shift and go to state 62
    INPUT           shift and go to state 63
    OUTPUT          shift and go to state 65
    IF              shift and go to state 66
    RETURN          shift and go to state 67
    ID              shift and go to state 64
    (               shift and go to state 52
    STRING          shift and go to state 76
    FLOAT           shift and go to state 77
    INT             shift and go to state 78
    FALSE           shift and go to state 79
    TRUE            shift and go to state 80

    statement                      shift and go to state 86
    maincontent                    shift and go to state 87
    loop                           shift and go to state 55
    input                          shift and go to state 56
    output                         shift and go to state 57
    ifelse                         shift and go to state 58
    returns                        shift and go to state 59
    expr                           shift and go to state 60
    var_assign                     shift and go to state 61
    arexp                          shift and go to state 68
    term                           shift and go to state 69
    factor                         shift and go to state 70
    element                        shift and go to state 71
    callfunc                       shift and go to state 72
    compound                       shift and go to state 73
    const                          shift and go to state 74
    compoundx                      shift and go to state 75

state 55

    (27) statement -> loop . unload_pv
    (98) unload_pv -> .
    WHILE           reduce using rule 98 (unload_pv -> .)
    INPUT           reduce using rule 98 (unload_pv -> .)
    OUTPUT          reduce using rule 98 (unload_pv -> .)
    IF              reduce using rule 98 (unload_pv -> .)
    RETURN          reduce using rule 98 (unload_pv -> .)
    ID              reduce using rule 98 (unload_pv -> .)
    (               reduce using rule 98 (unload_pv -> .)
    STRING          reduce using rule 98 (unload_pv -> .)
    FLOAT           reduce using rule 98 (unload_pv -> .)
    INT             reduce using rule 98 (unload_pv -> .)
    FALSE           reduce using rule 98 (unload_pv -> .)
    TRUE            reduce using rule 98 (unload_pv -> .)
    }               reduce using rule 98 (unload_pv -> .)

    unload_pv                      shift and go to state 88

state 56

    (28) statement -> input . unload_pv
    (98) unload_pv -> .
    WHILE           reduce using rule 98 (unload_pv -> .)
    INPUT           reduce using rule 98 (unload_pv -> .)
    OUTPUT          reduce using rule 98 (unload_pv -> .)
    IF              reduce using rule 98 (unload_pv -> .)
    RETURN          reduce using rule 98 (unload_pv -> .)
    ID              reduce using rule 98 (unload_pv -> .)
    (               reduce using rule 98 (unload_pv -> .)
    STRING          reduce using rule 98 (unload_pv -> .)
    FLOAT           reduce using rule 98 (unload_pv -> .)
    INT             reduce using rule 98 (unload_pv -> .)
    FALSE           reduce using rule 98 (unload_pv -> .)
    TRUE            reduce using rule 98 (unload_pv -> .)
    }               reduce using rule 98 (unload_pv -> .)

    unload_pv                      shift and go to state 89

state 57

    (29) statement -> output . unload_pv
    (98) unload_pv -> .
    WHILE           reduce using rule 98 (unload_pv -> .)
    INPUT           reduce using rule 98 (unload_pv -> .)
    OUTPUT          reduce using rule 98 (unload_pv -> .)
    IF              reduce using rule 98 (unload_pv -> .)
    RETURN          reduce using rule 98 (unload_pv -> .)
    ID              reduce using rule 98 (unload_pv -> .)
    (               reduce using rule 98 (unload_pv -> .)
    STRING          reduce using rule 98 (unload_pv -> .)
    FLOAT           reduce using rule 98 (unload_pv -> .)
    INT             reduce using rule 98 (unload_pv -> .)
    FALSE           reduce using rule 98 (unload_pv -> .)
    TRUE            reduce using rule 98 (unload_pv -> .)
    }               reduce using rule 98 (unload_pv -> .)

    unload_pv                      shift and go to state 90

state 58

    (30) statement -> ifelse . unload_pv
    (98) unload_pv -> .
    WHILE           reduce using rule 98 (unload_pv -> .)
    INPUT           reduce using rule 98 (unload_pv -> .)
    OUTPUT          reduce using rule 98 (unload_pv -> .)
    IF              reduce using rule 98 (unload_pv -> .)
    RETURN          reduce using rule 98 (unload_pv -> .)
    ID              reduce using rule 98 (unload_pv -> .)
    (               reduce using rule 98 (unload_pv -> .)
    STRING          reduce using rule 98 (unload_pv -> .)
    FLOAT           reduce using rule 98 (unload_pv -> .)
    INT             reduce using rule 98 (unload_pv -> .)
    FALSE           reduce using rule 98 (unload_pv -> .)
    TRUE            reduce using rule 98 (unload_pv -> .)
    }               reduce using rule 98 (unload_pv -> .)

    unload_pv                      shift and go to state 91

state 59

    (31) statement -> returns . unload_pv ;
    (98) unload_pv -> .
    ;               reduce using rule 98 (unload_pv -> .)

    unload_pv                      shift and go to state 92

state 60

    (32) statement -> expr . ;
    ;               shift and go to state 93


state 61

    (33) statement -> var_assign . unload_pv
    (98) unload_pv -> .
    WHILE           reduce using rule 98 (unload_pv -> .)
    INPUT           reduce using rule 98 (unload_pv -> .)
    OUTPUT          reduce using rule 98 (unload_pv -> .)
    IF              reduce using rule 98 (unload_pv -> .)
    RETURN          reduce using rule 98 (unload_pv -> .)
    ID              reduce using rule 98 (unload_pv -> .)
    (               reduce using rule 98 (unload_pv -> .)
    STRING          reduce using rule 98 (unload_pv -> .)
    FLOAT           reduce using rule 98 (unload_pv -> .)
    INT             reduce using rule 98 (unload_pv -> .)
    FALSE           reduce using rule 98 (unload_pv -> .)
    TRUE            reduce using rule 98 (unload_pv -> .)
    }               reduce using rule 98 (unload_pv -> .)

    unload_pv                      shift and go to state 94

state 62

    (44) loop -> WHILE . store_jump ( expr ) store_gotof { statement } end_loop
    (109) store_jump -> .
    (               reduce using rule 109 (store_jump -> .)

    store_jump                     shift and go to state 95

state 63

    (43) input -> INPUT . ( ID store_oper ) ;
    (               shift and go to state 96


state 64

    (36) var_assign -> ID . store_oper = expr ;
    (78) callfunc -> ID . verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (72) compoundx -> ID . store_oper
    (96) store_oper -> .
    (104) verify_func -> .
    =               reduce using rule 96 (store_oper -> .)
    /               reduce using rule 96 (store_oper -> .)
    *               reduce using rule 96 (store_oper -> .)
    -               reduce using rule 96 (store_oper -> .)
    +               reduce using rule 96 (store_oper -> .)
    OR              reduce using rule 96 (store_oper -> .)
    EQEQ            reduce using rule 96 (store_oper -> .)
    DIFF            reduce using rule 96 (store_oper -> .)
    AND             reduce using rule 96 (store_oper -> .)
    <               reduce using rule 96 (store_oper -> .)
    LOETHAN         reduce using rule 96 (store_oper -> .)
    >               reduce using rule 96 (store_oper -> .)
    GOETHAN         reduce using rule 96 (store_oper -> .)
    ;               reduce using rule 96 (store_oper -> .)
    (               reduce using rule 104 (verify_func -> .)

    store_oper                     shift and go to state 97
    verify_func                    shift and go to state 98

state 65

    (40) output -> OUTPUT . ( expr outex ) ;
    (               shift and go to state 99


state 66

    (38) ifelse -> IF . ( expr ) store_gotof { statement } ELSE store_endif { statement }
    (39) ifelse -> IF . ( expr ) store_gotof { statement } store_endif
    (               shift and go to state 100


state 67

    (37) returns -> RETURN . expr store_rquad
    (45) expr -> . arexp exprx
    (56) arexp -> . term arexpextra
    (57) arexp -> . term
    (61) term -> . factor termx
    (62) term -> . factor
    (66) factor -> . element
    (67) factor -> . ( store_op expr ) store_op
    (68) element -> . callfunc store_oper
    (69) element -> . compound store_oper
    (70) element -> . const store_const
    (78) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (71) compound -> . compoundx
    (73) const -> . STRING
    (74) const -> . FLOAT
    (75) const -> . INT
    (76) const -> . FALSE
    (77) const -> . TRUE
    (72) compoundx -> . ID store_oper
    (               shift and go to state 52
    ID              shift and go to state 102
    STRING          shift and go to state 76
    FLOAT           shift and go to state 77
    INT             shift and go to state 78
    FALSE           shift and go to state 79
    TRUE            shift and go to state 80

    expr                           shift and go to state 101
    arexp                          shift and go to state 68
    term                           shift and go to state 69
    factor                         shift and go to state 70
    element                        shift and go to state 71
    callfunc                       shift and go to state 72
    compound                       shift and go to state 73
    const                          shift and go to state 74
    compoundx                      shift and go to state 75

state 68

    (45) expr -> arexp . exprx
    (46) exprx -> .
    (47) exprx -> . exprop arexp
    (48) exprop -> . OR
    (49) exprop -> . EQEQ
    (50) exprop -> . DIFF
    (51) exprop -> . AND
    (52) exprop -> . <
    (53) exprop -> . LOETHAN
    (54) exprop -> . >
    (55) exprop -> . GOETHAN
    ;               reduce using rule 46 (exprx -> .)
    )               reduce using rule 46 (exprx -> .)
    ,               reduce using rule 46 (exprx -> .)
    OR              shift and go to state 105
    EQEQ            shift and go to state 106
    DIFF            shift and go to state 107
    AND             shift and go to state 108
    <               shift and go to state 109
    LOETHAN         shift and go to state 110
    >               shift and go to state 111
    GOETHAN         shift and go to state 112

    exprx                          shift and go to state 103
    exprop                         shift and go to state 104

state 69

    (56) arexp -> term . arexpextra
    (57) arexp -> term .
    (58) arexpextra -> .
    (59) arexpextra -> . - term arexpextra
    (60) arexpextra -> . + term arexpextra
  ! reduce/reduce conflict for OR resolved using rule 57 (arexp -> term .)
  ! reduce/reduce conflict for EQEQ resolved using rule 57 (arexp -> term .)
  ! reduce/reduce conflict for DIFF resolved using rule 57 (arexp -> term .)
  ! reduce/reduce conflict for AND resolved using rule 57 (arexp -> term .)
  ! reduce/reduce conflict for < resolved using rule 57 (arexp -> term .)
  ! reduce/reduce conflict for LOETHAN resolved using rule 57 (arexp -> term .)
  ! reduce/reduce conflict for > resolved using rule 57 (arexp -> term .)
  ! reduce/reduce conflict for GOETHAN resolved using rule 57 (arexp -> term .)
  ! reduce/reduce conflict for ; resolved using rule 57 (arexp -> term .)
  ! reduce/reduce conflict for ) resolved using rule 57 (arexp -> term .)
  ! reduce/reduce conflict for , resolved using rule 57 (arexp -> term .)
    OR              reduce using rule 57 (arexp -> term .)
    EQEQ            reduce using rule 57 (arexp -> term .)
    DIFF            reduce using rule 57 (arexp -> term .)
    AND             reduce using rule 57 (arexp -> term .)
    <               reduce using rule 57 (arexp -> term .)
    LOETHAN         reduce using rule 57 (arexp -> term .)
    >               reduce using rule 57 (arexp -> term .)
    GOETHAN         reduce using rule 57 (arexp -> term .)
    ;               reduce using rule 57 (arexp -> term .)
    )               reduce using rule 57 (arexp -> term .)
    ,               reduce using rule 57 (arexp -> term .)
    -               shift and go to state 114
    +               shift and go to state 115

    arexpextra                     shift and go to state 113

state 70

    (61) term -> factor . termx
    (62) term -> factor .
    (63) termx -> .
    (64) termx -> . / factor termx
    (65) termx -> . * factor termx
  ! reduce/reduce conflict for - resolved using rule 62 (term -> factor .)
  ! reduce/reduce conflict for + resolved using rule 62 (term -> factor .)
  ! reduce/reduce conflict for OR resolved using rule 62 (term -> factor .)
  ! reduce/reduce conflict for EQEQ resolved using rule 62 (term -> factor .)
  ! reduce/reduce conflict for DIFF resolved using rule 62 (term -> factor .)
  ! reduce/reduce conflict for AND resolved using rule 62 (term -> factor .)
  ! reduce/reduce conflict for < resolved using rule 62 (term -> factor .)
  ! reduce/reduce conflict for LOETHAN resolved using rule 62 (term -> factor .)
  ! reduce/reduce conflict for > resolved using rule 62 (term -> factor .)
  ! reduce/reduce conflict for GOETHAN resolved using rule 62 (term -> factor .)
  ! reduce/reduce conflict for ; resolved using rule 62 (term -> factor .)
  ! reduce/reduce conflict for ) resolved using rule 62 (term -> factor .)
  ! reduce/reduce conflict for , resolved using rule 62 (term -> factor .)
    -               reduce using rule 62 (term -> factor .)
    +               reduce using rule 62 (term -> factor .)
    OR              reduce using rule 62 (term -> factor .)
    EQEQ            reduce using rule 62 (term -> factor .)
    DIFF            reduce using rule 62 (term -> factor .)
    AND             reduce using rule 62 (term -> factor .)
    <               reduce using rule 62 (term -> factor .)
    LOETHAN         reduce using rule 62 (term -> factor .)
    >               reduce using rule 62 (term -> factor .)
    GOETHAN         reduce using rule 62 (term -> factor .)
    ;               reduce using rule 62 (term -> factor .)
    )               reduce using rule 62 (term -> factor .)
    ,               reduce using rule 62 (term -> factor .)
    /               shift and go to state 117
    *               shift and go to state 118

    termx                          shift and go to state 116

state 71

    (66) factor -> element .
    /               reduce using rule 66 (factor -> element .)
    *               reduce using rule 66 (factor -> element .)
    -               reduce using rule 66 (factor -> element .)
    +               reduce using rule 66 (factor -> element .)
    OR              reduce using rule 66 (factor -> element .)
    EQEQ            reduce using rule 66 (factor -> element .)
    DIFF            reduce using rule 66 (factor -> element .)
    AND             reduce using rule 66 (factor -> element .)
    <               reduce using rule 66 (factor -> element .)
    LOETHAN         reduce using rule 66 (factor -> element .)
    >               reduce using rule 66 (factor -> element .)
    GOETHAN         reduce using rule 66 (factor -> element .)
    ;               reduce using rule 66 (factor -> element .)
    )               reduce using rule 66 (factor -> element .)
    ,               reduce using rule 66 (factor -> element .)


state 72

    (68) element -> callfunc . store_oper
    (96) store_oper -> .
    /               reduce using rule 96 (store_oper -> .)
    *               reduce using rule 96 (store_oper -> .)
    -               reduce using rule 96 (store_oper -> .)
    +               reduce using rule 96 (store_oper -> .)
    OR              reduce using rule 96 (store_oper -> .)
    EQEQ            reduce using rule 96 (store_oper -> .)
    DIFF            reduce using rule 96 (store_oper -> .)
    AND             reduce using rule 96 (store_oper -> .)
    <               reduce using rule 96 (store_oper -> .)
    LOETHAN         reduce using rule 96 (store_oper -> .)
    >               reduce using rule 96 (store_oper -> .)
    GOETHAN         reduce using rule 96 (store_oper -> .)
    ;               reduce using rule 96 (store_oper -> .)
    )               reduce using rule 96 (store_oper -> .)
    ,               reduce using rule 96 (store_oper -> .)

    store_oper                     shift and go to state 119

state 73

    (69) element -> compound . store_oper
    (96) store_oper -> .
    /               reduce using rule 96 (store_oper -> .)
    *               reduce using rule 96 (store_oper -> .)
    -               reduce using rule 96 (store_oper -> .)
    +               reduce using rule 96 (store_oper -> .)
    OR              reduce using rule 96 (store_oper -> .)
    EQEQ            reduce using rule 96 (store_oper -> .)
    DIFF            reduce using rule 96 (store_oper -> .)
    AND             reduce using rule 96 (store_oper -> .)
    <               reduce using rule 96 (store_oper -> .)
    LOETHAN         reduce using rule 96 (store_oper -> .)
    >               reduce using rule 96 (store_oper -> .)
    GOETHAN         reduce using rule 96 (store_oper -> .)
    ;               reduce using rule 96 (store_oper -> .)
    )               reduce using rule 96 (store_oper -> .)
    ,               reduce using rule 96 (store_oper -> .)

    store_oper                     shift and go to state 120

state 74

    (70) element -> const . store_const
    (97) store_const -> .
    /               reduce using rule 97 (store_const -> .)
    *               reduce using rule 97 (store_const -> .)
    -               reduce using rule 97 (store_const -> .)
    +               reduce using rule 97 (store_const -> .)
    OR              reduce using rule 97 (store_const -> .)
    EQEQ            reduce using rule 97 (store_const -> .)
    DIFF            reduce using rule 97 (store_const -> .)
    AND             reduce using rule 97 (store_const -> .)
    <               reduce using rule 97 (store_const -> .)
    LOETHAN         reduce using rule 97 (store_const -> .)
    >               reduce using rule 97 (store_const -> .)
    GOETHAN         reduce using rule 97 (store_const -> .)
    ;               reduce using rule 97 (store_const -> .)
    )               reduce using rule 97 (store_const -> .)
    ,               reduce using rule 97 (store_const -> .)

    store_const                    shift and go to state 121

state 75

    (71) compound -> compoundx .
    /               reduce using rule 71 (compound -> compoundx .)
    *               reduce using rule 71 (compound -> compoundx .)
    -               reduce using rule 71 (compound -> compoundx .)
    +               reduce using rule 71 (compound -> compoundx .)
    OR              reduce using rule 71 (compound -> compoundx .)
    EQEQ            reduce using rule 71 (compound -> compoundx .)
    DIFF            reduce using rule 71 (compound -> compoundx .)
    AND             reduce using rule 71 (compound -> compoundx .)
    <               reduce using rule 71 (compound -> compoundx .)
    LOETHAN         reduce using rule 71 (compound -> compoundx .)
    >               reduce using rule 71 (compound -> compoundx .)
    GOETHAN         reduce using rule 71 (compound -> compoundx .)
    ;               reduce using rule 71 (compound -> compoundx .)
    )               reduce using rule 71 (compound -> compoundx .)
    ,               reduce using rule 71 (compound -> compoundx .)


state 76

    (73) const -> STRING .
    /               reduce using rule 73 (const -> STRING .)
    *               reduce using rule 73 (const -> STRING .)
    -               reduce using rule 73 (const -> STRING .)
    +               reduce using rule 73 (const -> STRING .)
    OR              reduce using rule 73 (const -> STRING .)
    EQEQ            reduce using rule 73 (const -> STRING .)
    DIFF            reduce using rule 73 (const -> STRING .)
    AND             reduce using rule 73 (const -> STRING .)
    <               reduce using rule 73 (const -> STRING .)
    LOETHAN         reduce using rule 73 (const -> STRING .)
    >               reduce using rule 73 (const -> STRING .)
    GOETHAN         reduce using rule 73 (const -> STRING .)
    ;               reduce using rule 73 (const -> STRING .)
    )               reduce using rule 73 (const -> STRING .)
    ,               reduce using rule 73 (const -> STRING .)


state 77

    (74) const -> FLOAT .
    /               reduce using rule 74 (const -> FLOAT .)
    *               reduce using rule 74 (const -> FLOAT .)
    -               reduce using rule 74 (const -> FLOAT .)
    +               reduce using rule 74 (const -> FLOAT .)
    OR              reduce using rule 74 (const -> FLOAT .)
    EQEQ            reduce using rule 74 (const -> FLOAT .)
    DIFF            reduce using rule 74 (const -> FLOAT .)
    AND             reduce using rule 74 (const -> FLOAT .)
    <               reduce using rule 74 (const -> FLOAT .)
    LOETHAN         reduce using rule 74 (const -> FLOAT .)
    >               reduce using rule 74 (const -> FLOAT .)
    GOETHAN         reduce using rule 74 (const -> FLOAT .)
    ;               reduce using rule 74 (const -> FLOAT .)
    )               reduce using rule 74 (const -> FLOAT .)
    ,               reduce using rule 74 (const -> FLOAT .)


state 78

    (75) const -> INT .
    /               reduce using rule 75 (const -> INT .)
    *               reduce using rule 75 (const -> INT .)
    -               reduce using rule 75 (const -> INT .)
    +               reduce using rule 75 (const -> INT .)
    OR              reduce using rule 75 (const -> INT .)
    EQEQ            reduce using rule 75 (const -> INT .)
    DIFF            reduce using rule 75 (const -> INT .)
    AND             reduce using rule 75 (const -> INT .)
    <               reduce using rule 75 (const -> INT .)
    LOETHAN         reduce using rule 75 (const -> INT .)
    >               reduce using rule 75 (const -> INT .)
    GOETHAN         reduce using rule 75 (const -> INT .)
    ;               reduce using rule 75 (const -> INT .)
    )               reduce using rule 75 (const -> INT .)
    ,               reduce using rule 75 (const -> INT .)


state 79

    (76) const -> FALSE .
    /               reduce using rule 76 (const -> FALSE .)
    *               reduce using rule 76 (const -> FALSE .)
    -               reduce using rule 76 (const -> FALSE .)
    +               reduce using rule 76 (const -> FALSE .)
    OR              reduce using rule 76 (const -> FALSE .)
    EQEQ            reduce using rule 76 (const -> FALSE .)
    DIFF            reduce using rule 76 (const -> FALSE .)
    AND             reduce using rule 76 (const -> FALSE .)
    <               reduce using rule 76 (const -> FALSE .)
    LOETHAN         reduce using rule 76 (const -> FALSE .)
    >               reduce using rule 76 (const -> FALSE .)
    GOETHAN         reduce using rule 76 (const -> FALSE .)
    ;               reduce using rule 76 (const -> FALSE .)
    )               reduce using rule 76 (const -> FALSE .)
    ,               reduce using rule 76 (const -> FALSE .)


state 80

    (77) const -> TRUE .
    /               reduce using rule 77 (const -> TRUE .)
    *               reduce using rule 77 (const -> TRUE .)
    -               reduce using rule 77 (const -> TRUE .)
    +               reduce using rule 77 (const -> TRUE .)
    OR              reduce using rule 77 (const -> TRUE .)
    EQEQ            reduce using rule 77 (const -> TRUE .)
    DIFF            reduce using rule 77 (const -> TRUE .)
    AND             reduce using rule 77 (const -> TRUE .)
    <               reduce using rule 77 (const -> TRUE .)
    LOETHAN         reduce using rule 77 (const -> TRUE .)
    >               reduce using rule 77 (const -> TRUE .)
    GOETHAN         reduce using rule 77 (const -> TRUE .)
    ;               reduce using rule 77 (const -> TRUE .)
    )               reduce using rule 77 (const -> TRUE .)
    ,               reduce using rule 77 (const -> TRUE .)


state 81

    (8) vars -> VAR datatype varids . store_type ; vars
    (12) store_type -> .
    ;               reduce using rule 12 (store_type -> .)

    store_type                     shift and go to state 122

state 82

    (10) varids -> ID . darray
    (11) varids -> ID . darray , varids
    (13) darray -> .
    (14) darray -> . [ INT ] twodarray
    ,               reduce using rule 13 (darray -> .)
    ;               reduce using rule 13 (darray -> .)
    [               shift and go to state 124

    darray                         shift and go to state 123

state 83

    (17) functions -> datatype FUNC ID ( params ) store_funcv store_params store_init_quad { vars store_local_vars . funcontent } close_func functions
    (19) funcontent -> .
    (20) funcontent -> . statement funcontent
    (27) statement -> . loop unload_pv
    (28) statement -> . input unload_pv
    (29) statement -> . output unload_pv
    (30) statement -> . ifelse unload_pv
    (31) statement -> . returns unload_pv ;
    (32) statement -> . expr ;
    (33) statement -> . var_assign unload_pv
    (34) statement -> .
    (35) statement -> . statement statement
    (44) loop -> . WHILE store_jump ( expr ) store_gotof { statement } end_loop
    (43) input -> . INPUT ( ID store_oper ) ;
    (40) output -> . OUTPUT ( expr outex ) ;
    (38) ifelse -> . IF ( expr ) store_gotof { statement } ELSE store_endif { statement }
    (39) ifelse -> . IF ( expr ) store_gotof { statement } store_endif
    (37) returns -> . RETURN expr store_rquad
    (45) expr -> . arexp exprx
    (36) var_assign -> . ID store_oper = expr ;
    (56) arexp -> . term arexpextra
    (57) arexp -> . term
    (61) term -> . factor termx
    (62) term -> . factor
    (66) factor -> . element
    (67) factor -> . ( store_op expr ) store_op
    (68) element -> . callfunc store_oper
    (69) element -> . compound store_oper
    (70) element -> . const store_const
    (78) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (71) compound -> . compoundx
    (73) const -> . STRING
    (74) const -> . FLOAT
    (75) const -> . INT
    (76) const -> . FALSE
    (77) const -> . TRUE
    (72) compoundx -> . ID store_oper
  ! reduce/reduce conflict for } resolved using rule 19 (funcontent -> .)
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for OUTPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    }               reduce using rule 19 (funcontent -> .)
    WHILE           shift and go to state 62
    INPUT           shift and go to state 63
    OUTPUT          shift and go to state 65
    IF              shift and go to state 66
    RETURN          shift and go to state 67
    ID              shift and go to state 64
    (               shift and go to state 52
    STRING          shift and go to state 76
    FLOAT           shift and go to state 77
    INT             shift and go to state 78
    FALSE           shift and go to state 79
    TRUE            shift and go to state 80

    funcontent                     shift and go to state 125
    statement                      shift and go to state 126
    loop                           shift and go to state 55
    input                          shift and go to state 56
    output                         shift and go to state 57
    ifelse                         shift and go to state 58
    returns                        shift and go to state 59
    expr                           shift and go to state 60
    var_assign                     shift and go to state 61
    arexp                          shift and go to state 68
    term                           shift and go to state 69
    factor                         shift and go to state 70
    element                        shift and go to state 71
    callfunc                       shift and go to state 72
    compound                       shift and go to state 73
    const                          shift and go to state 74
    compoundx                      shift and go to state 75

state 84

    (67) factor -> ( store_op . expr ) store_op
    (45) expr -> . arexp exprx
    (56) arexp -> . term arexpextra
    (57) arexp -> . term
    (61) term -> . factor termx
    (62) term -> . factor
    (66) factor -> . element
    (67) factor -> . ( store_op expr ) store_op
    (68) element -> . callfunc store_oper
    (69) element -> . compound store_oper
    (70) element -> . const store_const
    (78) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (71) compound -> . compoundx
    (73) const -> . STRING
    (74) const -> . FLOAT
    (75) const -> . INT
    (76) const -> . FALSE
    (77) const -> . TRUE
    (72) compoundx -> . ID store_oper
    (               shift and go to state 52
    ID              shift and go to state 102
    STRING          shift and go to state 76
    FLOAT           shift and go to state 77
    INT             shift and go to state 78
    FALSE           shift and go to state 79
    TRUE            shift and go to state 80

    expr                           shift and go to state 127
    arexp                          shift and go to state 68
    term                           shift and go to state 69
    factor                         shift and go to state 70
    element                        shift and go to state 71
    callfunc                       shift and go to state 72
    compound                       shift and go to state 73
    const                          shift and go to state 74
    compoundx                      shift and go to state 75

state 85

    (24) main -> FUNC MAIN ( ) store_funcm { vars store_mainv maincontent } .
    $end            reduce using rule 24 (main -> FUNC MAIN ( ) store_funcm { vars store_mainv maincontent } .)


state 86

    (35) statement -> statement statement .
    (26) maincontent -> statement . maincontent
    (35) statement -> statement . statement
    (25) maincontent -> .
    (26) maincontent -> . statement maincontent
    (27) statement -> . loop unload_pv
    (28) statement -> . input unload_pv
    (29) statement -> . output unload_pv
    (30) statement -> . ifelse unload_pv
    (31) statement -> . returns unload_pv ;
    (32) statement -> . expr ;
    (33) statement -> . var_assign unload_pv
    (34) statement -> .
    (35) statement -> . statement statement
    (44) loop -> . WHILE store_jump ( expr ) store_gotof { statement } end_loop
    (43) input -> . INPUT ( ID store_oper ) ;
    (40) output -> . OUTPUT ( expr outex ) ;
    (38) ifelse -> . IF ( expr ) store_gotof { statement } ELSE store_endif { statement }
    (39) ifelse -> . IF ( expr ) store_gotof { statement } store_endif
    (37) returns -> . RETURN expr store_rquad
    (45) expr -> . arexp exprx
    (36) var_assign -> . ID store_oper = expr ;
    (56) arexp -> . term arexpextra
    (57) arexp -> . term
    (61) term -> . factor termx
    (62) term -> . factor
    (66) factor -> . element
    (67) factor -> . ( store_op expr ) store_op
    (68) element -> . callfunc store_oper
    (69) element -> . compound store_oper
    (70) element -> . const store_const
    (78) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (71) compound -> . compoundx
    (73) const -> . STRING
    (74) const -> . FLOAT
    (75) const -> . INT
    (76) const -> . FALSE
    (77) const -> . TRUE
    (72) compoundx -> . ID store_oper
  ! reduce/reduce conflict for } resolved using rule 25 (maincontent -> .)
  ! reduce/reduce conflict for WHILE resolved using rule 35 (statement -> statement statement .)
  ! reduce/reduce conflict for INPUT resolved using rule 35 (statement -> statement statement .)
  ! reduce/reduce conflict for OUTPUT resolved using rule 35 (statement -> statement statement .)
  ! reduce/reduce conflict for IF resolved using rule 35 (statement -> statement statement .)
  ! reduce/reduce conflict for RETURN resolved using rule 35 (statement -> statement statement .)
  ! reduce/reduce conflict for ID resolved using rule 35 (statement -> statement statement .)
  ! reduce/reduce conflict for ( resolved using rule 35 (statement -> statement statement .)
  ! reduce/reduce conflict for STRING resolved using rule 35 (statement -> statement statement .)
  ! reduce/reduce conflict for FLOAT resolved using rule 35 (statement -> statement statement .)
  ! reduce/reduce conflict for INT resolved using rule 35 (statement -> statement statement .)
  ! reduce/reduce conflict for FALSE resolved using rule 35 (statement -> statement statement .)
  ! reduce/reduce conflict for TRUE resolved using rule 35 (statement -> statement statement .)
  ! reduce/reduce conflict for } resolved using rule 25 (maincontent -> .)
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for OUTPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    }               reduce using rule 25 (maincontent -> .)
    WHILE           shift and go to state 62
    INPUT           shift and go to state 63
    OUTPUT          shift and go to state 65
    IF              shift and go to state 66
    RETURN          shift and go to state 67
    ID              shift and go to state 64
    (               shift and go to state 52
    STRING          shift and go to state 76
    FLOAT           shift and go to state 77
    INT             shift and go to state 78
    FALSE           shift and go to state 79
    TRUE            shift and go to state 80

    statement                      shift and go to state 86
    maincontent                    shift and go to state 87
    loop                           shift and go to state 55
    input                          shift and go to state 56
    output                         shift and go to state 57
    ifelse                         shift and go to state 58
    returns                        shift and go to state 59
    expr                           shift and go to state 60
    var_assign                     shift and go to state 61
    arexp                          shift and go to state 68
    term                           shift and go to state 69
    factor                         shift and go to state 70
    element                        shift and go to state 71
    callfunc                       shift and go to state 72
    compound                       shift and go to state 73
    const                          shift and go to state 74
    compoundx                      shift and go to state 75

state 87

    (26) maincontent -> statement maincontent .
    }               reduce using rule 26 (maincontent -> statement maincontent .)


state 88

    (27) statement -> loop unload_pv .
    WHILE           reduce using rule 27 (statement -> loop unload_pv .)
    INPUT           reduce using rule 27 (statement -> loop unload_pv .)
    OUTPUT          reduce using rule 27 (statement -> loop unload_pv .)
    IF              reduce using rule 27 (statement -> loop unload_pv .)
    RETURN          reduce using rule 27 (statement -> loop unload_pv .)
    ID              reduce using rule 27 (statement -> loop unload_pv .)
    (               reduce using rule 27 (statement -> loop unload_pv .)
    STRING          reduce using rule 27 (statement -> loop unload_pv .)
    FLOAT           reduce using rule 27 (statement -> loop unload_pv .)
    INT             reduce using rule 27 (statement -> loop unload_pv .)
    FALSE           reduce using rule 27 (statement -> loop unload_pv .)
    TRUE            reduce using rule 27 (statement -> loop unload_pv .)
    }               reduce using rule 27 (statement -> loop unload_pv .)


state 89

    (28) statement -> input unload_pv .
    WHILE           reduce using rule 28 (statement -> input unload_pv .)
    INPUT           reduce using rule 28 (statement -> input unload_pv .)
    OUTPUT          reduce using rule 28 (statement -> input unload_pv .)
    IF              reduce using rule 28 (statement -> input unload_pv .)
    RETURN          reduce using rule 28 (statement -> input unload_pv .)
    ID              reduce using rule 28 (statement -> input unload_pv .)
    (               reduce using rule 28 (statement -> input unload_pv .)
    STRING          reduce using rule 28 (statement -> input unload_pv .)
    FLOAT           reduce using rule 28 (statement -> input unload_pv .)
    INT             reduce using rule 28 (statement -> input unload_pv .)
    FALSE           reduce using rule 28 (statement -> input unload_pv .)
    TRUE            reduce using rule 28 (statement -> input unload_pv .)
    }               reduce using rule 28 (statement -> input unload_pv .)


state 90

    (29) statement -> output unload_pv .
    WHILE           reduce using rule 29 (statement -> output unload_pv .)
    INPUT           reduce using rule 29 (statement -> output unload_pv .)
    OUTPUT          reduce using rule 29 (statement -> output unload_pv .)
    IF              reduce using rule 29 (statement -> output unload_pv .)
    RETURN          reduce using rule 29 (statement -> output unload_pv .)
    ID              reduce using rule 29 (statement -> output unload_pv .)
    (               reduce using rule 29 (statement -> output unload_pv .)
    STRING          reduce using rule 29 (statement -> output unload_pv .)
    FLOAT           reduce using rule 29 (statement -> output unload_pv .)
    INT             reduce using rule 29 (statement -> output unload_pv .)
    FALSE           reduce using rule 29 (statement -> output unload_pv .)
    TRUE            reduce using rule 29 (statement -> output unload_pv .)
    }               reduce using rule 29 (statement -> output unload_pv .)


state 91

    (30) statement -> ifelse unload_pv .
    WHILE           reduce using rule 30 (statement -> ifelse unload_pv .)
    INPUT           reduce using rule 30 (statement -> ifelse unload_pv .)
    OUTPUT          reduce using rule 30 (statement -> ifelse unload_pv .)
    IF              reduce using rule 30 (statement -> ifelse unload_pv .)
    RETURN          reduce using rule 30 (statement -> ifelse unload_pv .)
    ID              reduce using rule 30 (statement -> ifelse unload_pv .)
    (               reduce using rule 30 (statement -> ifelse unload_pv .)
    STRING          reduce using rule 30 (statement -> ifelse unload_pv .)
    FLOAT           reduce using rule 30 (statement -> ifelse unload_pv .)
    INT             reduce using rule 30 (statement -> ifelse unload_pv .)
    FALSE           reduce using rule 30 (statement -> ifelse unload_pv .)
    TRUE            reduce using rule 30 (statement -> ifelse unload_pv .)
    }               reduce using rule 30 (statement -> ifelse unload_pv .)


state 92

    (31) statement -> returns unload_pv . ;
    ;               shift and go to state 128


state 93

    (32) statement -> expr ; .
    WHILE           reduce using rule 32 (statement -> expr ; .)
    INPUT           reduce using rule 32 (statement -> expr ; .)
    OUTPUT          reduce using rule 32 (statement -> expr ; .)
    IF              reduce using rule 32 (statement -> expr ; .)
    RETURN          reduce using rule 32 (statement -> expr ; .)
    ID              reduce using rule 32 (statement -> expr ; .)
    (               reduce using rule 32 (statement -> expr ; .)
    STRING          reduce using rule 32 (statement -> expr ; .)
    FLOAT           reduce using rule 32 (statement -> expr ; .)
    INT             reduce using rule 32 (statement -> expr ; .)
    FALSE           reduce using rule 32 (statement -> expr ; .)
    TRUE            reduce using rule 32 (statement -> expr ; .)
    }               reduce using rule 32 (statement -> expr ; .)


state 94

    (33) statement -> var_assign unload_pv .
    WHILE           reduce using rule 33 (statement -> var_assign unload_pv .)
    INPUT           reduce using rule 33 (statement -> var_assign unload_pv .)
    OUTPUT          reduce using rule 33 (statement -> var_assign unload_pv .)
    IF              reduce using rule 33 (statement -> var_assign unload_pv .)
    RETURN          reduce using rule 33 (statement -> var_assign unload_pv .)
    ID              reduce using rule 33 (statement -> var_assign unload_pv .)
    (               reduce using rule 33 (statement -> var_assign unload_pv .)
    STRING          reduce using rule 33 (statement -> var_assign unload_pv .)
    FLOAT           reduce using rule 33 (statement -> var_assign unload_pv .)
    INT             reduce using rule 33 (statement -> var_assign unload_pv .)
    FALSE           reduce using rule 33 (statement -> var_assign unload_pv .)
    TRUE            reduce using rule 33 (statement -> var_assign unload_pv .)
    }               reduce using rule 33 (statement -> var_assign unload_pv .)


state 95

    (44) loop -> WHILE store_jump . ( expr ) store_gotof { statement } end_loop
    (               shift and go to state 129


state 96

    (43) input -> INPUT ( . ID store_oper ) ;
    ID              shift and go to state 130


state 97

    (36) var_assign -> ID store_oper . = expr ;
    (72) compoundx -> ID store_oper .
    =               shift and go to state 131
    /               reduce using rule 72 (compoundx -> ID store_oper .)
    *               reduce using rule 72 (compoundx -> ID store_oper .)
    -               reduce using rule 72 (compoundx -> ID store_oper .)
    +               reduce using rule 72 (compoundx -> ID store_oper .)
    OR              reduce using rule 72 (compoundx -> ID store_oper .)
    EQEQ            reduce using rule 72 (compoundx -> ID store_oper .)
    DIFF            reduce using rule 72 (compoundx -> ID store_oper .)
    AND             reduce using rule 72 (compoundx -> ID store_oper .)
    <               reduce using rule 72 (compoundx -> ID store_oper .)
    LOETHAN         reduce using rule 72 (compoundx -> ID store_oper .)
    >               reduce using rule 72 (compoundx -> ID store_oper .)
    GOETHAN         reduce using rule 72 (compoundx -> ID store_oper .)
    ;               reduce using rule 72 (compoundx -> ID store_oper .)


state 98

    (78) callfunc -> ID verify_func . add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (105) add_fstack -> .
    (               reduce using rule 105 (add_fstack -> .)

    add_fstack                     shift and go to state 132

state 99

    (40) output -> OUTPUT ( . expr outex ) ;
    (45) expr -> . arexp exprx
    (56) arexp -> . term arexpextra
    (57) arexp -> . term
    (61) term -> . factor termx
    (62) term -> . factor
    (66) factor -> . element
    (67) factor -> . ( store_op expr ) store_op
    (68) element -> . callfunc store_oper
    (69) element -> . compound store_oper
    (70) element -> . const store_const
    (78) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (71) compound -> . compoundx
    (73) const -> . STRING
    (74) const -> . FLOAT
    (75) const -> . INT
    (76) const -> . FALSE
    (77) const -> . TRUE
    (72) compoundx -> . ID store_oper
    (               shift and go to state 52
    ID              shift and go to state 102
    STRING          shift and go to state 76
    FLOAT           shift and go to state 77
    INT             shift and go to state 78
    FALSE           shift and go to state 79
    TRUE            shift and go to state 80

    expr                           shift and go to state 133
    arexp                          shift and go to state 68
    term                           shift and go to state 69
    factor                         shift and go to state 70
    element                        shift and go to state 71
    callfunc                       shift and go to state 72
    compound                       shift and go to state 73
    const                          shift and go to state 74
    compoundx                      shift and go to state 75

state 100

    (38) ifelse -> IF ( . expr ) store_gotof { statement } ELSE store_endif { statement }
    (39) ifelse -> IF ( . expr ) store_gotof { statement } store_endif
    (45) expr -> . arexp exprx
    (56) arexp -> . term arexpextra
    (57) arexp -> . term
    (61) term -> . factor termx
    (62) term -> . factor
    (66) factor -> . element
    (67) factor -> . ( store_op expr ) store_op
    (68) element -> . callfunc store_oper
    (69) element -> . compound store_oper
    (70) element -> . const store_const
    (78) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (71) compound -> . compoundx
    (73) const -> . STRING
    (74) const -> . FLOAT
    (75) const -> . INT
    (76) const -> . FALSE
    (77) const -> . TRUE
    (72) compoundx -> . ID store_oper
    (               shift and go to state 52
    ID              shift and go to state 102
    STRING          shift and go to state 76
    FLOAT           shift and go to state 77
    INT             shift and go to state 78
    FALSE           shift and go to state 79
    TRUE            shift and go to state 80

    expr                           shift and go to state 134
    arexp                          shift and go to state 68
    term                           shift and go to state 69
    factor                         shift and go to state 70
    element                        shift and go to state 71
    callfunc                       shift and go to state 72
    compound                       shift and go to state 73
    const                          shift and go to state 74
    compoundx                      shift and go to state 75

state 101

    (37) returns -> RETURN expr . store_rquad
    (99) store_rquad -> .
    ;               reduce using rule 99 (store_rquad -> .)

    store_rquad                    shift and go to state 135

state 102

    (78) callfunc -> ID . verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (72) compoundx -> ID . store_oper
    (104) verify_func -> .
    (96) store_oper -> .
    (               reduce using rule 104 (verify_func -> .)
    /               reduce using rule 96 (store_oper -> .)
    *               reduce using rule 96 (store_oper -> .)
    -               reduce using rule 96 (store_oper -> .)
    +               reduce using rule 96 (store_oper -> .)
    OR              reduce using rule 96 (store_oper -> .)
    EQEQ            reduce using rule 96 (store_oper -> .)
    DIFF            reduce using rule 96 (store_oper -> .)
    AND             reduce using rule 96 (store_oper -> .)
    <               reduce using rule 96 (store_oper -> .)
    LOETHAN         reduce using rule 96 (store_oper -> .)
    >               reduce using rule 96 (store_oper -> .)
    GOETHAN         reduce using rule 96 (store_oper -> .)
    ;               reduce using rule 96 (store_oper -> .)
    )               reduce using rule 96 (store_oper -> .)
    ,               reduce using rule 96 (store_oper -> .)

    verify_func                    shift and go to state 98
    store_oper                     shift and go to state 136

state 103

    (45) expr -> arexp exprx .
    ;               reduce using rule 45 (expr -> arexp exprx .)
    )               reduce using rule 45 (expr -> arexp exprx .)
    ,               reduce using rule 45 (expr -> arexp exprx .)


state 104

    (47) exprx -> exprop . arexp
    (56) arexp -> . term arexpextra
    (57) arexp -> . term
    (61) term -> . factor termx
    (62) term -> . factor
    (66) factor -> . element
    (67) factor -> . ( store_op expr ) store_op
    (68) element -> . callfunc store_oper
    (69) element -> . compound store_oper
    (70) element -> . const store_const
    (78) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (71) compound -> . compoundx
    (73) const -> . STRING
    (74) const -> . FLOAT
    (75) const -> . INT
    (76) const -> . FALSE
    (77) const -> . TRUE
    (72) compoundx -> . ID store_oper
    (               shift and go to state 52
    ID              shift and go to state 102
    STRING          shift and go to state 76
    FLOAT           shift and go to state 77
    INT             shift and go to state 78
    FALSE           shift and go to state 79
    TRUE            shift and go to state 80

    arexp                          shift and go to state 137
    term                           shift and go to state 69
    factor                         shift and go to state 70
    element                        shift and go to state 71
    callfunc                       shift and go to state 72
    compound                       shift and go to state 73
    const                          shift and go to state 74
    compoundx                      shift and go to state 75

state 105

    (48) exprop -> OR .
    (               reduce using rule 48 (exprop -> OR .)
    ID              reduce using rule 48 (exprop -> OR .)
    STRING          reduce using rule 48 (exprop -> OR .)
    FLOAT           reduce using rule 48 (exprop -> OR .)
    INT             reduce using rule 48 (exprop -> OR .)
    FALSE           reduce using rule 48 (exprop -> OR .)
    TRUE            reduce using rule 48 (exprop -> OR .)


state 106

    (49) exprop -> EQEQ .
    (               reduce using rule 49 (exprop -> EQEQ .)
    ID              reduce using rule 49 (exprop -> EQEQ .)
    STRING          reduce using rule 49 (exprop -> EQEQ .)
    FLOAT           reduce using rule 49 (exprop -> EQEQ .)
    INT             reduce using rule 49 (exprop -> EQEQ .)
    FALSE           reduce using rule 49 (exprop -> EQEQ .)
    TRUE            reduce using rule 49 (exprop -> EQEQ .)


state 107

    (50) exprop -> DIFF .
    (               reduce using rule 50 (exprop -> DIFF .)
    ID              reduce using rule 50 (exprop -> DIFF .)
    STRING          reduce using rule 50 (exprop -> DIFF .)
    FLOAT           reduce using rule 50 (exprop -> DIFF .)
    INT             reduce using rule 50 (exprop -> DIFF .)
    FALSE           reduce using rule 50 (exprop -> DIFF .)
    TRUE            reduce using rule 50 (exprop -> DIFF .)


state 108

    (51) exprop -> AND .
    (               reduce using rule 51 (exprop -> AND .)
    ID              reduce using rule 51 (exprop -> AND .)
    STRING          reduce using rule 51 (exprop -> AND .)
    FLOAT           reduce using rule 51 (exprop -> AND .)
    INT             reduce using rule 51 (exprop -> AND .)
    FALSE           reduce using rule 51 (exprop -> AND .)
    TRUE            reduce using rule 51 (exprop -> AND .)


state 109

    (52) exprop -> < .
    (               reduce using rule 52 (exprop -> < .)
    ID              reduce using rule 52 (exprop -> < .)
    STRING          reduce using rule 52 (exprop -> < .)
    FLOAT           reduce using rule 52 (exprop -> < .)
    INT             reduce using rule 52 (exprop -> < .)
    FALSE           reduce using rule 52 (exprop -> < .)
    TRUE            reduce using rule 52 (exprop -> < .)


state 110

    (53) exprop -> LOETHAN .
    (               reduce using rule 53 (exprop -> LOETHAN .)
    ID              reduce using rule 53 (exprop -> LOETHAN .)
    STRING          reduce using rule 53 (exprop -> LOETHAN .)
    FLOAT           reduce using rule 53 (exprop -> LOETHAN .)
    INT             reduce using rule 53 (exprop -> LOETHAN .)
    FALSE           reduce using rule 53 (exprop -> LOETHAN .)
    TRUE            reduce using rule 53 (exprop -> LOETHAN .)


state 111

    (54) exprop -> > .
    (               reduce using rule 54 (exprop -> > .)
    ID              reduce using rule 54 (exprop -> > .)
    STRING          reduce using rule 54 (exprop -> > .)
    FLOAT           reduce using rule 54 (exprop -> > .)
    INT             reduce using rule 54 (exprop -> > .)
    FALSE           reduce using rule 54 (exprop -> > .)
    TRUE            reduce using rule 54 (exprop -> > .)


state 112

    (55) exprop -> GOETHAN .
    (               reduce using rule 55 (exprop -> GOETHAN .)
    ID              reduce using rule 55 (exprop -> GOETHAN .)
    STRING          reduce using rule 55 (exprop -> GOETHAN .)
    FLOAT           reduce using rule 55 (exprop -> GOETHAN .)
    INT             reduce using rule 55 (exprop -> GOETHAN .)
    FALSE           reduce using rule 55 (exprop -> GOETHAN .)
    TRUE            reduce using rule 55 (exprop -> GOETHAN .)


state 113

    (56) arexp -> term arexpextra .
    OR              reduce using rule 56 (arexp -> term arexpextra .)
    EQEQ            reduce using rule 56 (arexp -> term arexpextra .)
    DIFF            reduce using rule 56 (arexp -> term arexpextra .)
    AND             reduce using rule 56 (arexp -> term arexpextra .)
    <               reduce using rule 56 (arexp -> term arexpextra .)
    LOETHAN         reduce using rule 56 (arexp -> term arexpextra .)
    >               reduce using rule 56 (arexp -> term arexpextra .)
    GOETHAN         reduce using rule 56 (arexp -> term arexpextra .)
    ;               reduce using rule 56 (arexp -> term arexpextra .)
    )               reduce using rule 56 (arexp -> term arexpextra .)
    ,               reduce using rule 56 (arexp -> term arexpextra .)


state 114

    (59) arexpextra -> - . term arexpextra
    (61) term -> . factor termx
    (62) term -> . factor
    (66) factor -> . element
    (67) factor -> . ( store_op expr ) store_op
    (68) element -> . callfunc store_oper
    (69) element -> . compound store_oper
    (70) element -> . const store_const
    (78) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (71) compound -> . compoundx
    (73) const -> . STRING
    (74) const -> . FLOAT
    (75) const -> . INT
    (76) const -> . FALSE
    (77) const -> . TRUE
    (72) compoundx -> . ID store_oper
    (               shift and go to state 52
    ID              shift and go to state 102
    STRING          shift and go to state 76
    FLOAT           shift and go to state 77
    INT             shift and go to state 78
    FALSE           shift and go to state 79
    TRUE            shift and go to state 80

    term                           shift and go to state 138
    factor                         shift and go to state 70
    element                        shift and go to state 71
    callfunc                       shift and go to state 72
    compound                       shift and go to state 73
    const                          shift and go to state 74
    compoundx                      shift and go to state 75

state 115

    (60) arexpextra -> + . term arexpextra
    (61) term -> . factor termx
    (62) term -> . factor
    (66) factor -> . element
    (67) factor -> . ( store_op expr ) store_op
    (68) element -> . callfunc store_oper
    (69) element -> . compound store_oper
    (70) element -> . const store_const
    (78) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (71) compound -> . compoundx
    (73) const -> . STRING
    (74) const -> . FLOAT
    (75) const -> . INT
    (76) const -> . FALSE
    (77) const -> . TRUE
    (72) compoundx -> . ID store_oper
    (               shift and go to state 52
    ID              shift and go to state 102
    STRING          shift and go to state 76
    FLOAT           shift and go to state 77
    INT             shift and go to state 78
    FALSE           shift and go to state 79
    TRUE            shift and go to state 80

    term                           shift and go to state 139
    factor                         shift and go to state 70
    element                        shift and go to state 71
    callfunc                       shift and go to state 72
    compound                       shift and go to state 73
    const                          shift and go to state 74
    compoundx                      shift and go to state 75

state 116

    (61) term -> factor termx .
    -               reduce using rule 61 (term -> factor termx .)
    +               reduce using rule 61 (term -> factor termx .)
    OR              reduce using rule 61 (term -> factor termx .)
    EQEQ            reduce using rule 61 (term -> factor termx .)
    DIFF            reduce using rule 61 (term -> factor termx .)
    AND             reduce using rule 61 (term -> factor termx .)
    <               reduce using rule 61 (term -> factor termx .)
    LOETHAN         reduce using rule 61 (term -> factor termx .)
    >               reduce using rule 61 (term -> factor termx .)
    GOETHAN         reduce using rule 61 (term -> factor termx .)
    ;               reduce using rule 61 (term -> factor termx .)
    )               reduce using rule 61 (term -> factor termx .)
    ,               reduce using rule 61 (term -> factor termx .)


state 117

    (64) termx -> / . factor termx
    (66) factor -> . element
    (67) factor -> . ( store_op expr ) store_op
    (68) element -> . callfunc store_oper
    (69) element -> . compound store_oper
    (70) element -> . const store_const
    (78) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (71) compound -> . compoundx
    (73) const -> . STRING
    (74) const -> . FLOAT
    (75) const -> . INT
    (76) const -> . FALSE
    (77) const -> . TRUE
    (72) compoundx -> . ID store_oper
    (               shift and go to state 52
    ID              shift and go to state 102
    STRING          shift and go to state 76
    FLOAT           shift and go to state 77
    INT             shift and go to state 78
    FALSE           shift and go to state 79
    TRUE            shift and go to state 80

    factor                         shift and go to state 140
    element                        shift and go to state 71
    callfunc                       shift and go to state 72
    compound                       shift and go to state 73
    const                          shift and go to state 74
    compoundx                      shift and go to state 75

state 118

    (65) termx -> * . factor termx
    (66) factor -> . element
    (67) factor -> . ( store_op expr ) store_op
    (68) element -> . callfunc store_oper
    (69) element -> . compound store_oper
    (70) element -> . const store_const
    (78) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (71) compound -> . compoundx
    (73) const -> . STRING
    (74) const -> . FLOAT
    (75) const -> . INT
    (76) const -> . FALSE
    (77) const -> . TRUE
    (72) compoundx -> . ID store_oper
    (               shift and go to state 52
    ID              shift and go to state 102
    STRING          shift and go to state 76
    FLOAT           shift and go to state 77
    INT             shift and go to state 78
    FALSE           shift and go to state 79
    TRUE            shift and go to state 80

    factor                         shift and go to state 141
    element                        shift and go to state 71
    callfunc                       shift and go to state 72
    compound                       shift and go to state 73
    const                          shift and go to state 74
    compoundx                      shift and go to state 75

state 119

    (68) element -> callfunc store_oper .
    /               reduce using rule 68 (element -> callfunc store_oper .)
    *               reduce using rule 68 (element -> callfunc store_oper .)
    -               reduce using rule 68 (element -> callfunc store_oper .)
    +               reduce using rule 68 (element -> callfunc store_oper .)
    OR              reduce using rule 68 (element -> callfunc store_oper .)
    EQEQ            reduce using rule 68 (element -> callfunc store_oper .)
    DIFF            reduce using rule 68 (element -> callfunc store_oper .)
    AND             reduce using rule 68 (element -> callfunc store_oper .)
    <               reduce using rule 68 (element -> callfunc store_oper .)
    LOETHAN         reduce using rule 68 (element -> callfunc store_oper .)
    >               reduce using rule 68 (element -> callfunc store_oper .)
    GOETHAN         reduce using rule 68 (element -> callfunc store_oper .)
    ;               reduce using rule 68 (element -> callfunc store_oper .)
    )               reduce using rule 68 (element -> callfunc store_oper .)
    ,               reduce using rule 68 (element -> callfunc store_oper .)


state 120

    (69) element -> compound store_oper .
    /               reduce using rule 69 (element -> compound store_oper .)
    *               reduce using rule 69 (element -> compound store_oper .)
    -               reduce using rule 69 (element -> compound store_oper .)
    +               reduce using rule 69 (element -> compound store_oper .)
    OR              reduce using rule 69 (element -> compound store_oper .)
    EQEQ            reduce using rule 69 (element -> compound store_oper .)
    DIFF            reduce using rule 69 (element -> compound store_oper .)
    AND             reduce using rule 69 (element -> compound store_oper .)
    <               reduce using rule 69 (element -> compound store_oper .)
    LOETHAN         reduce using rule 69 (element -> compound store_oper .)
    >               reduce using rule 69 (element -> compound store_oper .)
    GOETHAN         reduce using rule 69 (element -> compound store_oper .)
    ;               reduce using rule 69 (element -> compound store_oper .)
    )               reduce using rule 69 (element -> compound store_oper .)
    ,               reduce using rule 69 (element -> compound store_oper .)


state 121

    (70) element -> const store_const .
    /               reduce using rule 70 (element -> const store_const .)
    *               reduce using rule 70 (element -> const store_const .)
    -               reduce using rule 70 (element -> const store_const .)
    +               reduce using rule 70 (element -> const store_const .)
    OR              reduce using rule 70 (element -> const store_const .)
    EQEQ            reduce using rule 70 (element -> const store_const .)
    DIFF            reduce using rule 70 (element -> const store_const .)
    AND             reduce using rule 70 (element -> const store_const .)
    <               reduce using rule 70 (element -> const store_const .)
    LOETHAN         reduce using rule 70 (element -> const store_const .)
    >               reduce using rule 70 (element -> const store_const .)
    GOETHAN         reduce using rule 70 (element -> const store_const .)
    ;               reduce using rule 70 (element -> const store_const .)
    )               reduce using rule 70 (element -> const store_const .)
    ,               reduce using rule 70 (element -> const store_const .)


state 122

    (8) vars -> VAR datatype varids store_type . ; vars
    ;               shift and go to state 142


state 123

    (10) varids -> ID darray .
    (11) varids -> ID darray . , varids
    ;               reduce using rule 10 (varids -> ID darray .)
    ,               shift and go to state 143


state 124

    (14) darray -> [ . INT ] twodarray
    INT             shift and go to state 144


state 125

    (17) functions -> datatype FUNC ID ( params ) store_funcv store_params store_init_quad { vars store_local_vars funcontent . } close_func functions
    }               shift and go to state 145


state 126

    (20) funcontent -> statement . funcontent
    (35) statement -> statement . statement
    (19) funcontent -> .
    (20) funcontent -> . statement funcontent
    (27) statement -> . loop unload_pv
    (28) statement -> . input unload_pv
    (29) statement -> . output unload_pv
    (30) statement -> . ifelse unload_pv
    (31) statement -> . returns unload_pv ;
    (32) statement -> . expr ;
    (33) statement -> . var_assign unload_pv
    (34) statement -> .
    (35) statement -> . statement statement
    (44) loop -> . WHILE store_jump ( expr ) store_gotof { statement } end_loop
    (43) input -> . INPUT ( ID store_oper ) ;
    (40) output -> . OUTPUT ( expr outex ) ;
    (38) ifelse -> . IF ( expr ) store_gotof { statement } ELSE store_endif { statement }
    (39) ifelse -> . IF ( expr ) store_gotof { statement } store_endif
    (37) returns -> . RETURN expr store_rquad
    (45) expr -> . arexp exprx
    (36) var_assign -> . ID store_oper = expr ;
    (56) arexp -> . term arexpextra
    (57) arexp -> . term
    (61) term -> . factor termx
    (62) term -> . factor
    (66) factor -> . element
    (67) factor -> . ( store_op expr ) store_op
    (68) element -> . callfunc store_oper
    (69) element -> . compound store_oper
    (70) element -> . const store_const
    (78) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (71) compound -> . compoundx
    (73) const -> . STRING
    (74) const -> . FLOAT
    (75) const -> . INT
    (76) const -> . FALSE
    (77) const -> . TRUE
    (72) compoundx -> . ID store_oper
  ! reduce/reduce conflict for } resolved using rule 19 (funcontent -> .)
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for OUTPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    }               reduce using rule 19 (funcontent -> .)
    WHILE           shift and go to state 62
    INPUT           shift and go to state 63
    OUTPUT          shift and go to state 65
    IF              shift and go to state 66
    RETURN          shift and go to state 67
    ID              shift and go to state 64
    (               shift and go to state 52
    STRING          shift and go to state 76
    FLOAT           shift and go to state 77
    INT             shift and go to state 78
    FALSE           shift and go to state 79
    TRUE            shift and go to state 80

    statement                      shift and go to state 146
    funcontent                     shift and go to state 147
    loop                           shift and go to state 55
    input                          shift and go to state 56
    output                         shift and go to state 57
    ifelse                         shift and go to state 58
    returns                        shift and go to state 59
    expr                           shift and go to state 60
    var_assign                     shift and go to state 61
    arexp                          shift and go to state 68
    term                           shift and go to state 69
    factor                         shift and go to state 70
    element                        shift and go to state 71
    callfunc                       shift and go to state 72
    compound                       shift and go to state 73
    const                          shift and go to state 74
    compoundx                      shift and go to state 75

state 127

    (67) factor -> ( store_op expr . ) store_op
    )               shift and go to state 148


state 128

    (31) statement -> returns unload_pv ; .
    WHILE           reduce using rule 31 (statement -> returns unload_pv ; .)
    INPUT           reduce using rule 31 (statement -> returns unload_pv ; .)
    OUTPUT          reduce using rule 31 (statement -> returns unload_pv ; .)
    IF              reduce using rule 31 (statement -> returns unload_pv ; .)
    RETURN          reduce using rule 31 (statement -> returns unload_pv ; .)
    ID              reduce using rule 31 (statement -> returns unload_pv ; .)
    (               reduce using rule 31 (statement -> returns unload_pv ; .)
    STRING          reduce using rule 31 (statement -> returns unload_pv ; .)
    FLOAT           reduce using rule 31 (statement -> returns unload_pv ; .)
    INT             reduce using rule 31 (statement -> returns unload_pv ; .)
    FALSE           reduce using rule 31 (statement -> returns unload_pv ; .)
    TRUE            reduce using rule 31 (statement -> returns unload_pv ; .)
    }               reduce using rule 31 (statement -> returns unload_pv ; .)


state 129

    (44) loop -> WHILE store_jump ( . expr ) store_gotof { statement } end_loop
    (45) expr -> . arexp exprx
    (56) arexp -> . term arexpextra
    (57) arexp -> . term
    (61) term -> . factor termx
    (62) term -> . factor
    (66) factor -> . element
    (67) factor -> . ( store_op expr ) store_op
    (68) element -> . callfunc store_oper
    (69) element -> . compound store_oper
    (70) element -> . const store_const
    (78) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (71) compound -> . compoundx
    (73) const -> . STRING
    (74) const -> . FLOAT
    (75) const -> . INT
    (76) const -> . FALSE
    (77) const -> . TRUE
    (72) compoundx -> . ID store_oper
    (               shift and go to state 52
    ID              shift and go to state 102
    STRING          shift and go to state 76
    FLOAT           shift and go to state 77
    INT             shift and go to state 78
    FALSE           shift and go to state 79
    TRUE            shift and go to state 80

    expr                           shift and go to state 149
    arexp                          shift and go to state 68
    term                           shift and go to state 69
    factor                         shift and go to state 70
    element                        shift and go to state 71
    callfunc                       shift and go to state 72
    compound                       shift and go to state 73
    const                          shift and go to state 74
    compoundx                      shift and go to state 75

state 130

    (43) input -> INPUT ( ID . store_oper ) ;
    (96) store_oper -> .
    )               reduce using rule 96 (store_oper -> .)

    store_oper                     shift and go to state 150

state 131

    (36) var_assign -> ID store_oper = . expr ;
    (45) expr -> . arexp exprx
    (56) arexp -> . term arexpextra
    (57) arexp -> . term
    (61) term -> . factor termx
    (62) term -> . factor
    (66) factor -> . element
    (67) factor -> . ( store_op expr ) store_op
    (68) element -> . callfunc store_oper
    (69) element -> . compound store_oper
    (70) element -> . const store_const
    (78) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (71) compound -> . compoundx
    (73) const -> . STRING
    (74) const -> . FLOAT
    (75) const -> . INT
    (76) const -> . FALSE
    (77) const -> . TRUE
    (72) compoundx -> . ID store_oper
    (               shift and go to state 52
    ID              shift and go to state 102
    STRING          shift and go to state 76
    FLOAT           shift and go to state 77
    INT             shift and go to state 78
    FALSE           shift and go to state 79
    TRUE            shift and go to state 80

    expr                           shift and go to state 151
    arexp                          shift and go to state 68
    term                           shift and go to state 69
    factor                         shift and go to state 70
    element                        shift and go to state 71
    callfunc                       shift and go to state 72
    compound                       shift and go to state 73
    const                          shift and go to state 74
    compoundx                      shift and go to state 75

state 132

    (78) callfunc -> ID verify_func add_fstack . ( callfuncpar ver_params ) end_fstack store_gosub
    (               shift and go to state 152


state 133

    (40) output -> OUTPUT ( expr . outex ) ;
    (41) outex -> .
    (42) outex -> . , expr outex
    )               reduce using rule 41 (outex -> .)
    ,               shift and go to state 154

    outex                          shift and go to state 153

state 134

    (38) ifelse -> IF ( expr . ) store_gotof { statement } ELSE store_endif { statement }
    (39) ifelse -> IF ( expr . ) store_gotof { statement } store_endif
    )               shift and go to state 155


state 135

    (37) returns -> RETURN expr store_rquad .
    ;               reduce using rule 37 (returns -> RETURN expr store_rquad .)


state 136

    (72) compoundx -> ID store_oper .
    /               reduce using rule 72 (compoundx -> ID store_oper .)
    *               reduce using rule 72 (compoundx -> ID store_oper .)
    -               reduce using rule 72 (compoundx -> ID store_oper .)
    +               reduce using rule 72 (compoundx -> ID store_oper .)
    OR              reduce using rule 72 (compoundx -> ID store_oper .)
    EQEQ            reduce using rule 72 (compoundx -> ID store_oper .)
    DIFF            reduce using rule 72 (compoundx -> ID store_oper .)
    AND             reduce using rule 72 (compoundx -> ID store_oper .)
    <               reduce using rule 72 (compoundx -> ID store_oper .)
    LOETHAN         reduce using rule 72 (compoundx -> ID store_oper .)
    >               reduce using rule 72 (compoundx -> ID store_oper .)
    GOETHAN         reduce using rule 72 (compoundx -> ID store_oper .)
    ;               reduce using rule 72 (compoundx -> ID store_oper .)
    )               reduce using rule 72 (compoundx -> ID store_oper .)
    ,               reduce using rule 72 (compoundx -> ID store_oper .)


state 137

    (47) exprx -> exprop arexp .
    ;               reduce using rule 47 (exprx -> exprop arexp .)
    )               reduce using rule 47 (exprx -> exprop arexp .)
    ,               reduce using rule 47 (exprx -> exprop arexp .)


state 138

    (59) arexpextra -> - term . arexpextra
    (58) arexpextra -> .
    (59) arexpextra -> . - term arexpextra
    (60) arexpextra -> . + term arexpextra
    OR              reduce using rule 58 (arexpextra -> .)
    EQEQ            reduce using rule 58 (arexpextra -> .)
    DIFF            reduce using rule 58 (arexpextra -> .)
    AND             reduce using rule 58 (arexpextra -> .)
    <               reduce using rule 58 (arexpextra -> .)
    LOETHAN         reduce using rule 58 (arexpextra -> .)
    >               reduce using rule 58 (arexpextra -> .)
    GOETHAN         reduce using rule 58 (arexpextra -> .)
    ;               reduce using rule 58 (arexpextra -> .)
    )               reduce using rule 58 (arexpextra -> .)
    ,               reduce using rule 58 (arexpextra -> .)
    -               shift and go to state 114
    +               shift and go to state 115

    arexpextra                     shift and go to state 156

state 139

    (60) arexpextra -> + term . arexpextra
    (58) arexpextra -> .
    (59) arexpextra -> . - term arexpextra
    (60) arexpextra -> . + term arexpextra
    OR              reduce using rule 58 (arexpextra -> .)
    EQEQ            reduce using rule 58 (arexpextra -> .)
    DIFF            reduce using rule 58 (arexpextra -> .)
    AND             reduce using rule 58 (arexpextra -> .)
    <               reduce using rule 58 (arexpextra -> .)
    LOETHAN         reduce using rule 58 (arexpextra -> .)
    >               reduce using rule 58 (arexpextra -> .)
    GOETHAN         reduce using rule 58 (arexpextra -> .)
    ;               reduce using rule 58 (arexpextra -> .)
    )               reduce using rule 58 (arexpextra -> .)
    ,               reduce using rule 58 (arexpextra -> .)
    -               shift and go to state 114
    +               shift and go to state 115

    arexpextra                     shift and go to state 157

state 140

    (64) termx -> / factor . termx
    (63) termx -> .
    (64) termx -> . / factor termx
    (65) termx -> . * factor termx
    -               reduce using rule 63 (termx -> .)
    +               reduce using rule 63 (termx -> .)
    OR              reduce using rule 63 (termx -> .)
    EQEQ            reduce using rule 63 (termx -> .)
    DIFF            reduce using rule 63 (termx -> .)
    AND             reduce using rule 63 (termx -> .)
    <               reduce using rule 63 (termx -> .)
    LOETHAN         reduce using rule 63 (termx -> .)
    >               reduce using rule 63 (termx -> .)
    GOETHAN         reduce using rule 63 (termx -> .)
    ;               reduce using rule 63 (termx -> .)
    )               reduce using rule 63 (termx -> .)
    ,               reduce using rule 63 (termx -> .)
    /               shift and go to state 117
    *               shift and go to state 118

    termx                          shift and go to state 158

state 141

    (65) termx -> * factor . termx
    (63) termx -> .
    (64) termx -> . / factor termx
    (65) termx -> . * factor termx
    -               reduce using rule 63 (termx -> .)
    +               reduce using rule 63 (termx -> .)
    OR              reduce using rule 63 (termx -> .)
    EQEQ            reduce using rule 63 (termx -> .)
    DIFF            reduce using rule 63 (termx -> .)
    AND             reduce using rule 63 (termx -> .)
    <               reduce using rule 63 (termx -> .)
    LOETHAN         reduce using rule 63 (termx -> .)
    >               reduce using rule 63 (termx -> .)
    GOETHAN         reduce using rule 63 (termx -> .)
    ;               reduce using rule 63 (termx -> .)
    )               reduce using rule 63 (termx -> .)
    ,               reduce using rule 63 (termx -> .)
    /               shift and go to state 117
    *               shift and go to state 118

    termx                          shift and go to state 159

state 142

    (8) vars -> VAR datatype varids store_type ; . vars
    (8) vars -> . VAR datatype varids store_type ; vars
    (9) vars -> .
    VAR             shift and go to state 47
    WHILE           reduce using rule 9 (vars -> .)
    INPUT           reduce using rule 9 (vars -> .)
    OUTPUT          reduce using rule 9 (vars -> .)
    IF              reduce using rule 9 (vars -> .)
    RETURN          reduce using rule 9 (vars -> .)
    ID              reduce using rule 9 (vars -> .)
    (               reduce using rule 9 (vars -> .)
    STRING          reduce using rule 9 (vars -> .)
    FLOAT           reduce using rule 9 (vars -> .)
    INT             reduce using rule 9 (vars -> .)
    FALSE           reduce using rule 9 (vars -> .)
    TRUE            reduce using rule 9 (vars -> .)
    }               reduce using rule 9 (vars -> .)

    vars                           shift and go to state 160

state 143

    (11) varids -> ID darray , . varids
    (10) varids -> . ID darray
    (11) varids -> . ID darray , varids
    ID              shift and go to state 82

    varids                         shift and go to state 161

state 144

    (14) darray -> [ INT . ] twodarray
    ]               shift and go to state 162


state 145

    (17) functions -> datatype FUNC ID ( params ) store_funcv store_params store_init_quad { vars store_local_vars funcontent } . close_func functions
    (100) close_func -> .
    VOID            reduce using rule 100 (close_func -> .)
    D_BOOL          reduce using rule 100 (close_func -> .)
    D_STRING        reduce using rule 100 (close_func -> .)
    D_FLOAT         reduce using rule 100 (close_func -> .)
    D_INT           reduce using rule 100 (close_func -> .)
    VAR             reduce using rule 100 (close_func -> .)
    FUNC            reduce using rule 100 (close_func -> .)

    close_func                     shift and go to state 163

state 146

    (35) statement -> statement statement .
    (20) funcontent -> statement . funcontent
    (35) statement -> statement . statement
    (19) funcontent -> .
    (20) funcontent -> . statement funcontent
    (27) statement -> . loop unload_pv
    (28) statement -> . input unload_pv
    (29) statement -> . output unload_pv
    (30) statement -> . ifelse unload_pv
    (31) statement -> . returns unload_pv ;
    (32) statement -> . expr ;
    (33) statement -> . var_assign unload_pv
    (34) statement -> .
    (35) statement -> . statement statement
    (44) loop -> . WHILE store_jump ( expr ) store_gotof { statement } end_loop
    (43) input -> . INPUT ( ID store_oper ) ;
    (40) output -> . OUTPUT ( expr outex ) ;
    (38) ifelse -> . IF ( expr ) store_gotof { statement } ELSE store_endif { statement }
    (39) ifelse -> . IF ( expr ) store_gotof { statement } store_endif
    (37) returns -> . RETURN expr store_rquad
    (45) expr -> . arexp exprx
    (36) var_assign -> . ID store_oper = expr ;
    (56) arexp -> . term arexpextra
    (57) arexp -> . term
    (61) term -> . factor termx
    (62) term -> . factor
    (66) factor -> . element
    (67) factor -> . ( store_op expr ) store_op
    (68) element -> . callfunc store_oper
    (69) element -> . compound store_oper
    (70) element -> . const store_const
    (78) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (71) compound -> . compoundx
    (73) const -> . STRING
    (74) const -> . FLOAT
    (75) const -> . INT
    (76) const -> . FALSE
    (77) const -> . TRUE
    (72) compoundx -> . ID store_oper
  ! reduce/reduce conflict for } resolved using rule 19 (funcontent -> .)
  ! reduce/reduce conflict for WHILE resolved using rule 35 (statement -> statement statement .)
  ! reduce/reduce conflict for INPUT resolved using rule 35 (statement -> statement statement .)
  ! reduce/reduce conflict for OUTPUT resolved using rule 35 (statement -> statement statement .)
  ! reduce/reduce conflict for IF resolved using rule 35 (statement -> statement statement .)
  ! reduce/reduce conflict for RETURN resolved using rule 35 (statement -> statement statement .)
  ! reduce/reduce conflict for ID resolved using rule 35 (statement -> statement statement .)
  ! reduce/reduce conflict for ( resolved using rule 35 (statement -> statement statement .)
  ! reduce/reduce conflict for STRING resolved using rule 35 (statement -> statement statement .)
  ! reduce/reduce conflict for FLOAT resolved using rule 35 (statement -> statement statement .)
  ! reduce/reduce conflict for INT resolved using rule 35 (statement -> statement statement .)
  ! reduce/reduce conflict for FALSE resolved using rule 35 (statement -> statement statement .)
  ! reduce/reduce conflict for TRUE resolved using rule 35 (statement -> statement statement .)
  ! reduce/reduce conflict for } resolved using rule 19 (funcontent -> .)
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for OUTPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    }               reduce using rule 19 (funcontent -> .)
    WHILE           shift and go to state 62
    INPUT           shift and go to state 63
    OUTPUT          shift and go to state 65
    IF              shift and go to state 66
    RETURN          shift and go to state 67
    ID              shift and go to state 64
    (               shift and go to state 52
    STRING          shift and go to state 76
    FLOAT           shift and go to state 77
    INT             shift and go to state 78
    FALSE           shift and go to state 79
    TRUE            shift and go to state 80

    statement                      shift and go to state 146
    funcontent                     shift and go to state 147
    loop                           shift and go to state 55
    input                          shift and go to state 56
    output                         shift and go to state 57
    ifelse                         shift and go to state 58
    returns                        shift and go to state 59
    expr                           shift and go to state 60
    var_assign                     shift and go to state 61
    arexp                          shift and go to state 68
    term                           shift and go to state 69
    factor                         shift and go to state 70
    element                        shift and go to state 71
    callfunc                       shift and go to state 72
    compound                       shift and go to state 73
    const                          shift and go to state 74
    compoundx                      shift and go to state 75

state 147

    (20) funcontent -> statement funcontent .
    }               reduce using rule 20 (funcontent -> statement funcontent .)


state 148

    (67) factor -> ( store_op expr ) . store_op
    (95) store_op -> .
    /               reduce using rule 95 (store_op -> .)
    *               reduce using rule 95 (store_op -> .)
    -               reduce using rule 95 (store_op -> .)
    +               reduce using rule 95 (store_op -> .)
    OR              reduce using rule 95 (store_op -> .)
    EQEQ            reduce using rule 95 (store_op -> .)
    DIFF            reduce using rule 95 (store_op -> .)
    AND             reduce using rule 95 (store_op -> .)
    <               reduce using rule 95 (store_op -> .)
    LOETHAN         reduce using rule 95 (store_op -> .)
    >               reduce using rule 95 (store_op -> .)
    GOETHAN         reduce using rule 95 (store_op -> .)
    ;               reduce using rule 95 (store_op -> .)
    )               reduce using rule 95 (store_op -> .)
    ,               reduce using rule 95 (store_op -> .)

    store_op                       shift and go to state 164

state 149

    (44) loop -> WHILE store_jump ( expr . ) store_gotof { statement } end_loop
    )               shift and go to state 165


state 150

    (43) input -> INPUT ( ID store_oper . ) ;
    )               shift and go to state 166


state 151

    (36) var_assign -> ID store_oper = expr . ;
    ;               shift and go to state 167


state 152

    (78) callfunc -> ID verify_func add_fstack ( . callfuncpar ver_params ) end_fstack store_gosub
    (79) callfuncpar -> .
    (80) callfuncpar -> . expr store_pquad callfuncparx
    (45) expr -> . arexp exprx
    (56) arexp -> . term arexpextra
    (57) arexp -> . term
    (61) term -> . factor termx
    (62) term -> . factor
    (66) factor -> . element
    (67) factor -> . ( store_op expr ) store_op
    (68) element -> . callfunc store_oper
    (69) element -> . compound store_oper
    (70) element -> . const store_const
    (78) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (71) compound -> . compoundx
    (73) const -> . STRING
    (74) const -> . FLOAT
    (75) const -> . INT
    (76) const -> . FALSE
    (77) const -> . TRUE
    (72) compoundx -> . ID store_oper
    )               reduce using rule 79 (callfuncpar -> .)
    (               shift and go to state 52
    ID              shift and go to state 102
    STRING          shift and go to state 76
    FLOAT           shift and go to state 77
    INT             shift and go to state 78
    FALSE           shift and go to state 79
    TRUE            shift and go to state 80

    callfuncpar                    shift and go to state 168
    expr                           shift and go to state 169
    arexp                          shift and go to state 68
    term                           shift and go to state 69
    factor                         shift and go to state 70
    element                        shift and go to state 71
    callfunc                       shift and go to state 72
    compound                       shift and go to state 73
    const                          shift and go to state 74
    compoundx                      shift and go to state 75

state 153

    (40) output -> OUTPUT ( expr outex . ) ;
    )               shift and go to state 170


state 154

    (42) outex -> , . expr outex
    (45) expr -> . arexp exprx
    (56) arexp -> . term arexpextra
    (57) arexp -> . term
    (61) term -> . factor termx
    (62) term -> . factor
    (66) factor -> . element
    (67) factor -> . ( store_op expr ) store_op
    (68) element -> . callfunc store_oper
    (69) element -> . compound store_oper
    (70) element -> . const store_const
    (78) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (71) compound -> . compoundx
    (73) const -> . STRING
    (74) const -> . FLOAT
    (75) const -> . INT
    (76) const -> . FALSE
    (77) const -> . TRUE
    (72) compoundx -> . ID store_oper
    (               shift and go to state 52
    ID              shift and go to state 102
    STRING          shift and go to state 76
    FLOAT           shift and go to state 77
    INT             shift and go to state 78
    FALSE           shift and go to state 79
    TRUE            shift and go to state 80

    expr                           shift and go to state 171
    arexp                          shift and go to state 68
    term                           shift and go to state 69
    factor                         shift and go to state 70
    element                        shift and go to state 71
    callfunc                       shift and go to state 72
    compound                       shift and go to state 73
    const                          shift and go to state 74
    compoundx                      shift and go to state 75

state 155

    (38) ifelse -> IF ( expr ) . store_gotof { statement } ELSE store_endif { statement }
    (39) ifelse -> IF ( expr ) . store_gotof { statement } store_endif
    (108) store_gotof -> .
    {               reduce using rule 108 (store_gotof -> .)

    store_gotof                    shift and go to state 172

state 156

    (59) arexpextra -> - term arexpextra .
    OR              reduce using rule 59 (arexpextra -> - term arexpextra .)
    EQEQ            reduce using rule 59 (arexpextra -> - term arexpextra .)
    DIFF            reduce using rule 59 (arexpextra -> - term arexpextra .)
    AND             reduce using rule 59 (arexpextra -> - term arexpextra .)
    <               reduce using rule 59 (arexpextra -> - term arexpextra .)
    LOETHAN         reduce using rule 59 (arexpextra -> - term arexpextra .)
    >               reduce using rule 59 (arexpextra -> - term arexpextra .)
    GOETHAN         reduce using rule 59 (arexpextra -> - term arexpextra .)
    ;               reduce using rule 59 (arexpextra -> - term arexpextra .)
    )               reduce using rule 59 (arexpextra -> - term arexpextra .)
    ,               reduce using rule 59 (arexpextra -> - term arexpextra .)


state 157

    (60) arexpextra -> + term arexpextra .
    OR              reduce using rule 60 (arexpextra -> + term arexpextra .)
    EQEQ            reduce using rule 60 (arexpextra -> + term arexpextra .)
    DIFF            reduce using rule 60 (arexpextra -> + term arexpextra .)
    AND             reduce using rule 60 (arexpextra -> + term arexpextra .)
    <               reduce using rule 60 (arexpextra -> + term arexpextra .)
    LOETHAN         reduce using rule 60 (arexpextra -> + term arexpextra .)
    >               reduce using rule 60 (arexpextra -> + term arexpextra .)
    GOETHAN         reduce using rule 60 (arexpextra -> + term arexpextra .)
    ;               reduce using rule 60 (arexpextra -> + term arexpextra .)
    )               reduce using rule 60 (arexpextra -> + term arexpextra .)
    ,               reduce using rule 60 (arexpextra -> + term arexpextra .)


state 158

    (64) termx -> / factor termx .
    -               reduce using rule 64 (termx -> / factor termx .)
    +               reduce using rule 64 (termx -> / factor termx .)
    OR              reduce using rule 64 (termx -> / factor termx .)
    EQEQ            reduce using rule 64 (termx -> / factor termx .)
    DIFF            reduce using rule 64 (termx -> / factor termx .)
    AND             reduce using rule 64 (termx -> / factor termx .)
    <               reduce using rule 64 (termx -> / factor termx .)
    LOETHAN         reduce using rule 64 (termx -> / factor termx .)
    >               reduce using rule 64 (termx -> / factor termx .)
    GOETHAN         reduce using rule 64 (termx -> / factor termx .)
    ;               reduce using rule 64 (termx -> / factor termx .)
    )               reduce using rule 64 (termx -> / factor termx .)
    ,               reduce using rule 64 (termx -> / factor termx .)


state 159

    (65) termx -> * factor termx .
    -               reduce using rule 65 (termx -> * factor termx .)
    +               reduce using rule 65 (termx -> * factor termx .)
    OR              reduce using rule 65 (termx -> * factor termx .)
    EQEQ            reduce using rule 65 (termx -> * factor termx .)
    DIFF            reduce using rule 65 (termx -> * factor termx .)
    AND             reduce using rule 65 (termx -> * factor termx .)
    <               reduce using rule 65 (termx -> * factor termx .)
    LOETHAN         reduce using rule 65 (termx -> * factor termx .)
    >               reduce using rule 65 (termx -> * factor termx .)
    GOETHAN         reduce using rule 65 (termx -> * factor termx .)
    ;               reduce using rule 65 (termx -> * factor termx .)
    )               reduce using rule 65 (termx -> * factor termx .)
    ,               reduce using rule 65 (termx -> * factor termx .)


state 160

    (8) vars -> VAR datatype varids store_type ; vars .
    WHILE           reduce using rule 8 (vars -> VAR datatype varids store_type ; vars .)
    INPUT           reduce using rule 8 (vars -> VAR datatype varids store_type ; vars .)
    OUTPUT          reduce using rule 8 (vars -> VAR datatype varids store_type ; vars .)
    IF              reduce using rule 8 (vars -> VAR datatype varids store_type ; vars .)
    RETURN          reduce using rule 8 (vars -> VAR datatype varids store_type ; vars .)
    ID              reduce using rule 8 (vars -> VAR datatype varids store_type ; vars .)
    (               reduce using rule 8 (vars -> VAR datatype varids store_type ; vars .)
    STRING          reduce using rule 8 (vars -> VAR datatype varids store_type ; vars .)
    FLOAT           reduce using rule 8 (vars -> VAR datatype varids store_type ; vars .)
    INT             reduce using rule 8 (vars -> VAR datatype varids store_type ; vars .)
    FALSE           reduce using rule 8 (vars -> VAR datatype varids store_type ; vars .)
    TRUE            reduce using rule 8 (vars -> VAR datatype varids store_type ; vars .)
    }               reduce using rule 8 (vars -> VAR datatype varids store_type ; vars .)


state 161

    (11) varids -> ID darray , varids .
    ;               reduce using rule 11 (varids -> ID darray , varids .)


state 162

    (14) darray -> [ INT ] . twodarray
    (15) twodarray -> .
    (16) twodarray -> . [ INT ]
    ,               reduce using rule 15 (twodarray -> .)
    ;               reduce using rule 15 (twodarray -> .)
    [               shift and go to state 173

    twodarray                      shift and go to state 174

state 163

    (17) functions -> datatype FUNC ID ( params ) store_funcv store_params store_init_quad { vars store_local_vars funcontent } close_func . functions
    (17) functions -> . datatype FUNC ID ( params ) store_funcv store_params store_init_quad { vars store_local_vars funcontent } close_func functions
    (18) functions -> .
    (83) datatype -> . VOID
    (84) datatype -> . D_BOOL
    (85) datatype -> . D_STRING
    (86) datatype -> . D_FLOAT
    (87) datatype -> . D_INT
    VAR             reduce using rule 18 (functions -> .)
    FUNC            reduce using rule 18 (functions -> .)
    VOID            shift and go to state 10
    D_BOOL          shift and go to state 11
    D_STRING        shift and go to state 12
    D_FLOAT         shift and go to state 13
    D_INT           shift and go to state 14

    datatype                       shift and go to state 16
    functions                      shift and go to state 175

state 164

    (67) factor -> ( store_op expr ) store_op .
    /               reduce using rule 67 (factor -> ( store_op expr ) store_op .)
    *               reduce using rule 67 (factor -> ( store_op expr ) store_op .)
    -               reduce using rule 67 (factor -> ( store_op expr ) store_op .)
    +               reduce using rule 67 (factor -> ( store_op expr ) store_op .)
    OR              reduce using rule 67 (factor -> ( store_op expr ) store_op .)
    EQEQ            reduce using rule 67 (factor -> ( store_op expr ) store_op .)
    DIFF            reduce using rule 67 (factor -> ( store_op expr ) store_op .)
    AND             reduce using rule 67 (factor -> ( store_op expr ) store_op .)
    <               reduce using rule 67 (factor -> ( store_op expr ) store_op .)
    LOETHAN         reduce using rule 67 (factor -> ( store_op expr ) store_op .)
    >               reduce using rule 67 (factor -> ( store_op expr ) store_op .)
    GOETHAN         reduce using rule 67 (factor -> ( store_op expr ) store_op .)
    ;               reduce using rule 67 (factor -> ( store_op expr ) store_op .)
    )               reduce using rule 67 (factor -> ( store_op expr ) store_op .)
    ,               reduce using rule 67 (factor -> ( store_op expr ) store_op .)


state 165

    (44) loop -> WHILE store_jump ( expr ) . store_gotof { statement } end_loop
    (108) store_gotof -> .
    {               reduce using rule 108 (store_gotof -> .)

    store_gotof                    shift and go to state 176

state 166

    (43) input -> INPUT ( ID store_oper ) . ;
    ;               shift and go to state 177


state 167

    (36) var_assign -> ID store_oper = expr ; .
    WHILE           reduce using rule 36 (var_assign -> ID store_oper = expr ; .)
    INPUT           reduce using rule 36 (var_assign -> ID store_oper = expr ; .)
    OUTPUT          reduce using rule 36 (var_assign -> ID store_oper = expr ; .)
    IF              reduce using rule 36 (var_assign -> ID store_oper = expr ; .)
    RETURN          reduce using rule 36 (var_assign -> ID store_oper = expr ; .)
    ID              reduce using rule 36 (var_assign -> ID store_oper = expr ; .)
    (               reduce using rule 36 (var_assign -> ID store_oper = expr ; .)
    STRING          reduce using rule 36 (var_assign -> ID store_oper = expr ; .)
    FLOAT           reduce using rule 36 (var_assign -> ID store_oper = expr ; .)
    INT             reduce using rule 36 (var_assign -> ID store_oper = expr ; .)
    FALSE           reduce using rule 36 (var_assign -> ID store_oper = expr ; .)
    TRUE            reduce using rule 36 (var_assign -> ID store_oper = expr ; .)
    }               reduce using rule 36 (var_assign -> ID store_oper = expr ; .)


state 168

    (78) callfunc -> ID verify_func add_fstack ( callfuncpar . ver_params ) end_fstack store_gosub
    (103) ver_params -> .
    )               reduce using rule 103 (ver_params -> .)

    ver_params                     shift and go to state 178

state 169

    (80) callfuncpar -> expr . store_pquad callfuncparx
    (102) store_pquad -> .
    ,               reduce using rule 102 (store_pquad -> .)
    )               reduce using rule 102 (store_pquad -> .)

    store_pquad                    shift and go to state 179

state 170

    (40) output -> OUTPUT ( expr outex ) . ;
    ;               shift and go to state 180


state 171

    (42) outex -> , expr . outex
    (41) outex -> .
    (42) outex -> . , expr outex
    )               reduce using rule 41 (outex -> .)
    ,               shift and go to state 154

    outex                          shift and go to state 181

state 172

    (38) ifelse -> IF ( expr ) store_gotof . { statement } ELSE store_endif { statement }
    (39) ifelse -> IF ( expr ) store_gotof . { statement } store_endif
    {               shift and go to state 182


state 173

    (16) twodarray -> [ . INT ]
    INT             shift and go to state 183


state 174

    (14) darray -> [ INT ] twodarray .
    ,               reduce using rule 14 (darray -> [ INT ] twodarray .)
    ;               reduce using rule 14 (darray -> [ INT ] twodarray .)


state 175

    (17) functions -> datatype FUNC ID ( params ) store_funcv store_params store_init_quad { vars store_local_vars funcontent } close_func functions .
    VAR             reduce using rule 17 (functions -> datatype FUNC ID ( params ) store_funcv store_params store_init_quad { vars store_local_vars funcontent } close_func functions .)
    FUNC            reduce using rule 17 (functions -> datatype FUNC ID ( params ) store_funcv store_params store_init_quad { vars store_local_vars funcontent } close_func functions .)


state 176

    (44) loop -> WHILE store_jump ( expr ) store_gotof . { statement } end_loop
    {               shift and go to state 184


state 177

    (43) input -> INPUT ( ID store_oper ) ; .
    WHILE           reduce using rule 43 (input -> INPUT ( ID store_oper ) ; .)
    INPUT           reduce using rule 43 (input -> INPUT ( ID store_oper ) ; .)
    OUTPUT          reduce using rule 43 (input -> INPUT ( ID store_oper ) ; .)
    IF              reduce using rule 43 (input -> INPUT ( ID store_oper ) ; .)
    RETURN          reduce using rule 43 (input -> INPUT ( ID store_oper ) ; .)
    ID              reduce using rule 43 (input -> INPUT ( ID store_oper ) ; .)
    (               reduce using rule 43 (input -> INPUT ( ID store_oper ) ; .)
    STRING          reduce using rule 43 (input -> INPUT ( ID store_oper ) ; .)
    FLOAT           reduce using rule 43 (input -> INPUT ( ID store_oper ) ; .)
    INT             reduce using rule 43 (input -> INPUT ( ID store_oper ) ; .)
    FALSE           reduce using rule 43 (input -> INPUT ( ID store_oper ) ; .)
    TRUE            reduce using rule 43 (input -> INPUT ( ID store_oper ) ; .)
    }               reduce using rule 43 (input -> INPUT ( ID store_oper ) ; .)


state 178

    (78) callfunc -> ID verify_func add_fstack ( callfuncpar ver_params . ) end_fstack store_gosub
    )               shift and go to state 185


state 179

    (80) callfuncpar -> expr store_pquad . callfuncparx
    (81) callfuncparx -> .
    (82) callfuncparx -> . , callfuncpar
    )               reduce using rule 81 (callfuncparx -> .)
    ,               shift and go to state 187

    callfuncparx                   shift and go to state 186

state 180

    (40) output -> OUTPUT ( expr outex ) ; .
    WHILE           reduce using rule 40 (output -> OUTPUT ( expr outex ) ; .)
    INPUT           reduce using rule 40 (output -> OUTPUT ( expr outex ) ; .)
    OUTPUT          reduce using rule 40 (output -> OUTPUT ( expr outex ) ; .)
    IF              reduce using rule 40 (output -> OUTPUT ( expr outex ) ; .)
    RETURN          reduce using rule 40 (output -> OUTPUT ( expr outex ) ; .)
    ID              reduce using rule 40 (output -> OUTPUT ( expr outex ) ; .)
    (               reduce using rule 40 (output -> OUTPUT ( expr outex ) ; .)
    STRING          reduce using rule 40 (output -> OUTPUT ( expr outex ) ; .)
    FLOAT           reduce using rule 40 (output -> OUTPUT ( expr outex ) ; .)
    INT             reduce using rule 40 (output -> OUTPUT ( expr outex ) ; .)
    FALSE           reduce using rule 40 (output -> OUTPUT ( expr outex ) ; .)
    TRUE            reduce using rule 40 (output -> OUTPUT ( expr outex ) ; .)
    }               reduce using rule 40 (output -> OUTPUT ( expr outex ) ; .)


state 181

    (42) outex -> , expr outex .
    )               reduce using rule 42 (outex -> , expr outex .)


state 182

    (38) ifelse -> IF ( expr ) store_gotof { . statement } ELSE store_endif { statement }
    (39) ifelse -> IF ( expr ) store_gotof { . statement } store_endif
    (27) statement -> . loop unload_pv
    (28) statement -> . input unload_pv
    (29) statement -> . output unload_pv
    (30) statement -> . ifelse unload_pv
    (31) statement -> . returns unload_pv ;
    (32) statement -> . expr ;
    (33) statement -> . var_assign unload_pv
    (34) statement -> .
    (35) statement -> . statement statement
    (44) loop -> . WHILE store_jump ( expr ) store_gotof { statement } end_loop
    (43) input -> . INPUT ( ID store_oper ) ;
    (40) output -> . OUTPUT ( expr outex ) ;
    (38) ifelse -> . IF ( expr ) store_gotof { statement } ELSE store_endif { statement }
    (39) ifelse -> . IF ( expr ) store_gotof { statement } store_endif
    (37) returns -> . RETURN expr store_rquad
    (45) expr -> . arexp exprx
    (36) var_assign -> . ID store_oper = expr ;
    (56) arexp -> . term arexpextra
    (57) arexp -> . term
    (61) term -> . factor termx
    (62) term -> . factor
    (66) factor -> . element
    (67) factor -> . ( store_op expr ) store_op
    (68) element -> . callfunc store_oper
    (69) element -> . compound store_oper
    (70) element -> . const store_const
    (78) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (71) compound -> . compoundx
    (73) const -> . STRING
    (74) const -> . FLOAT
    (75) const -> . INT
    (76) const -> . FALSE
    (77) const -> . TRUE
    (72) compoundx -> . ID store_oper
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for OUTPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    }               reduce using rule 34 (statement -> .)
    WHILE           shift and go to state 62
    INPUT           shift and go to state 63
    OUTPUT          shift and go to state 65
    IF              shift and go to state 66
    RETURN          shift and go to state 67
    ID              shift and go to state 64
    (               shift and go to state 52
    STRING          shift and go to state 76
    FLOAT           shift and go to state 77
    INT             shift and go to state 78
    FALSE           shift and go to state 79
    TRUE            shift and go to state 80

    expr                           shift and go to state 60
    statement                      shift and go to state 188
    loop                           shift and go to state 55
    input                          shift and go to state 56
    output                         shift and go to state 57
    ifelse                         shift and go to state 58
    returns                        shift and go to state 59
    var_assign                     shift and go to state 61
    arexp                          shift and go to state 68
    term                           shift and go to state 69
    factor                         shift and go to state 70
    element                        shift and go to state 71
    callfunc                       shift and go to state 72
    compound                       shift and go to state 73
    const                          shift and go to state 74
    compoundx                      shift and go to state 75

state 183

    (16) twodarray -> [ INT . ]
    ]               shift and go to state 189


state 184

    (44) loop -> WHILE store_jump ( expr ) store_gotof { . statement } end_loop
    (27) statement -> . loop unload_pv
    (28) statement -> . input unload_pv
    (29) statement -> . output unload_pv
    (30) statement -> . ifelse unload_pv
    (31) statement -> . returns unload_pv ;
    (32) statement -> . expr ;
    (33) statement -> . var_assign unload_pv
    (34) statement -> .
    (35) statement -> . statement statement
    (44) loop -> . WHILE store_jump ( expr ) store_gotof { statement } end_loop
    (43) input -> . INPUT ( ID store_oper ) ;
    (40) output -> . OUTPUT ( expr outex ) ;
    (38) ifelse -> . IF ( expr ) store_gotof { statement } ELSE store_endif { statement }
    (39) ifelse -> . IF ( expr ) store_gotof { statement } store_endif
    (37) returns -> . RETURN expr store_rquad
    (45) expr -> . arexp exprx
    (36) var_assign -> . ID store_oper = expr ;
    (56) arexp -> . term arexpextra
    (57) arexp -> . term
    (61) term -> . factor termx
    (62) term -> . factor
    (66) factor -> . element
    (67) factor -> . ( store_op expr ) store_op
    (68) element -> . callfunc store_oper
    (69) element -> . compound store_oper
    (70) element -> . const store_const
    (78) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (71) compound -> . compoundx
    (73) const -> . STRING
    (74) const -> . FLOAT
    (75) const -> . INT
    (76) const -> . FALSE
    (77) const -> . TRUE
    (72) compoundx -> . ID store_oper
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for OUTPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    }               reduce using rule 34 (statement -> .)
    WHILE           shift and go to state 62
    INPUT           shift and go to state 63
    OUTPUT          shift and go to state 65
    IF              shift and go to state 66
    RETURN          shift and go to state 67
    ID              shift and go to state 64
    (               shift and go to state 52
    STRING          shift and go to state 76
    FLOAT           shift and go to state 77
    INT             shift and go to state 78
    FALSE           shift and go to state 79
    TRUE            shift and go to state 80

    expr                           shift and go to state 60
    statement                      shift and go to state 190
    loop                           shift and go to state 55
    input                          shift and go to state 56
    output                         shift and go to state 57
    ifelse                         shift and go to state 58
    returns                        shift and go to state 59
    var_assign                     shift and go to state 61
    arexp                          shift and go to state 68
    term                           shift and go to state 69
    factor                         shift and go to state 70
    element                        shift and go to state 71
    callfunc                       shift and go to state 72
    compound                       shift and go to state 73
    const                          shift and go to state 74
    compoundx                      shift and go to state 75

state 185

    (78) callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) . end_fstack store_gosub
    (106) end_fstack -> .
    /               reduce using rule 106 (end_fstack -> .)
    *               reduce using rule 106 (end_fstack -> .)
    -               reduce using rule 106 (end_fstack -> .)
    +               reduce using rule 106 (end_fstack -> .)
    OR              reduce using rule 106 (end_fstack -> .)
    EQEQ            reduce using rule 106 (end_fstack -> .)
    DIFF            reduce using rule 106 (end_fstack -> .)
    AND             reduce using rule 106 (end_fstack -> .)
    <               reduce using rule 106 (end_fstack -> .)
    LOETHAN         reduce using rule 106 (end_fstack -> .)
    >               reduce using rule 106 (end_fstack -> .)
    GOETHAN         reduce using rule 106 (end_fstack -> .)
    ;               reduce using rule 106 (end_fstack -> .)
    )               reduce using rule 106 (end_fstack -> .)
    ,               reduce using rule 106 (end_fstack -> .)

    end_fstack                     shift and go to state 191

state 186

    (80) callfuncpar -> expr store_pquad callfuncparx .
    )               reduce using rule 80 (callfuncpar -> expr store_pquad callfuncparx .)


state 187

    (82) callfuncparx -> , . callfuncpar
    (79) callfuncpar -> .
    (80) callfuncpar -> . expr store_pquad callfuncparx
    (45) expr -> . arexp exprx
    (56) arexp -> . term arexpextra
    (57) arexp -> . term
    (61) term -> . factor termx
    (62) term -> . factor
    (66) factor -> . element
    (67) factor -> . ( store_op expr ) store_op
    (68) element -> . callfunc store_oper
    (69) element -> . compound store_oper
    (70) element -> . const store_const
    (78) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (71) compound -> . compoundx
    (73) const -> . STRING
    (74) const -> . FLOAT
    (75) const -> . INT
    (76) const -> . FALSE
    (77) const -> . TRUE
    (72) compoundx -> . ID store_oper
    )               reduce using rule 79 (callfuncpar -> .)
    (               shift and go to state 52
    ID              shift and go to state 102
    STRING          shift and go to state 76
    FLOAT           shift and go to state 77
    INT             shift and go to state 78
    FALSE           shift and go to state 79
    TRUE            shift and go to state 80

    callfuncpar                    shift and go to state 192
    expr                           shift and go to state 169
    arexp                          shift and go to state 68
    term                           shift and go to state 69
    factor                         shift and go to state 70
    element                        shift and go to state 71
    callfunc                       shift and go to state 72
    compound                       shift and go to state 73
    const                          shift and go to state 74
    compoundx                      shift and go to state 75

state 188

    (38) ifelse -> IF ( expr ) store_gotof { statement . } ELSE store_endif { statement }
    (39) ifelse -> IF ( expr ) store_gotof { statement . } store_endif
    (35) statement -> statement . statement
    (27) statement -> . loop unload_pv
    (28) statement -> . input unload_pv
    (29) statement -> . output unload_pv
    (30) statement -> . ifelse unload_pv
    (31) statement -> . returns unload_pv ;
    (32) statement -> . expr ;
    (33) statement -> . var_assign unload_pv
    (34) statement -> .
    (35) statement -> . statement statement
    (44) loop -> . WHILE store_jump ( expr ) store_gotof { statement } end_loop
    (43) input -> . INPUT ( ID store_oper ) ;
    (40) output -> . OUTPUT ( expr outex ) ;
    (38) ifelse -> . IF ( expr ) store_gotof { statement } ELSE store_endif { statement }
    (39) ifelse -> . IF ( expr ) store_gotof { statement } store_endif
    (37) returns -> . RETURN expr store_rquad
    (45) expr -> . arexp exprx
    (36) var_assign -> . ID store_oper = expr ;
    (56) arexp -> . term arexpextra
    (57) arexp -> . term
    (61) term -> . factor termx
    (62) term -> . factor
    (66) factor -> . element
    (67) factor -> . ( store_op expr ) store_op
    (68) element -> . callfunc store_oper
    (69) element -> . compound store_oper
    (70) element -> . const store_const
    (78) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (71) compound -> . compoundx
    (73) const -> . STRING
    (74) const -> . FLOAT
    (75) const -> . INT
    (76) const -> . FALSE
    (77) const -> . TRUE
    (72) compoundx -> . ID store_oper
  ! shift/reduce conflict for } resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for OUTPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    }               shift and go to state 194
    WHILE           shift and go to state 62
    INPUT           shift and go to state 63
    OUTPUT          shift and go to state 65
    IF              shift and go to state 66
    RETURN          shift and go to state 67
    ID              shift and go to state 64
    (               shift and go to state 52
    STRING          shift and go to state 76
    FLOAT           shift and go to state 77
    INT             shift and go to state 78
    FALSE           shift and go to state 79
    TRUE            shift and go to state 80

    expr                           shift and go to state 60
    statement                      shift and go to state 193
    loop                           shift and go to state 55
    input                          shift and go to state 56
    output                         shift and go to state 57
    ifelse                         shift and go to state 58
    returns                        shift and go to state 59
    var_assign                     shift and go to state 61
    arexp                          shift and go to state 68
    term                           shift and go to state 69
    factor                         shift and go to state 70
    element                        shift and go to state 71
    callfunc                       shift and go to state 72
    compound                       shift and go to state 73
    const                          shift and go to state 74
    compoundx                      shift and go to state 75

state 189

    (16) twodarray -> [ INT ] .
    ,               reduce using rule 16 (twodarray -> [ INT ] .)
    ;               reduce using rule 16 (twodarray -> [ INT ] .)


state 190

    (44) loop -> WHILE store_jump ( expr ) store_gotof { statement . } end_loop
    (35) statement -> statement . statement
    (27) statement -> . loop unload_pv
    (28) statement -> . input unload_pv
    (29) statement -> . output unload_pv
    (30) statement -> . ifelse unload_pv
    (31) statement -> . returns unload_pv ;
    (32) statement -> . expr ;
    (33) statement -> . var_assign unload_pv
    (34) statement -> .
    (35) statement -> . statement statement
    (44) loop -> . WHILE store_jump ( expr ) store_gotof { statement } end_loop
    (43) input -> . INPUT ( ID store_oper ) ;
    (40) output -> . OUTPUT ( expr outex ) ;
    (38) ifelse -> . IF ( expr ) store_gotof { statement } ELSE store_endif { statement }
    (39) ifelse -> . IF ( expr ) store_gotof { statement } store_endif
    (37) returns -> . RETURN expr store_rquad
    (45) expr -> . arexp exprx
    (36) var_assign -> . ID store_oper = expr ;
    (56) arexp -> . term arexpextra
    (57) arexp -> . term
    (61) term -> . factor termx
    (62) term -> . factor
    (66) factor -> . element
    (67) factor -> . ( store_op expr ) store_op
    (68) element -> . callfunc store_oper
    (69) element -> . compound store_oper
    (70) element -> . const store_const
    (78) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (71) compound -> . compoundx
    (73) const -> . STRING
    (74) const -> . FLOAT
    (75) const -> . INT
    (76) const -> . FALSE
    (77) const -> . TRUE
    (72) compoundx -> . ID store_oper
  ! shift/reduce conflict for } resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for OUTPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    }               shift and go to state 195
    WHILE           shift and go to state 62
    INPUT           shift and go to state 63
    OUTPUT          shift and go to state 65
    IF              shift and go to state 66
    RETURN          shift and go to state 67
    ID              shift and go to state 64
    (               shift and go to state 52
    STRING          shift and go to state 76
    FLOAT           shift and go to state 77
    INT             shift and go to state 78
    FALSE           shift and go to state 79
    TRUE            shift and go to state 80

    expr                           shift and go to state 60
    statement                      shift and go to state 193
    loop                           shift and go to state 55
    input                          shift and go to state 56
    output                         shift and go to state 57
    ifelse                         shift and go to state 58
    returns                        shift and go to state 59
    var_assign                     shift and go to state 61
    arexp                          shift and go to state 68
    term                           shift and go to state 69
    factor                         shift and go to state 70
    element                        shift and go to state 71
    callfunc                       shift and go to state 72
    compound                       shift and go to state 73
    const                          shift and go to state 74
    compoundx                      shift and go to state 75

state 191

    (78) callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack . store_gosub
    (107) store_gosub -> .
    /               reduce using rule 107 (store_gosub -> .)
    *               reduce using rule 107 (store_gosub -> .)
    -               reduce using rule 107 (store_gosub -> .)
    +               reduce using rule 107 (store_gosub -> .)
    OR              reduce using rule 107 (store_gosub -> .)
    EQEQ            reduce using rule 107 (store_gosub -> .)
    DIFF            reduce using rule 107 (store_gosub -> .)
    AND             reduce using rule 107 (store_gosub -> .)
    <               reduce using rule 107 (store_gosub -> .)
    LOETHAN         reduce using rule 107 (store_gosub -> .)
    >               reduce using rule 107 (store_gosub -> .)
    GOETHAN         reduce using rule 107 (store_gosub -> .)
    ;               reduce using rule 107 (store_gosub -> .)
    )               reduce using rule 107 (store_gosub -> .)
    ,               reduce using rule 107 (store_gosub -> .)

    store_gosub                    shift and go to state 196

state 192

    (82) callfuncparx -> , callfuncpar .
    )               reduce using rule 82 (callfuncparx -> , callfuncpar .)


state 193

    (35) statement -> statement statement .
    (35) statement -> statement . statement
    (27) statement -> . loop unload_pv
    (28) statement -> . input unload_pv
    (29) statement -> . output unload_pv
    (30) statement -> . ifelse unload_pv
    (31) statement -> . returns unload_pv ;
    (32) statement -> . expr ;
    (33) statement -> . var_assign unload_pv
    (34) statement -> .
    (35) statement -> . statement statement
    (44) loop -> . WHILE store_jump ( expr ) store_gotof { statement } end_loop
    (43) input -> . INPUT ( ID store_oper ) ;
    (40) output -> . OUTPUT ( expr outex ) ;
    (38) ifelse -> . IF ( expr ) store_gotof { statement } ELSE store_endif { statement }
    (39) ifelse -> . IF ( expr ) store_gotof { statement } store_endif
    (37) returns -> . RETURN expr store_rquad
    (45) expr -> . arexp exprx
    (36) var_assign -> . ID store_oper = expr ;
    (56) arexp -> . term arexpextra
    (57) arexp -> . term
    (61) term -> . factor termx
    (62) term -> . factor
    (66) factor -> . element
    (67) factor -> . ( store_op expr ) store_op
    (68) element -> . callfunc store_oper
    (69) element -> . compound store_oper
    (70) element -> . const store_const
    (78) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (71) compound -> . compoundx
    (73) const -> . STRING
    (74) const -> . FLOAT
    (75) const -> . INT
    (76) const -> . FALSE
    (77) const -> . TRUE
    (72) compoundx -> . ID store_oper
  ! reduce/reduce conflict for WHILE resolved using rule 35 (statement -> statement statement .)
  ! reduce/reduce conflict for INPUT resolved using rule 35 (statement -> statement statement .)
  ! reduce/reduce conflict for OUTPUT resolved using rule 35 (statement -> statement statement .)
  ! reduce/reduce conflict for IF resolved using rule 35 (statement -> statement statement .)
  ! reduce/reduce conflict for RETURN resolved using rule 35 (statement -> statement statement .)
  ! reduce/reduce conflict for ID resolved using rule 35 (statement -> statement statement .)
  ! reduce/reduce conflict for ( resolved using rule 35 (statement -> statement statement .)
  ! reduce/reduce conflict for STRING resolved using rule 35 (statement -> statement statement .)
  ! reduce/reduce conflict for FLOAT resolved using rule 35 (statement -> statement statement .)
  ! reduce/reduce conflict for INT resolved using rule 35 (statement -> statement statement .)
  ! reduce/reduce conflict for FALSE resolved using rule 35 (statement -> statement statement .)
  ! reduce/reduce conflict for TRUE resolved using rule 35 (statement -> statement statement .)
  ! reduce/reduce conflict for } resolved using rule 35 (statement -> statement statement .)
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for OUTPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    }               reduce using rule 35 (statement -> statement statement .)
    WHILE           shift and go to state 62
    INPUT           shift and go to state 63
    OUTPUT          shift and go to state 65
    IF              shift and go to state 66
    RETURN          shift and go to state 67
    ID              shift and go to state 64
    (               shift and go to state 52
    STRING          shift and go to state 76
    FLOAT           shift and go to state 77
    INT             shift and go to state 78
    FALSE           shift and go to state 79
    TRUE            shift and go to state 80

    statement                      shift and go to state 193
    loop                           shift and go to state 55
    input                          shift and go to state 56
    output                         shift and go to state 57
    ifelse                         shift and go to state 58
    returns                        shift and go to state 59
    expr                           shift and go to state 60
    var_assign                     shift and go to state 61
    arexp                          shift and go to state 68
    term                           shift and go to state 69
    factor                         shift and go to state 70
    element                        shift and go to state 71
    callfunc                       shift and go to state 72
    compound                       shift and go to state 73
    const                          shift and go to state 74
    compoundx                      shift and go to state 75

state 194

    (38) ifelse -> IF ( expr ) store_gotof { statement } . ELSE store_endif { statement }
    (39) ifelse -> IF ( expr ) store_gotof { statement } . store_endif
    (101) store_endif -> .
    ELSE            shift and go to state 197
    WHILE           reduce using rule 101 (store_endif -> .)
    INPUT           reduce using rule 101 (store_endif -> .)
    OUTPUT          reduce using rule 101 (store_endif -> .)
    IF              reduce using rule 101 (store_endif -> .)
    RETURN          reduce using rule 101 (store_endif -> .)
    ID              reduce using rule 101 (store_endif -> .)
    (               reduce using rule 101 (store_endif -> .)
    STRING          reduce using rule 101 (store_endif -> .)
    FLOAT           reduce using rule 101 (store_endif -> .)
    INT             reduce using rule 101 (store_endif -> .)
    FALSE           reduce using rule 101 (store_endif -> .)
    TRUE            reduce using rule 101 (store_endif -> .)
    }               reduce using rule 101 (store_endif -> .)

    store_endif                    shift and go to state 198

state 195

    (44) loop -> WHILE store_jump ( expr ) store_gotof { statement } . end_loop
    (110) end_loop -> .
    WHILE           reduce using rule 110 (end_loop -> .)
    INPUT           reduce using rule 110 (end_loop -> .)
    OUTPUT          reduce using rule 110 (end_loop -> .)
    IF              reduce using rule 110 (end_loop -> .)
    RETURN          reduce using rule 110 (end_loop -> .)
    ID              reduce using rule 110 (end_loop -> .)
    (               reduce using rule 110 (end_loop -> .)
    STRING          reduce using rule 110 (end_loop -> .)
    FLOAT           reduce using rule 110 (end_loop -> .)
    INT             reduce using rule 110 (end_loop -> .)
    FALSE           reduce using rule 110 (end_loop -> .)
    TRUE            reduce using rule 110 (end_loop -> .)
    }               reduce using rule 110 (end_loop -> .)

    end_loop                       shift and go to state 199

state 196

    (78) callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub .
    /               reduce using rule 78 (callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub .)
    *               reduce using rule 78 (callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub .)
    -               reduce using rule 78 (callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub .)
    +               reduce using rule 78 (callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub .)
    OR              reduce using rule 78 (callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub .)
    EQEQ            reduce using rule 78 (callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub .)
    DIFF            reduce using rule 78 (callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub .)
    AND             reduce using rule 78 (callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub .)
    <               reduce using rule 78 (callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub .)
    LOETHAN         reduce using rule 78 (callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub .)
    >               reduce using rule 78 (callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub .)
    GOETHAN         reduce using rule 78 (callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub .)
    ;               reduce using rule 78 (callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub .)
    )               reduce using rule 78 (callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub .)
    ,               reduce using rule 78 (callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub .)


state 197

    (38) ifelse -> IF ( expr ) store_gotof { statement } ELSE . store_endif { statement }
    (101) store_endif -> .
    {               reduce using rule 101 (store_endif -> .)

    store_endif                    shift and go to state 200

state 198

    (39) ifelse -> IF ( expr ) store_gotof { statement } store_endif .
    WHILE           reduce using rule 39 (ifelse -> IF ( expr ) store_gotof { statement } store_endif .)
    INPUT           reduce using rule 39 (ifelse -> IF ( expr ) store_gotof { statement } store_endif .)
    OUTPUT          reduce using rule 39 (ifelse -> IF ( expr ) store_gotof { statement } store_endif .)
    IF              reduce using rule 39 (ifelse -> IF ( expr ) store_gotof { statement } store_endif .)
    RETURN          reduce using rule 39 (ifelse -> IF ( expr ) store_gotof { statement } store_endif .)
    ID              reduce using rule 39 (ifelse -> IF ( expr ) store_gotof { statement } store_endif .)
    (               reduce using rule 39 (ifelse -> IF ( expr ) store_gotof { statement } store_endif .)
    STRING          reduce using rule 39 (ifelse -> IF ( expr ) store_gotof { statement } store_endif .)
    FLOAT           reduce using rule 39 (ifelse -> IF ( expr ) store_gotof { statement } store_endif .)
    INT             reduce using rule 39 (ifelse -> IF ( expr ) store_gotof { statement } store_endif .)
    FALSE           reduce using rule 39 (ifelse -> IF ( expr ) store_gotof { statement } store_endif .)
    TRUE            reduce using rule 39 (ifelse -> IF ( expr ) store_gotof { statement } store_endif .)
    }               reduce using rule 39 (ifelse -> IF ( expr ) store_gotof { statement } store_endif .)


state 199

    (44) loop -> WHILE store_jump ( expr ) store_gotof { statement } end_loop .
    WHILE           reduce using rule 44 (loop -> WHILE store_jump ( expr ) store_gotof { statement } end_loop .)
    INPUT           reduce using rule 44 (loop -> WHILE store_jump ( expr ) store_gotof { statement } end_loop .)
    OUTPUT          reduce using rule 44 (loop -> WHILE store_jump ( expr ) store_gotof { statement } end_loop .)
    IF              reduce using rule 44 (loop -> WHILE store_jump ( expr ) store_gotof { statement } end_loop .)
    RETURN          reduce using rule 44 (loop -> WHILE store_jump ( expr ) store_gotof { statement } end_loop .)
    ID              reduce using rule 44 (loop -> WHILE store_jump ( expr ) store_gotof { statement } end_loop .)
    (               reduce using rule 44 (loop -> WHILE store_jump ( expr ) store_gotof { statement } end_loop .)
    STRING          reduce using rule 44 (loop -> WHILE store_jump ( expr ) store_gotof { statement } end_loop .)
    FLOAT           reduce using rule 44 (loop -> WHILE store_jump ( expr ) store_gotof { statement } end_loop .)
    INT             reduce using rule 44 (loop -> WHILE store_jump ( expr ) store_gotof { statement } end_loop .)
    FALSE           reduce using rule 44 (loop -> WHILE store_jump ( expr ) store_gotof { statement } end_loop .)
    TRUE            reduce using rule 44 (loop -> WHILE store_jump ( expr ) store_gotof { statement } end_loop .)
    }               reduce using rule 44 (loop -> WHILE store_jump ( expr ) store_gotof { statement } end_loop .)


state 200

    (38) ifelse -> IF ( expr ) store_gotof { statement } ELSE store_endif . { statement }
    {               shift and go to state 201


state 201

    (38) ifelse -> IF ( expr ) store_gotof { statement } ELSE store_endif { . statement }
    (27) statement -> . loop unload_pv
    (28) statement -> . input unload_pv
    (29) statement -> . output unload_pv
    (30) statement -> . ifelse unload_pv
    (31) statement -> . returns unload_pv ;
    (32) statement -> . expr ;
    (33) statement -> . var_assign unload_pv
    (34) statement -> .
    (35) statement -> . statement statement
    (44) loop -> . WHILE store_jump ( expr ) store_gotof { statement } end_loop
    (43) input -> . INPUT ( ID store_oper ) ;
    (40) output -> . OUTPUT ( expr outex ) ;
    (38) ifelse -> . IF ( expr ) store_gotof { statement } ELSE store_endif { statement }
    (39) ifelse -> . IF ( expr ) store_gotof { statement } store_endif
    (37) returns -> . RETURN expr store_rquad
    (45) expr -> . arexp exprx
    (36) var_assign -> . ID store_oper = expr ;
    (56) arexp -> . term arexpextra
    (57) arexp -> . term
    (61) term -> . factor termx
    (62) term -> . factor
    (66) factor -> . element
    (67) factor -> . ( store_op expr ) store_op
    (68) element -> . callfunc store_oper
    (69) element -> . compound store_oper
    (70) element -> . const store_const
    (78) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (71) compound -> . compoundx
    (73) const -> . STRING
    (74) const -> . FLOAT
    (75) const -> . INT
    (76) const -> . FALSE
    (77) const -> . TRUE
    (72) compoundx -> . ID store_oper
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for OUTPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    }               reduce using rule 34 (statement -> .)
    WHILE           shift and go to state 62
    INPUT           shift and go to state 63
    OUTPUT          shift and go to state 65
    IF              shift and go to state 66
    RETURN          shift and go to state 67
    ID              shift and go to state 64
    (               shift and go to state 52
    STRING          shift and go to state 76
    FLOAT           shift and go to state 77
    INT             shift and go to state 78
    FALSE           shift and go to state 79
    TRUE            shift and go to state 80

    expr                           shift and go to state 60
    statement                      shift and go to state 202
    loop                           shift and go to state 55
    input                          shift and go to state 56
    output                         shift and go to state 57
    ifelse                         shift and go to state 58
    returns                        shift and go to state 59
    var_assign                     shift and go to state 61
    arexp                          shift and go to state 68
    term                           shift and go to state 69
    factor                         shift and go to state 70
    element                        shift and go to state 71
    callfunc                       shift and go to state 72
    compound                       shift and go to state 73
    const                          shift and go to state 74
    compoundx                      shift and go to state 75

state 202

    (38) ifelse -> IF ( expr ) store_gotof { statement } ELSE store_endif { statement . }
    (35) statement -> statement . statement
    (27) statement -> . loop unload_pv
    (28) statement -> . input unload_pv
    (29) statement -> . output unload_pv
    (30) statement -> . ifelse unload_pv
    (31) statement -> . returns unload_pv ;
    (32) statement -> . expr ;
    (33) statement -> . var_assign unload_pv
    (34) statement -> .
    (35) statement -> . statement statement
    (44) loop -> . WHILE store_jump ( expr ) store_gotof { statement } end_loop
    (43) input -> . INPUT ( ID store_oper ) ;
    (40) output -> . OUTPUT ( expr outex ) ;
    (38) ifelse -> . IF ( expr ) store_gotof { statement } ELSE store_endif { statement }
    (39) ifelse -> . IF ( expr ) store_gotof { statement } store_endif
    (37) returns -> . RETURN expr store_rquad
    (45) expr -> . arexp exprx
    (36) var_assign -> . ID store_oper = expr ;
    (56) arexp -> . term arexpextra
    (57) arexp -> . term
    (61) term -> . factor termx
    (62) term -> . factor
    (66) factor -> . element
    (67) factor -> . ( store_op expr ) store_op
    (68) element -> . callfunc store_oper
    (69) element -> . compound store_oper
    (70) element -> . const store_const
    (78) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (71) compound -> . compoundx
    (73) const -> . STRING
    (74) const -> . FLOAT
    (75) const -> . INT
    (76) const -> . FALSE
    (77) const -> . TRUE
    (72) compoundx -> . ID store_oper
  ! shift/reduce conflict for } resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for OUTPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    }               shift and go to state 203
    WHILE           shift and go to state 62
    INPUT           shift and go to state 63
    OUTPUT          shift and go to state 65
    IF              shift and go to state 66
    RETURN          shift and go to state 67
    ID              shift and go to state 64
    (               shift and go to state 52
    STRING          shift and go to state 76
    FLOAT           shift and go to state 77
    INT             shift and go to state 78
    FALSE           shift and go to state 79
    TRUE            shift and go to state 80

    expr                           shift and go to state 60
    statement                      shift and go to state 193
    loop                           shift and go to state 55
    input                          shift and go to state 56
    output                         shift and go to state 57
    ifelse                         shift and go to state 58
    returns                        shift and go to state 59
    var_assign                     shift and go to state 61
    arexp                          shift and go to state 68
    term                           shift and go to state 69
    factor                         shift and go to state 70
    element                        shift and go to state 71
    callfunc                       shift and go to state 72
    compound                       shift and go to state 73
    const                          shift and go to state 74
    compoundx                      shift and go to state 75

state 203

    (38) ifelse -> IF ( expr ) store_gotof { statement } ELSE store_endif { statement } .
    WHILE           reduce using rule 38 (ifelse -> IF ( expr ) store_gotof { statement } ELSE store_endif { statement } .)
    INPUT           reduce using rule 38 (ifelse -> IF ( expr ) store_gotof { statement } ELSE store_endif { statement } .)
    OUTPUT          reduce using rule 38 (ifelse -> IF ( expr ) store_gotof { statement } ELSE store_endif { statement } .)
    IF              reduce using rule 38 (ifelse -> IF ( expr ) store_gotof { statement } ELSE store_endif { statement } .)
    RETURN          reduce using rule 38 (ifelse -> IF ( expr ) store_gotof { statement } ELSE store_endif { statement } .)
    ID              reduce using rule 38 (ifelse -> IF ( expr ) store_gotof { statement } ELSE store_endif { statement } .)
    (               reduce using rule 38 (ifelse -> IF ( expr ) store_gotof { statement } ELSE store_endif { statement } .)
    STRING          reduce using rule 38 (ifelse -> IF ( expr ) store_gotof { statement } ELSE store_endif { statement } .)
    FLOAT           reduce using rule 38 (ifelse -> IF ( expr ) store_gotof { statement } ELSE store_endif { statement } .)
    INT             reduce using rule 38 (ifelse -> IF ( expr ) store_gotof { statement } ELSE store_endif { statement } .)
    FALSE           reduce using rule 38 (ifelse -> IF ( expr ) store_gotof { statement } ELSE store_endif { statement } .)
    TRUE            reduce using rule 38 (ifelse -> IF ( expr ) store_gotof { statement } ELSE store_endif { statement } .)
    }               reduce using rule 38 (ifelse -> IF ( expr ) store_gotof { statement } ELSE store_endif { statement } .)


Conflicts:

shift/reduce conflict for VAR in state 5 resolved as shift
shift/reduce conflict for VAR in state 25 resolved as shift
shift/reduce conflict for WHILE in state 49 resolved as shift
shift/reduce conflict for INPUT in state 49 resolved as shift
shift/reduce conflict for OUTPUT in state 49 resolved as shift
shift/reduce conflict for IF in state 49 resolved as shift
shift/reduce conflict for RETURN in state 49 resolved as shift
shift/reduce conflict for ID in state 49 resolved as shift
shift/reduce conflict for ( in state 49 resolved as shift
shift/reduce conflict for STRING in state 49 resolved as shift
shift/reduce conflict for FLOAT in state 49 resolved as shift
shift/reduce conflict for INT in state 49 resolved as shift
shift/reduce conflict for FALSE in state 49 resolved as shift
shift/reduce conflict for TRUE in state 49 resolved as shift
shift/reduce conflict for WHILE in state 54 resolved as shift
shift/reduce conflict for INPUT in state 54 resolved as shift
shift/reduce conflict for OUTPUT in state 54 resolved as shift
shift/reduce conflict for IF in state 54 resolved as shift
shift/reduce conflict for RETURN in state 54 resolved as shift
shift/reduce conflict for ID in state 54 resolved as shift
shift/reduce conflict for ( in state 54 resolved as shift
shift/reduce conflict for STRING in state 54 resolved as shift
shift/reduce conflict for FLOAT in state 54 resolved as shift
shift/reduce conflict for INT in state 54 resolved as shift
shift/reduce conflict for FALSE in state 54 resolved as shift
shift/reduce conflict for TRUE in state 54 resolved as shift
shift/reduce conflict for WHILE in state 83 resolved as shift
shift/reduce conflict for INPUT in state 83 resolved as shift
shift/reduce conflict for OUTPUT in state 83 resolved as shift
shift/reduce conflict for IF in state 83 resolved as shift
shift/reduce conflict for RETURN in state 83 resolved as shift
shift/reduce conflict for ID in state 83 resolved as shift
shift/reduce conflict for ( in state 83 resolved as shift
shift/reduce conflict for STRING in state 83 resolved as shift
shift/reduce conflict for FLOAT in state 83 resolved as shift
shift/reduce conflict for INT in state 83 resolved as shift
shift/reduce conflict for FALSE in state 83 resolved as shift
shift/reduce conflict for TRUE in state 83 resolved as shift
shift/reduce conflict for WHILE in state 86 resolved as shift
shift/reduce conflict for INPUT in state 86 resolved as shift
shift/reduce conflict for OUTPUT in state 86 resolved as shift
shift/reduce conflict for IF in state 86 resolved as shift
shift/reduce conflict for RETURN in state 86 resolved as shift
shift/reduce conflict for ID in state 86 resolved as shift
shift/reduce conflict for ( in state 86 resolved as shift
shift/reduce conflict for STRING in state 86 resolved as shift
shift/reduce conflict for FLOAT in state 86 resolved as shift
shift/reduce conflict for INT in state 86 resolved as shift
shift/reduce conflict for FALSE in state 86 resolved as shift
shift/reduce conflict for TRUE in state 86 resolved as shift
shift/reduce conflict for WHILE in state 126 resolved as shift
shift/reduce conflict for INPUT in state 126 resolved as shift
shift/reduce conflict for OUTPUT in state 126 resolved as shift
shift/reduce conflict for IF in state 126 resolved as shift
shift/reduce conflict for RETURN in state 126 resolved as shift
shift/reduce conflict for ID in state 126 resolved as shift
shift/reduce conflict for ( in state 126 resolved as shift
shift/reduce conflict for STRING in state 126 resolved as shift
shift/reduce conflict for FLOAT in state 126 resolved as shift
shift/reduce conflict for INT in state 126 resolved as shift
shift/reduce conflict for FALSE in state 126 resolved as shift
shift/reduce conflict for TRUE in state 126 resolved as shift
shift/reduce conflict for WHILE in state 146 resolved as shift
shift/reduce conflict for INPUT in state 146 resolved as shift
shift/reduce conflict for OUTPUT in state 146 resolved as shift
shift/reduce conflict for IF in state 146 resolved as shift
shift/reduce conflict for RETURN in state 146 resolved as shift
shift/reduce conflict for ID in state 146 resolved as shift
shift/reduce conflict for ( in state 146 resolved as shift
shift/reduce conflict for STRING in state 146 resolved as shift
shift/reduce conflict for FLOAT in state 146 resolved as shift
shift/reduce conflict for INT in state 146 resolved as shift
shift/reduce conflict for FALSE in state 146 resolved as shift
shift/reduce conflict for TRUE in state 146 resolved as shift
shift/reduce conflict for WHILE in state 182 resolved as shift
shift/reduce conflict for INPUT in state 182 resolved as shift
shift/reduce conflict for OUTPUT in state 182 resolved as shift
shift/reduce conflict for IF in state 182 resolved as shift
shift/reduce conflict for RETURN in state 182 resolved as shift
shift/reduce conflict for ID in state 182 resolved as shift
shift/reduce conflict for ( in state 182 resolved as shift
shift/reduce conflict for STRING in state 182 resolved as shift
shift/reduce conflict for FLOAT in state 182 resolved as shift
shift/reduce conflict for INT in state 182 resolved as shift
shift/reduce conflict for FALSE in state 182 resolved as shift
shift/reduce conflict for TRUE in state 182 resolved as shift
shift/reduce conflict for WHILE in state 184 resolved as shift
shift/reduce conflict for INPUT in state 184 resolved as shift
shift/reduce conflict for OUTPUT in state 184 resolved as shift
shift/reduce conflict for IF in state 184 resolved as shift
shift/reduce conflict for RETURN in state 184 resolved as shift
shift/reduce conflict for ID in state 184 resolved as shift
shift/reduce conflict for ( in state 184 resolved as shift
shift/reduce conflict for STRING in state 184 resolved as shift
shift/reduce conflict for FLOAT in state 184 resolved as shift
shift/reduce conflict for INT in state 184 resolved as shift
shift/reduce conflict for FALSE in state 184 resolved as shift
shift/reduce conflict for TRUE in state 184 resolved as shift
shift/reduce conflict for } in state 188 resolved as shift
shift/reduce conflict for WHILE in state 188 resolved as shift
shift/reduce conflict for INPUT in state 188 resolved as shift
shift/reduce conflict for OUTPUT in state 188 resolved as shift
shift/reduce conflict for IF in state 188 resolved as shift
shift/reduce conflict for RETURN in state 188 resolved as shift
shift/reduce conflict for ID in state 188 resolved as shift
shift/reduce conflict for ( in state 188 resolved as shift
shift/reduce conflict for STRING in state 188 resolved as shift
shift/reduce conflict for FLOAT in state 188 resolved as shift
shift/reduce conflict for INT in state 188 resolved as shift
shift/reduce conflict for FALSE in state 188 resolved as shift
shift/reduce conflict for TRUE in state 188 resolved as shift
shift/reduce conflict for } in state 190 resolved as shift
shift/reduce conflict for WHILE in state 190 resolved as shift
shift/reduce conflict for INPUT in state 190 resolved as shift
shift/reduce conflict for OUTPUT in state 190 resolved as shift
shift/reduce conflict for IF in state 190 resolved as shift
shift/reduce conflict for RETURN in state 190 resolved as shift
shift/reduce conflict for ID in state 190 resolved as shift
shift/reduce conflict for ( in state 190 resolved as shift
shift/reduce conflict for STRING in state 190 resolved as shift
shift/reduce conflict for FLOAT in state 190 resolved as shift
shift/reduce conflict for INT in state 190 resolved as shift
shift/reduce conflict for FALSE in state 190 resolved as shift
shift/reduce conflict for TRUE in state 190 resolved as shift
shift/reduce conflict for WHILE in state 193 resolved as shift
shift/reduce conflict for INPUT in state 193 resolved as shift
shift/reduce conflict for OUTPUT in state 193 resolved as shift
shift/reduce conflict for IF in state 193 resolved as shift
shift/reduce conflict for RETURN in state 193 resolved as shift
shift/reduce conflict for ID in state 193 resolved as shift
shift/reduce conflict for ( in state 193 resolved as shift
shift/reduce conflict for STRING in state 193 resolved as shift
shift/reduce conflict for FLOAT in state 193 resolved as shift
shift/reduce conflict for INT in state 193 resolved as shift
shift/reduce conflict for FALSE in state 193 resolved as shift
shift/reduce conflict for TRUE in state 193 resolved as shift
shift/reduce conflict for WHILE in state 201 resolved as shift
shift/reduce conflict for INPUT in state 201 resolved as shift
shift/reduce conflict for OUTPUT in state 201 resolved as shift
shift/reduce conflict for IF in state 201 resolved as shift
shift/reduce conflict for RETURN in state 201 resolved as shift
shift/reduce conflict for ID in state 201 resolved as shift
shift/reduce conflict for ( in state 201 resolved as shift
shift/reduce conflict for STRING in state 201 resolved as shift
shift/reduce conflict for FLOAT in state 201 resolved as shift
shift/reduce conflict for INT in state 201 resolved as shift
shift/reduce conflict for FALSE in state 201 resolved as shift
shift/reduce conflict for TRUE in state 201 resolved as shift
shift/reduce conflict for } in state 202 resolved as shift
shift/reduce conflict for WHILE in state 202 resolved as shift
shift/reduce conflict for INPUT in state 202 resolved as shift
shift/reduce conflict for OUTPUT in state 202 resolved as shift
shift/reduce conflict for IF in state 202 resolved as shift
shift/reduce conflict for RETURN in state 202 resolved as shift
shift/reduce conflict for ID in state 202 resolved as shift
shift/reduce conflict for ( in state 202 resolved as shift
shift/reduce conflict for STRING in state 202 resolved as shift
shift/reduce conflict for FLOAT in state 202 resolved as shift
shift/reduce conflict for INT in state 202 resolved as shift
shift/reduce conflict for FALSE in state 202 resolved as shift
shift/reduce conflict for TRUE in state 202 resolved as shift
reduce/reduce conflict in state 49 resolved using rule maincontent -> <empty>
rejected rule (statement -> <empty>) in state 49
reduce/reduce conflict in state 54 resolved using rule maincontent -> <empty>
rejected rule (statement -> <empty>) in state 54
reduce/reduce conflict in state 69 resolved using rule arexp -> term
rejected rule (arexpextra -> <empty>) in state 69
reduce/reduce conflict in state 70 resolved using rule term -> factor
rejected rule (termx -> <empty>) in state 70
reduce/reduce conflict in state 83 resolved using rule funcontent -> <empty>
rejected rule (statement -> <empty>) in state 83
reduce/reduce conflict in state 86 resolved using rule maincontent -> <empty>
rejected rule (statement -> statement statement) in state 86
reduce/reduce conflict in state 86 resolved using rule statement -> statement statement
rejected rule (statement -> <empty>) in state 86
reduce/reduce conflict in state 86 resolved using rule maincontent -> <empty>
rejected rule (statement -> <empty>) in state 86
reduce/reduce conflict in state 126 resolved using rule funcontent -> <empty>
rejected rule (statement -> <empty>) in state 126
reduce/reduce conflict in state 146 resolved using rule funcontent -> <empty>
rejected rule (statement -> statement statement) in state 146
reduce/reduce conflict in state 146 resolved using rule statement -> statement statement
rejected rule (statement -> <empty>) in state 146
reduce/reduce conflict in state 146 resolved using rule funcontent -> <empty>
rejected rule (statement -> <empty>) in state 146
reduce/reduce conflict in state 193 resolved using rule statement -> statement statement
rejected rule (statement -> <empty>) in state 193