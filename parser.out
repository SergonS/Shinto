Grammar:

Rule 0     S' -> program
Rule 1     program -> PROG ID check_program ; gvars store_gvars functions gvars store_gvars main
Rule 2     gvars -> VAR datatype gvarids store_gtype ; gvars
Rule 3     gvars -> <empty>
Rule 4     gvarids -> ID
Rule 5     gvarids -> ID , gvarids
Rule 6     store_gvars -> <empty>
Rule 7     store_gtype -> <empty>
Rule 8     vars -> VAR datatype varids store_type ;
Rule 9     vars -> <empty>
Rule 10    varids -> ID
Rule 11    varids -> ID , varids
Rule 12    store_type -> <empty>
Rule 13    functions -> datatype FUNC ID ( params store_params ) store_funcv store_init_quad { vars store_local_vars statement } functions
Rule 14    functions -> <empty>
Rule 15    params -> ID : datatype , params
Rule 16    params -> ID : datatype
Rule 17    params -> <empty>
Rule 18    main -> FUNC MAIN ( ) { vars statement } store_main
Rule 19    statement -> expr ;
Rule 20    statement -> var_assign
Rule 21    statement -> statement statement
Rule 22    statement -> <empty>
Rule 23    var_assign -> ID store_oper = expr ;
Rule 24    expr -> arexp arexpx
Rule 25    arexpx -> <empty>
Rule 26    arexpx -> arexpxop store_op arexp
Rule 27    arexpxop -> OR
Rule 28    arexpxop -> EQEQ
Rule 29    arexpxop -> DIFF
Rule 30    arexpxop -> AND
Rule 31    arexpxop -> <
Rule 32    arexpxop -> LOETHAN
Rule 33    arexpxop -> >
Rule 34    arexpxop -> GOETHAN
Rule 35    arexp -> term arexpextra
Rule 36    arexp -> term
Rule 37    arexpextra -> <empty>
Rule 38    arexpextra -> - term arexpextra  [precedence=left, level=1]
Rule 39    arexpextra -> + term arexpextra  [precedence=left, level=1]
Rule 40    term -> factor termx
Rule 41    term -> factor
Rule 42    termx -> <empty>
Rule 43    termx -> / store_op factor termx  [precedence=left, level=2]
Rule 44    termx -> * factor termx  [precedence=left, level=2]
Rule 45    factor -> FLOAT store_const
Rule 46    factor -> element
Rule 47    factor -> ( store_op expr ) store_op
Rule 48    element -> compound store_oper
Rule 49    element -> const store_const
Rule 50    compound -> compoundx
Rule 51    compoundx -> ID
Rule 52    const -> INT
Rule 53    const -> FALSE store_const
Rule 54    const -> TRUE store_const
Rule 55    datatype -> D_BOOL
Rule 56    datatype -> D_STRING
Rule 57    datatype -> D_FLOAT
Rule 58    datatype -> D_INT
Rule 59    store_main -> <empty>
Rule 60    check_program -> <empty>
Rule 61    store_init_quad -> <empty>
Rule 62    store_funcv -> <empty>
Rule 63    store_params -> <empty>
Rule 64    store_local_vars -> <empty>
Rule 65    store_op -> <empty>
Rule 66    store_oper -> <empty>
Rule 67    store_const -> <empty>
Rule 68    verify_func -> <empty>
Rule 69    add_fstack -> <empty>
Rule 70    end_fstack -> <empty>
Rule 71    store_gosub -> <empty>
Rule 72    store_gotof -> <empty>
Rule 73    store_goto -> <empty>
Rule 74    end_if -> <empty>

Unused terminals:

    ARROW
    ELSE
    FOR
    TO
    STRING
    IF
    THEN
    BOOL
    WHILE
    COMMENT

Terminals, with rules where they appear:

(                    : 13 18 47
)                    : 13 18 47
*                    : 44
+                    : 39
,                    : 5 11 15
-                    : 38
/                    : 43
:                    : 15 16
;                    : 1 2 8 19 23
<                    : 31
=                    : 23
>                    : 33
AND                  : 30
ARROW                : 
BOOL                 : 
COMMENT              : 
DIFF                 : 29
D_BOOL               : 55
D_FLOAT              : 57
D_INT                : 58
D_STRING             : 56
ELSE                 : 
EQEQ                 : 28
FALSE                : 53
FLOAT                : 45
FOR                  : 
FUNC                 : 13 18
GOETHAN              : 34
ID                   : 1 4 5 10 11 13 15 16 23 51
IF                   : 
INT                  : 52
LOETHAN              : 32
MAIN                 : 18
OR                   : 27
PROG                 : 1
STRING               : 
THEN                 : 
TO                   : 
TRUE                 : 54
VAR                  : 2 8
WHILE                : 
error                : 
{                    : 13 18
}                    : 13 18

Nonterminals, with rules where they appear:

add_fstack           : 
arexp                : 24 26
arexpextra           : 35 38 39
arexpx               : 24
arexpxop             : 26
check_program        : 1
compound             : 48
compoundx            : 50
const                : 49
datatype             : 2 8 13 15 16
element              : 46
end_fstack           : 
end_if               : 
expr                 : 19 23 47
factor               : 40 41 43 44
functions            : 1 13
gvarids              : 2 5
gvars                : 1 1 2
main                 : 1
params               : 13 15
program              : 0
statement            : 13 18 21 21
store_const          : 45 49 53 54
store_funcv          : 13
store_gosub          : 
store_goto           : 
store_gotof          : 
store_gtype          : 2
store_gvars          : 1 1
store_init_quad      : 13
store_local_vars     : 13
store_main           : 18
store_op             : 26 43 47 47
store_oper           : 23 48
store_params         : 13
store_type           : 8
term                 : 35 36 38 39
termx                : 40 43 44
var_assign           : 20
varids               : 8 11
vars                 : 13 18
verify_func          : 


state 0

    (0) S' -> . program
    (1) program -> . PROG ID check_program ; gvars store_gvars functions gvars store_gvars main
    PROG            shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .


state 2

    (1) program -> PROG . ID check_program ; gvars store_gvars functions gvars store_gvars main
    ID              shift and go to state 3


state 3

    (1) program -> PROG ID . check_program ; gvars store_gvars functions gvars store_gvars main
    (60) check_program -> .
    ;               reduce using rule 60 (check_program -> .)

    check_program                  shift and go to state 4

state 4

    (1) program -> PROG ID check_program . ; gvars store_gvars functions gvars store_gvars main
    ;               shift and go to state 5


state 5

    (1) program -> PROG ID check_program ; . gvars store_gvars functions gvars store_gvars main
    (2) gvars -> . VAR datatype gvarids store_gtype ; gvars
    (3) gvars -> .
  ! shift/reduce conflict for VAR resolved as shift
    VAR             shift and go to state 7
    D_BOOL          reduce using rule 3 (gvars -> .)
    D_STRING        reduce using rule 3 (gvars -> .)
    D_FLOAT         reduce using rule 3 (gvars -> .)
    D_INT           reduce using rule 3 (gvars -> .)
    FUNC            reduce using rule 3 (gvars -> .)

    gvars                          shift and go to state 6

state 6

    (1) program -> PROG ID check_program ; gvars . store_gvars functions gvars store_gvars main
    (6) store_gvars -> .
    D_BOOL          reduce using rule 6 (store_gvars -> .)
    D_STRING        reduce using rule 6 (store_gvars -> .)
    D_FLOAT         reduce using rule 6 (store_gvars -> .)
    D_INT           reduce using rule 6 (store_gvars -> .)
    VAR             reduce using rule 6 (store_gvars -> .)
    FUNC            reduce using rule 6 (store_gvars -> .)

    store_gvars                    shift and go to state 8

state 7

    (2) gvars -> VAR . datatype gvarids store_gtype ; gvars
    (55) datatype -> . D_BOOL
    (56) datatype -> . D_STRING
    (57) datatype -> . D_FLOAT
    (58) datatype -> . D_INT
    D_BOOL          shift and go to state 10
    D_STRING        shift and go to state 11
    D_FLOAT         shift and go to state 12
    D_INT           shift and go to state 13

    datatype                       shift and go to state 9

state 8

    (1) program -> PROG ID check_program ; gvars store_gvars . functions gvars store_gvars main
    (13) functions -> . datatype FUNC ID ( params store_params ) store_funcv store_init_quad { vars store_local_vars statement } functions
    (14) functions -> .
    (55) datatype -> . D_BOOL
    (56) datatype -> . D_STRING
    (57) datatype -> . D_FLOAT
    (58) datatype -> . D_INT
    VAR             reduce using rule 14 (functions -> .)
    FUNC            reduce using rule 14 (functions -> .)
    D_BOOL          shift and go to state 10
    D_STRING        shift and go to state 11
    D_FLOAT         shift and go to state 12
    D_INT           shift and go to state 13

    functions                      shift and go to state 14
    datatype                       shift and go to state 15

state 9

    (2) gvars -> VAR datatype . gvarids store_gtype ; gvars
    (4) gvarids -> . ID
    (5) gvarids -> . ID , gvarids
    ID              shift and go to state 17

    gvarids                        shift and go to state 16

state 10

    (55) datatype -> D_BOOL .
    ID              reduce using rule 55 (datatype -> D_BOOL .)
    FUNC            reduce using rule 55 (datatype -> D_BOOL .)
    ,               reduce using rule 55 (datatype -> D_BOOL .)
    )               reduce using rule 55 (datatype -> D_BOOL .)


state 11

    (56) datatype -> D_STRING .
    ID              reduce using rule 56 (datatype -> D_STRING .)
    FUNC            reduce using rule 56 (datatype -> D_STRING .)
    ,               reduce using rule 56 (datatype -> D_STRING .)
    )               reduce using rule 56 (datatype -> D_STRING .)


state 12

    (57) datatype -> D_FLOAT .
    ID              reduce using rule 57 (datatype -> D_FLOAT .)
    FUNC            reduce using rule 57 (datatype -> D_FLOAT .)
    ,               reduce using rule 57 (datatype -> D_FLOAT .)
    )               reduce using rule 57 (datatype -> D_FLOAT .)


state 13

    (58) datatype -> D_INT .
    ID              reduce using rule 58 (datatype -> D_INT .)
    FUNC            reduce using rule 58 (datatype -> D_INT .)
    ,               reduce using rule 58 (datatype -> D_INT .)
    )               reduce using rule 58 (datatype -> D_INT .)


state 14

    (1) program -> PROG ID check_program ; gvars store_gvars functions . gvars store_gvars main
    (2) gvars -> . VAR datatype gvarids store_gtype ; gvars
    (3) gvars -> .
    VAR             shift and go to state 7
    FUNC            reduce using rule 3 (gvars -> .)

    gvars                          shift and go to state 18

state 15

    (13) functions -> datatype . FUNC ID ( params store_params ) store_funcv store_init_quad { vars store_local_vars statement } functions
    FUNC            shift and go to state 19


state 16

    (2) gvars -> VAR datatype gvarids . store_gtype ; gvars
    (7) store_gtype -> .
    ;               reduce using rule 7 (store_gtype -> .)

    store_gtype                    shift and go to state 20

state 17

    (4) gvarids -> ID .
    (5) gvarids -> ID . , gvarids
    ;               reduce using rule 4 (gvarids -> ID .)
    ,               shift and go to state 21


state 18

    (1) program -> PROG ID check_program ; gvars store_gvars functions gvars . store_gvars main
    (6) store_gvars -> .
    FUNC            reduce using rule 6 (store_gvars -> .)

    store_gvars                    shift and go to state 22

state 19

    (13) functions -> datatype FUNC . ID ( params store_params ) store_funcv store_init_quad { vars store_local_vars statement } functions
    ID              shift and go to state 23


state 20

    (2) gvars -> VAR datatype gvarids store_gtype . ; gvars
    ;               shift and go to state 24


state 21

    (5) gvarids -> ID , . gvarids
    (4) gvarids -> . ID
    (5) gvarids -> . ID , gvarids
    ID              shift and go to state 17

    gvarids                        shift and go to state 25

state 22

    (1) program -> PROG ID check_program ; gvars store_gvars functions gvars store_gvars . main
    (18) main -> . FUNC MAIN ( ) { vars statement } store_main
    FUNC            shift and go to state 27

    main                           shift and go to state 26

state 23

    (13) functions -> datatype FUNC ID . ( params store_params ) store_funcv store_init_quad { vars store_local_vars statement } functions
    (               shift and go to state 28


state 24

    (2) gvars -> VAR datatype gvarids store_gtype ; . gvars
    (2) gvars -> . VAR datatype gvarids store_gtype ; gvars
    (3) gvars -> .
  ! shift/reduce conflict for VAR resolved as shift
    VAR             shift and go to state 7
    D_BOOL          reduce using rule 3 (gvars -> .)
    D_STRING        reduce using rule 3 (gvars -> .)
    D_FLOAT         reduce using rule 3 (gvars -> .)
    D_INT           reduce using rule 3 (gvars -> .)
    FUNC            reduce using rule 3 (gvars -> .)

    gvars                          shift and go to state 29

state 25

    (5) gvarids -> ID , gvarids .
    ;               reduce using rule 5 (gvarids -> ID , gvarids .)


state 26

    (1) program -> PROG ID check_program ; gvars store_gvars functions gvars store_gvars main .
    $end            reduce using rule 1 (program -> PROG ID check_program ; gvars store_gvars functions gvars store_gvars main .)


state 27

    (18) main -> FUNC . MAIN ( ) { vars statement } store_main
    MAIN            shift and go to state 30


state 28

    (13) functions -> datatype FUNC ID ( . params store_params ) store_funcv store_init_quad { vars store_local_vars statement } functions
    (15) params -> . ID : datatype , params
    (16) params -> . ID : datatype
    (17) params -> .
    ID              shift and go to state 31
    )               reduce using rule 17 (params -> .)

    params                         shift and go to state 32

state 29

    (2) gvars -> VAR datatype gvarids store_gtype ; gvars .
    D_BOOL          reduce using rule 2 (gvars -> VAR datatype gvarids store_gtype ; gvars .)
    D_STRING        reduce using rule 2 (gvars -> VAR datatype gvarids store_gtype ; gvars .)
    D_FLOAT         reduce using rule 2 (gvars -> VAR datatype gvarids store_gtype ; gvars .)
    D_INT           reduce using rule 2 (gvars -> VAR datatype gvarids store_gtype ; gvars .)
    VAR             reduce using rule 2 (gvars -> VAR datatype gvarids store_gtype ; gvars .)
    FUNC            reduce using rule 2 (gvars -> VAR datatype gvarids store_gtype ; gvars .)


state 30

    (18) main -> FUNC MAIN . ( ) { vars statement } store_main
    (               shift and go to state 33


state 31

    (15) params -> ID . : datatype , params
    (16) params -> ID . : datatype
    :               shift and go to state 34


state 32

    (13) functions -> datatype FUNC ID ( params . store_params ) store_funcv store_init_quad { vars store_local_vars statement } functions
    (63) store_params -> .
    )               reduce using rule 63 (store_params -> .)

    store_params                   shift and go to state 35

state 33

    (18) main -> FUNC MAIN ( . ) { vars statement } store_main
    )               shift and go to state 36


state 34

    (15) params -> ID : . datatype , params
    (16) params -> ID : . datatype
    (55) datatype -> . D_BOOL
    (56) datatype -> . D_STRING
    (57) datatype -> . D_FLOAT
    (58) datatype -> . D_INT
    D_BOOL          shift and go to state 10
    D_STRING        shift and go to state 11
    D_FLOAT         shift and go to state 12
    D_INT           shift and go to state 13

    datatype                       shift and go to state 37

state 35

    (13) functions -> datatype FUNC ID ( params store_params . ) store_funcv store_init_quad { vars store_local_vars statement } functions
    )               shift and go to state 38


state 36

    (18) main -> FUNC MAIN ( ) . { vars statement } store_main
    {               shift and go to state 39


state 37

    (15) params -> ID : datatype . , params
    (16) params -> ID : datatype .
    ,               shift and go to state 40
    )               reduce using rule 16 (params -> ID : datatype .)


state 38

    (13) functions -> datatype FUNC ID ( params store_params ) . store_funcv store_init_quad { vars store_local_vars statement } functions
    (62) store_funcv -> .
    {               reduce using rule 62 (store_funcv -> .)

    store_funcv                    shift and go to state 41

state 39

    (18) main -> FUNC MAIN ( ) { . vars statement } store_main
    (8) vars -> . VAR datatype varids store_type ;
    (9) vars -> .
    VAR             shift and go to state 43
    ID              reduce using rule 9 (vars -> .)
    FLOAT           reduce using rule 9 (vars -> .)
    (               reduce using rule 9 (vars -> .)
    INT             reduce using rule 9 (vars -> .)
    FALSE           reduce using rule 9 (vars -> .)
    TRUE            reduce using rule 9 (vars -> .)
    }               reduce using rule 9 (vars -> .)

    vars                           shift and go to state 42

state 40

    (15) params -> ID : datatype , . params
    (15) params -> . ID : datatype , params
    (16) params -> . ID : datatype
    (17) params -> .
    ID              shift and go to state 31
    )               reduce using rule 17 (params -> .)

    params                         shift and go to state 44

state 41

    (13) functions -> datatype FUNC ID ( params store_params ) store_funcv . store_init_quad { vars store_local_vars statement } functions
    (61) store_init_quad -> .
    {               reduce using rule 61 (store_init_quad -> .)

    store_init_quad                shift and go to state 45

state 42

    (18) main -> FUNC MAIN ( ) { vars . statement } store_main
    (19) statement -> . expr ;
    (20) statement -> . var_assign
    (21) statement -> . statement statement
    (22) statement -> .
    (24) expr -> . arexp arexpx
    (23) var_assign -> . ID store_oper = expr ;
    (35) arexp -> . term arexpextra
    (36) arexp -> . term
    (40) term -> . factor termx
    (41) term -> . factor
    (45) factor -> . FLOAT store_const
    (46) factor -> . element
    (47) factor -> . ( store_op expr ) store_op
    (48) element -> . compound store_oper
    (49) element -> . const store_const
    (50) compound -> . compoundx
    (52) const -> . INT
    (53) const -> . FALSE store_const
    (54) const -> . TRUE store_const
    (51) compoundx -> . ID
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    }               reduce using rule 22 (statement -> .)
    ID              shift and go to state 51
    FLOAT           shift and go to state 54
    (               shift and go to state 46
    INT             shift and go to state 59
    FALSE           shift and go to state 60
    TRUE            shift and go to state 61

    statement                      shift and go to state 47
    expr                           shift and go to state 48
    var_assign                     shift and go to state 49
    arexp                          shift and go to state 50
    term                           shift and go to state 52
    factor                         shift and go to state 53
    element                        shift and go to state 55
    compound                       shift and go to state 56
    const                          shift and go to state 57
    compoundx                      shift and go to state 58

state 43

    (8) vars -> VAR . datatype varids store_type ;
    (55) datatype -> . D_BOOL
    (56) datatype -> . D_STRING
    (57) datatype -> . D_FLOAT
    (58) datatype -> . D_INT
    D_BOOL          shift and go to state 10
    D_STRING        shift and go to state 11
    D_FLOAT         shift and go to state 12
    D_INT           shift and go to state 13

    datatype                       shift and go to state 62

state 44

    (15) params -> ID : datatype , params .
    )               reduce using rule 15 (params -> ID : datatype , params .)


state 45

    (13) functions -> datatype FUNC ID ( params store_params ) store_funcv store_init_quad . { vars store_local_vars statement } functions
    {               shift and go to state 63


state 46

    (47) factor -> ( . store_op expr ) store_op
    (65) store_op -> .
    FLOAT           reduce using rule 65 (store_op -> .)
    (               reduce using rule 65 (store_op -> .)
    INT             reduce using rule 65 (store_op -> .)
    FALSE           reduce using rule 65 (store_op -> .)
    TRUE            reduce using rule 65 (store_op -> .)
    ID              reduce using rule 65 (store_op -> .)

    store_op                       shift and go to state 64

state 47

    (18) main -> FUNC MAIN ( ) { vars statement . } store_main
    (21) statement -> statement . statement
    (19) statement -> . expr ;
    (20) statement -> . var_assign
    (21) statement -> . statement statement
    (22) statement -> .
    (24) expr -> . arexp arexpx
    (23) var_assign -> . ID store_oper = expr ;
    (35) arexp -> . term arexpextra
    (36) arexp -> . term
    (40) term -> . factor termx
    (41) term -> . factor
    (45) factor -> . FLOAT store_const
    (46) factor -> . element
    (47) factor -> . ( store_op expr ) store_op
    (48) element -> . compound store_oper
    (49) element -> . const store_const
    (50) compound -> . compoundx
    (52) const -> . INT
    (53) const -> . FALSE store_const
    (54) const -> . TRUE store_const
    (51) compoundx -> . ID
  ! shift/reduce conflict for } resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    }               shift and go to state 66
    ID              shift and go to state 51
    FLOAT           shift and go to state 54
    (               shift and go to state 46
    INT             shift and go to state 59
    FALSE           shift and go to state 60
    TRUE            shift and go to state 61

    statement                      shift and go to state 65
    expr                           shift and go to state 48
    var_assign                     shift and go to state 49
    arexp                          shift and go to state 50
    term                           shift and go to state 52
    factor                         shift and go to state 53
    element                        shift and go to state 55
    compound                       shift and go to state 56
    const                          shift and go to state 57
    compoundx                      shift and go to state 58

state 48

    (19) statement -> expr . ;
    ;               shift and go to state 67


state 49

    (20) statement -> var_assign .
    }               reduce using rule 20 (statement -> var_assign .)
    ID              reduce using rule 20 (statement -> var_assign .)
    FLOAT           reduce using rule 20 (statement -> var_assign .)
    (               reduce using rule 20 (statement -> var_assign .)
    INT             reduce using rule 20 (statement -> var_assign .)
    FALSE           reduce using rule 20 (statement -> var_assign .)
    TRUE            reduce using rule 20 (statement -> var_assign .)


state 50

    (24) expr -> arexp . arexpx
    (25) arexpx -> .
    (26) arexpx -> . arexpxop store_op arexp
    (27) arexpxop -> . OR
    (28) arexpxop -> . EQEQ
    (29) arexpxop -> . DIFF
    (30) arexpxop -> . AND
    (31) arexpxop -> . <
    (32) arexpxop -> . LOETHAN
    (33) arexpxop -> . >
    (34) arexpxop -> . GOETHAN
    ;               reduce using rule 25 (arexpx -> .)
    )               reduce using rule 25 (arexpx -> .)
    OR              shift and go to state 70
    EQEQ            shift and go to state 71
    DIFF            shift and go to state 72
    AND             shift and go to state 73
    <               shift and go to state 74
    LOETHAN         shift and go to state 75
    >               shift and go to state 76
    GOETHAN         shift and go to state 77

    arexpx                         shift and go to state 68
    arexpxop                       shift and go to state 69

state 51

    (23) var_assign -> ID . store_oper = expr ;
    (51) compoundx -> ID .
    (66) store_oper -> .
    /               reduce using rule 51 (compoundx -> ID .)
    *               reduce using rule 51 (compoundx -> ID .)
    -               reduce using rule 51 (compoundx -> ID .)
    +               reduce using rule 51 (compoundx -> ID .)
    OR              reduce using rule 51 (compoundx -> ID .)
    EQEQ            reduce using rule 51 (compoundx -> ID .)
    DIFF            reduce using rule 51 (compoundx -> ID .)
    AND             reduce using rule 51 (compoundx -> ID .)
    <               reduce using rule 51 (compoundx -> ID .)
    LOETHAN         reduce using rule 51 (compoundx -> ID .)
    >               reduce using rule 51 (compoundx -> ID .)
    GOETHAN         reduce using rule 51 (compoundx -> ID .)
    ;               reduce using rule 51 (compoundx -> ID .)
    =               reduce using rule 66 (store_oper -> .)

    store_oper                     shift and go to state 78

state 52

    (35) arexp -> term . arexpextra
    (36) arexp -> term .
    (37) arexpextra -> .
    (38) arexpextra -> . - term arexpextra
    (39) arexpextra -> . + term arexpextra
  ! reduce/reduce conflict for OR resolved using rule 36 (arexp -> term .)
  ! reduce/reduce conflict for EQEQ resolved using rule 36 (arexp -> term .)
  ! reduce/reduce conflict for DIFF resolved using rule 36 (arexp -> term .)
  ! reduce/reduce conflict for AND resolved using rule 36 (arexp -> term .)
  ! reduce/reduce conflict for < resolved using rule 36 (arexp -> term .)
  ! reduce/reduce conflict for LOETHAN resolved using rule 36 (arexp -> term .)
  ! reduce/reduce conflict for > resolved using rule 36 (arexp -> term .)
  ! reduce/reduce conflict for GOETHAN resolved using rule 36 (arexp -> term .)
  ! reduce/reduce conflict for ; resolved using rule 36 (arexp -> term .)
  ! reduce/reduce conflict for ) resolved using rule 36 (arexp -> term .)
    OR              reduce using rule 36 (arexp -> term .)
    EQEQ            reduce using rule 36 (arexp -> term .)
    DIFF            reduce using rule 36 (arexp -> term .)
    AND             reduce using rule 36 (arexp -> term .)
    <               reduce using rule 36 (arexp -> term .)
    LOETHAN         reduce using rule 36 (arexp -> term .)
    >               reduce using rule 36 (arexp -> term .)
    GOETHAN         reduce using rule 36 (arexp -> term .)
    ;               reduce using rule 36 (arexp -> term .)
    )               reduce using rule 36 (arexp -> term .)
    -               shift and go to state 80
    +               shift and go to state 81

    arexpextra                     shift and go to state 79

state 53

    (40) term -> factor . termx
    (41) term -> factor .
    (42) termx -> .
    (43) termx -> . / store_op factor termx
    (44) termx -> . * factor termx
  ! reduce/reduce conflict for - resolved using rule 41 (term -> factor .)
  ! reduce/reduce conflict for + resolved using rule 41 (term -> factor .)
  ! reduce/reduce conflict for OR resolved using rule 41 (term -> factor .)
  ! reduce/reduce conflict for EQEQ resolved using rule 41 (term -> factor .)
  ! reduce/reduce conflict for DIFF resolved using rule 41 (term -> factor .)
  ! reduce/reduce conflict for AND resolved using rule 41 (term -> factor .)
  ! reduce/reduce conflict for < resolved using rule 41 (term -> factor .)
  ! reduce/reduce conflict for LOETHAN resolved using rule 41 (term -> factor .)
  ! reduce/reduce conflict for > resolved using rule 41 (term -> factor .)
  ! reduce/reduce conflict for GOETHAN resolved using rule 41 (term -> factor .)
  ! reduce/reduce conflict for ; resolved using rule 41 (term -> factor .)
  ! reduce/reduce conflict for ) resolved using rule 41 (term -> factor .)
    -               reduce using rule 41 (term -> factor .)
    +               reduce using rule 41 (term -> factor .)
    OR              reduce using rule 41 (term -> factor .)
    EQEQ            reduce using rule 41 (term -> factor .)
    DIFF            reduce using rule 41 (term -> factor .)
    AND             reduce using rule 41 (term -> factor .)
    <               reduce using rule 41 (term -> factor .)
    LOETHAN         reduce using rule 41 (term -> factor .)
    >               reduce using rule 41 (term -> factor .)
    GOETHAN         reduce using rule 41 (term -> factor .)
    ;               reduce using rule 41 (term -> factor .)
    )               reduce using rule 41 (term -> factor .)
    /               shift and go to state 83
    *               shift and go to state 84

    termx                          shift and go to state 82

state 54

    (45) factor -> FLOAT . store_const
    (67) store_const -> .
    /               reduce using rule 67 (store_const -> .)
    *               reduce using rule 67 (store_const -> .)
    -               reduce using rule 67 (store_const -> .)
    +               reduce using rule 67 (store_const -> .)
    OR              reduce using rule 67 (store_const -> .)
    EQEQ            reduce using rule 67 (store_const -> .)
    DIFF            reduce using rule 67 (store_const -> .)
    AND             reduce using rule 67 (store_const -> .)
    <               reduce using rule 67 (store_const -> .)
    LOETHAN         reduce using rule 67 (store_const -> .)
    >               reduce using rule 67 (store_const -> .)
    GOETHAN         reduce using rule 67 (store_const -> .)
    ;               reduce using rule 67 (store_const -> .)
    )               reduce using rule 67 (store_const -> .)

    store_const                    shift and go to state 85

state 55

    (46) factor -> element .
    /               reduce using rule 46 (factor -> element .)
    *               reduce using rule 46 (factor -> element .)
    -               reduce using rule 46 (factor -> element .)
    +               reduce using rule 46 (factor -> element .)
    OR              reduce using rule 46 (factor -> element .)
    EQEQ            reduce using rule 46 (factor -> element .)
    DIFF            reduce using rule 46 (factor -> element .)
    AND             reduce using rule 46 (factor -> element .)
    <               reduce using rule 46 (factor -> element .)
    LOETHAN         reduce using rule 46 (factor -> element .)
    >               reduce using rule 46 (factor -> element .)
    GOETHAN         reduce using rule 46 (factor -> element .)
    ;               reduce using rule 46 (factor -> element .)
    )               reduce using rule 46 (factor -> element .)


state 56

    (48) element -> compound . store_oper
    (66) store_oper -> .
    /               reduce using rule 66 (store_oper -> .)
    *               reduce using rule 66 (store_oper -> .)
    -               reduce using rule 66 (store_oper -> .)
    +               reduce using rule 66 (store_oper -> .)
    OR              reduce using rule 66 (store_oper -> .)
    EQEQ            reduce using rule 66 (store_oper -> .)
    DIFF            reduce using rule 66 (store_oper -> .)
    AND             reduce using rule 66 (store_oper -> .)
    <               reduce using rule 66 (store_oper -> .)
    LOETHAN         reduce using rule 66 (store_oper -> .)
    >               reduce using rule 66 (store_oper -> .)
    GOETHAN         reduce using rule 66 (store_oper -> .)
    ;               reduce using rule 66 (store_oper -> .)
    )               reduce using rule 66 (store_oper -> .)

    store_oper                     shift and go to state 86

state 57

    (49) element -> const . store_const
    (67) store_const -> .
    /               reduce using rule 67 (store_const -> .)
    *               reduce using rule 67 (store_const -> .)
    -               reduce using rule 67 (store_const -> .)
    +               reduce using rule 67 (store_const -> .)
    OR              reduce using rule 67 (store_const -> .)
    EQEQ            reduce using rule 67 (store_const -> .)
    DIFF            reduce using rule 67 (store_const -> .)
    AND             reduce using rule 67 (store_const -> .)
    <               reduce using rule 67 (store_const -> .)
    LOETHAN         reduce using rule 67 (store_const -> .)
    >               reduce using rule 67 (store_const -> .)
    GOETHAN         reduce using rule 67 (store_const -> .)
    ;               reduce using rule 67 (store_const -> .)
    )               reduce using rule 67 (store_const -> .)

    store_const                    shift and go to state 87

state 58

    (50) compound -> compoundx .
    /               reduce using rule 50 (compound -> compoundx .)
    *               reduce using rule 50 (compound -> compoundx .)
    -               reduce using rule 50 (compound -> compoundx .)
    +               reduce using rule 50 (compound -> compoundx .)
    OR              reduce using rule 50 (compound -> compoundx .)
    EQEQ            reduce using rule 50 (compound -> compoundx .)
    DIFF            reduce using rule 50 (compound -> compoundx .)
    AND             reduce using rule 50 (compound -> compoundx .)
    <               reduce using rule 50 (compound -> compoundx .)
    LOETHAN         reduce using rule 50 (compound -> compoundx .)
    >               reduce using rule 50 (compound -> compoundx .)
    GOETHAN         reduce using rule 50 (compound -> compoundx .)
    ;               reduce using rule 50 (compound -> compoundx .)
    )               reduce using rule 50 (compound -> compoundx .)


state 59

    (52) const -> INT .
    /               reduce using rule 52 (const -> INT .)
    *               reduce using rule 52 (const -> INT .)
    -               reduce using rule 52 (const -> INT .)
    +               reduce using rule 52 (const -> INT .)
    OR              reduce using rule 52 (const -> INT .)
    EQEQ            reduce using rule 52 (const -> INT .)
    DIFF            reduce using rule 52 (const -> INT .)
    AND             reduce using rule 52 (const -> INT .)
    <               reduce using rule 52 (const -> INT .)
    LOETHAN         reduce using rule 52 (const -> INT .)
    >               reduce using rule 52 (const -> INT .)
    GOETHAN         reduce using rule 52 (const -> INT .)
    ;               reduce using rule 52 (const -> INT .)
    )               reduce using rule 52 (const -> INT .)


state 60

    (53) const -> FALSE . store_const
    (67) store_const -> .
    /               reduce using rule 67 (store_const -> .)
    *               reduce using rule 67 (store_const -> .)
    -               reduce using rule 67 (store_const -> .)
    +               reduce using rule 67 (store_const -> .)
    OR              reduce using rule 67 (store_const -> .)
    EQEQ            reduce using rule 67 (store_const -> .)
    DIFF            reduce using rule 67 (store_const -> .)
    AND             reduce using rule 67 (store_const -> .)
    <               reduce using rule 67 (store_const -> .)
    LOETHAN         reduce using rule 67 (store_const -> .)
    >               reduce using rule 67 (store_const -> .)
    GOETHAN         reduce using rule 67 (store_const -> .)
    ;               reduce using rule 67 (store_const -> .)
    )               reduce using rule 67 (store_const -> .)

    store_const                    shift and go to state 88

state 61

    (54) const -> TRUE . store_const
    (67) store_const -> .
    /               reduce using rule 67 (store_const -> .)
    *               reduce using rule 67 (store_const -> .)
    -               reduce using rule 67 (store_const -> .)
    +               reduce using rule 67 (store_const -> .)
    OR              reduce using rule 67 (store_const -> .)
    EQEQ            reduce using rule 67 (store_const -> .)
    DIFF            reduce using rule 67 (store_const -> .)
    AND             reduce using rule 67 (store_const -> .)
    <               reduce using rule 67 (store_const -> .)
    LOETHAN         reduce using rule 67 (store_const -> .)
    >               reduce using rule 67 (store_const -> .)
    GOETHAN         reduce using rule 67 (store_const -> .)
    ;               reduce using rule 67 (store_const -> .)
    )               reduce using rule 67 (store_const -> .)

    store_const                    shift and go to state 89

state 62

    (8) vars -> VAR datatype . varids store_type ;
    (10) varids -> . ID
    (11) varids -> . ID , varids
    ID              shift and go to state 91

    varids                         shift and go to state 90

state 63

    (13) functions -> datatype FUNC ID ( params store_params ) store_funcv store_init_quad { . vars store_local_vars statement } functions
    (8) vars -> . VAR datatype varids store_type ;
    (9) vars -> .
    VAR             shift and go to state 43
    ID              reduce using rule 9 (vars -> .)
    FLOAT           reduce using rule 9 (vars -> .)
    (               reduce using rule 9 (vars -> .)
    INT             reduce using rule 9 (vars -> .)
    FALSE           reduce using rule 9 (vars -> .)
    TRUE            reduce using rule 9 (vars -> .)
    }               reduce using rule 9 (vars -> .)

    vars                           shift and go to state 92

state 64

    (47) factor -> ( store_op . expr ) store_op
    (24) expr -> . arexp arexpx
    (35) arexp -> . term arexpextra
    (36) arexp -> . term
    (40) term -> . factor termx
    (41) term -> . factor
    (45) factor -> . FLOAT store_const
    (46) factor -> . element
    (47) factor -> . ( store_op expr ) store_op
    (48) element -> . compound store_oper
    (49) element -> . const store_const
    (50) compound -> . compoundx
    (52) const -> . INT
    (53) const -> . FALSE store_const
    (54) const -> . TRUE store_const
    (51) compoundx -> . ID
    FLOAT           shift and go to state 54
    (               shift and go to state 46
    INT             shift and go to state 59
    FALSE           shift and go to state 60
    TRUE            shift and go to state 61
    ID              shift and go to state 94

    expr                           shift and go to state 93
    arexp                          shift and go to state 50
    term                           shift and go to state 52
    factor                         shift and go to state 53
    element                        shift and go to state 55
    compound                       shift and go to state 56
    const                          shift and go to state 57
    compoundx                      shift and go to state 58

state 65

    (21) statement -> statement statement .
    (21) statement -> statement . statement
    (19) statement -> . expr ;
    (20) statement -> . var_assign
    (21) statement -> . statement statement
    (22) statement -> .
    (24) expr -> . arexp arexpx
    (23) var_assign -> . ID store_oper = expr ;
    (35) arexp -> . term arexpextra
    (36) arexp -> . term
    (40) term -> . factor termx
    (41) term -> . factor
    (45) factor -> . FLOAT store_const
    (46) factor -> . element
    (47) factor -> . ( store_op expr ) store_op
    (48) element -> . compound store_oper
    (49) element -> . const store_const
    (50) compound -> . compoundx
    (52) const -> . INT
    (53) const -> . FALSE store_const
    (54) const -> . TRUE store_const
    (51) compoundx -> . ID
  ! reduce/reduce conflict for ID resolved using rule 22 (statement -> .)
  ! reduce/reduce conflict for FLOAT resolved using rule 22 (statement -> .)
  ! reduce/reduce conflict for ( resolved using rule 22 (statement -> .)
  ! reduce/reduce conflict for INT resolved using rule 22 (statement -> .)
  ! reduce/reduce conflict for FALSE resolved using rule 22 (statement -> .)
  ! reduce/reduce conflict for TRUE resolved using rule 22 (statement -> .)
  ! reduce/reduce conflict for } resolved using rule 22 (statement -> .)
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    }               reduce using rule 22 (statement -> .)
    ID              shift and go to state 51
    FLOAT           shift and go to state 54
    (               shift and go to state 46
    INT             shift and go to state 59
    FALSE           shift and go to state 60
    TRUE            shift and go to state 61

    statement                      shift and go to state 65
    expr                           shift and go to state 48
    var_assign                     shift and go to state 49
    arexp                          shift and go to state 50
    term                           shift and go to state 52
    factor                         shift and go to state 53
    element                        shift and go to state 55
    compound                       shift and go to state 56
    const                          shift and go to state 57
    compoundx                      shift and go to state 58

state 66

    (18) main -> FUNC MAIN ( ) { vars statement } . store_main
    (59) store_main -> .
    $end            reduce using rule 59 (store_main -> .)

    store_main                     shift and go to state 95

state 67

    (19) statement -> expr ; .
    }               reduce using rule 19 (statement -> expr ; .)
    ID              reduce using rule 19 (statement -> expr ; .)
    FLOAT           reduce using rule 19 (statement -> expr ; .)
    (               reduce using rule 19 (statement -> expr ; .)
    INT             reduce using rule 19 (statement -> expr ; .)
    FALSE           reduce using rule 19 (statement -> expr ; .)
    TRUE            reduce using rule 19 (statement -> expr ; .)


state 68

    (24) expr -> arexp arexpx .
    ;               reduce using rule 24 (expr -> arexp arexpx .)
    )               reduce using rule 24 (expr -> arexp arexpx .)


state 69

    (26) arexpx -> arexpxop . store_op arexp
    (65) store_op -> .
    FLOAT           reduce using rule 65 (store_op -> .)
    (               reduce using rule 65 (store_op -> .)
    INT             reduce using rule 65 (store_op -> .)
    FALSE           reduce using rule 65 (store_op -> .)
    TRUE            reduce using rule 65 (store_op -> .)
    ID              reduce using rule 65 (store_op -> .)

    store_op                       shift and go to state 96

state 70

    (27) arexpxop -> OR .
    FLOAT           reduce using rule 27 (arexpxop -> OR .)
    (               reduce using rule 27 (arexpxop -> OR .)
    INT             reduce using rule 27 (arexpxop -> OR .)
    FALSE           reduce using rule 27 (arexpxop -> OR .)
    TRUE            reduce using rule 27 (arexpxop -> OR .)
    ID              reduce using rule 27 (arexpxop -> OR .)


state 71

    (28) arexpxop -> EQEQ .
    FLOAT           reduce using rule 28 (arexpxop -> EQEQ .)
    (               reduce using rule 28 (arexpxop -> EQEQ .)
    INT             reduce using rule 28 (arexpxop -> EQEQ .)
    FALSE           reduce using rule 28 (arexpxop -> EQEQ .)
    TRUE            reduce using rule 28 (arexpxop -> EQEQ .)
    ID              reduce using rule 28 (arexpxop -> EQEQ .)


state 72

    (29) arexpxop -> DIFF .
    FLOAT           reduce using rule 29 (arexpxop -> DIFF .)
    (               reduce using rule 29 (arexpxop -> DIFF .)
    INT             reduce using rule 29 (arexpxop -> DIFF .)
    FALSE           reduce using rule 29 (arexpxop -> DIFF .)
    TRUE            reduce using rule 29 (arexpxop -> DIFF .)
    ID              reduce using rule 29 (arexpxop -> DIFF .)


state 73

    (30) arexpxop -> AND .
    FLOAT           reduce using rule 30 (arexpxop -> AND .)
    (               reduce using rule 30 (arexpxop -> AND .)
    INT             reduce using rule 30 (arexpxop -> AND .)
    FALSE           reduce using rule 30 (arexpxop -> AND .)
    TRUE            reduce using rule 30 (arexpxop -> AND .)
    ID              reduce using rule 30 (arexpxop -> AND .)


state 74

    (31) arexpxop -> < .
    FLOAT           reduce using rule 31 (arexpxop -> < .)
    (               reduce using rule 31 (arexpxop -> < .)
    INT             reduce using rule 31 (arexpxop -> < .)
    FALSE           reduce using rule 31 (arexpxop -> < .)
    TRUE            reduce using rule 31 (arexpxop -> < .)
    ID              reduce using rule 31 (arexpxop -> < .)


state 75

    (32) arexpxop -> LOETHAN .
    FLOAT           reduce using rule 32 (arexpxop -> LOETHAN .)
    (               reduce using rule 32 (arexpxop -> LOETHAN .)
    INT             reduce using rule 32 (arexpxop -> LOETHAN .)
    FALSE           reduce using rule 32 (arexpxop -> LOETHAN .)
    TRUE            reduce using rule 32 (arexpxop -> LOETHAN .)
    ID              reduce using rule 32 (arexpxop -> LOETHAN .)


state 76

    (33) arexpxop -> > .
    FLOAT           reduce using rule 33 (arexpxop -> > .)
    (               reduce using rule 33 (arexpxop -> > .)
    INT             reduce using rule 33 (arexpxop -> > .)
    FALSE           reduce using rule 33 (arexpxop -> > .)
    TRUE            reduce using rule 33 (arexpxop -> > .)
    ID              reduce using rule 33 (arexpxop -> > .)


state 77

    (34) arexpxop -> GOETHAN .
    FLOAT           reduce using rule 34 (arexpxop -> GOETHAN .)
    (               reduce using rule 34 (arexpxop -> GOETHAN .)
    INT             reduce using rule 34 (arexpxop -> GOETHAN .)
    FALSE           reduce using rule 34 (arexpxop -> GOETHAN .)
    TRUE            reduce using rule 34 (arexpxop -> GOETHAN .)
    ID              reduce using rule 34 (arexpxop -> GOETHAN .)


state 78

    (23) var_assign -> ID store_oper . = expr ;
    =               shift and go to state 97


state 79

    (35) arexp -> term arexpextra .
    OR              reduce using rule 35 (arexp -> term arexpextra .)
    EQEQ            reduce using rule 35 (arexp -> term arexpextra .)
    DIFF            reduce using rule 35 (arexp -> term arexpextra .)
    AND             reduce using rule 35 (arexp -> term arexpextra .)
    <               reduce using rule 35 (arexp -> term arexpextra .)
    LOETHAN         reduce using rule 35 (arexp -> term arexpextra .)
    >               reduce using rule 35 (arexp -> term arexpextra .)
    GOETHAN         reduce using rule 35 (arexp -> term arexpextra .)
    ;               reduce using rule 35 (arexp -> term arexpextra .)
    )               reduce using rule 35 (arexp -> term arexpextra .)


state 80

    (38) arexpextra -> - . term arexpextra
    (40) term -> . factor termx
    (41) term -> . factor
    (45) factor -> . FLOAT store_const
    (46) factor -> . element
    (47) factor -> . ( store_op expr ) store_op
    (48) element -> . compound store_oper
    (49) element -> . const store_const
    (50) compound -> . compoundx
    (52) const -> . INT
    (53) const -> . FALSE store_const
    (54) const -> . TRUE store_const
    (51) compoundx -> . ID
    FLOAT           shift and go to state 54
    (               shift and go to state 46
    INT             shift and go to state 59
    FALSE           shift and go to state 60
    TRUE            shift and go to state 61
    ID              shift and go to state 94

    term                           shift and go to state 98
    factor                         shift and go to state 53
    element                        shift and go to state 55
    compound                       shift and go to state 56
    const                          shift and go to state 57
    compoundx                      shift and go to state 58

state 81

    (39) arexpextra -> + . term arexpextra
    (40) term -> . factor termx
    (41) term -> . factor
    (45) factor -> . FLOAT store_const
    (46) factor -> . element
    (47) factor -> . ( store_op expr ) store_op
    (48) element -> . compound store_oper
    (49) element -> . const store_const
    (50) compound -> . compoundx
    (52) const -> . INT
    (53) const -> . FALSE store_const
    (54) const -> . TRUE store_const
    (51) compoundx -> . ID
    FLOAT           shift and go to state 54
    (               shift and go to state 46
    INT             shift and go to state 59
    FALSE           shift and go to state 60
    TRUE            shift and go to state 61
    ID              shift and go to state 94

    term                           shift and go to state 99
    factor                         shift and go to state 53
    element                        shift and go to state 55
    compound                       shift and go to state 56
    const                          shift and go to state 57
    compoundx                      shift and go to state 58

state 82

    (40) term -> factor termx .
    -               reduce using rule 40 (term -> factor termx .)
    +               reduce using rule 40 (term -> factor termx .)
    OR              reduce using rule 40 (term -> factor termx .)
    EQEQ            reduce using rule 40 (term -> factor termx .)
    DIFF            reduce using rule 40 (term -> factor termx .)
    AND             reduce using rule 40 (term -> factor termx .)
    <               reduce using rule 40 (term -> factor termx .)
    LOETHAN         reduce using rule 40 (term -> factor termx .)
    >               reduce using rule 40 (term -> factor termx .)
    GOETHAN         reduce using rule 40 (term -> factor termx .)
    ;               reduce using rule 40 (term -> factor termx .)
    )               reduce using rule 40 (term -> factor termx .)


state 83

    (43) termx -> / . store_op factor termx
    (65) store_op -> .
    FLOAT           reduce using rule 65 (store_op -> .)
    (               reduce using rule 65 (store_op -> .)
    INT             reduce using rule 65 (store_op -> .)
    FALSE           reduce using rule 65 (store_op -> .)
    TRUE            reduce using rule 65 (store_op -> .)
    ID              reduce using rule 65 (store_op -> .)

    store_op                       shift and go to state 100

state 84

    (44) termx -> * . factor termx
    (45) factor -> . FLOAT store_const
    (46) factor -> . element
    (47) factor -> . ( store_op expr ) store_op
    (48) element -> . compound store_oper
    (49) element -> . const store_const
    (50) compound -> . compoundx
    (52) const -> . INT
    (53) const -> . FALSE store_const
    (54) const -> . TRUE store_const
    (51) compoundx -> . ID
    FLOAT           shift and go to state 54
    (               shift and go to state 46
    INT             shift and go to state 59
    FALSE           shift and go to state 60
    TRUE            shift and go to state 61
    ID              shift and go to state 94

    factor                         shift and go to state 101
    element                        shift and go to state 55
    compound                       shift and go to state 56
    const                          shift and go to state 57
    compoundx                      shift and go to state 58

state 85

    (45) factor -> FLOAT store_const .
    /               reduce using rule 45 (factor -> FLOAT store_const .)
    *               reduce using rule 45 (factor -> FLOAT store_const .)
    -               reduce using rule 45 (factor -> FLOAT store_const .)
    +               reduce using rule 45 (factor -> FLOAT store_const .)
    OR              reduce using rule 45 (factor -> FLOAT store_const .)
    EQEQ            reduce using rule 45 (factor -> FLOAT store_const .)
    DIFF            reduce using rule 45 (factor -> FLOAT store_const .)
    AND             reduce using rule 45 (factor -> FLOAT store_const .)
    <               reduce using rule 45 (factor -> FLOAT store_const .)
    LOETHAN         reduce using rule 45 (factor -> FLOAT store_const .)
    >               reduce using rule 45 (factor -> FLOAT store_const .)
    GOETHAN         reduce using rule 45 (factor -> FLOAT store_const .)
    ;               reduce using rule 45 (factor -> FLOAT store_const .)
    )               reduce using rule 45 (factor -> FLOAT store_const .)


state 86

    (48) element -> compound store_oper .
    /               reduce using rule 48 (element -> compound store_oper .)
    *               reduce using rule 48 (element -> compound store_oper .)
    -               reduce using rule 48 (element -> compound store_oper .)
    +               reduce using rule 48 (element -> compound store_oper .)
    OR              reduce using rule 48 (element -> compound store_oper .)
    EQEQ            reduce using rule 48 (element -> compound store_oper .)
    DIFF            reduce using rule 48 (element -> compound store_oper .)
    AND             reduce using rule 48 (element -> compound store_oper .)
    <               reduce using rule 48 (element -> compound store_oper .)
    LOETHAN         reduce using rule 48 (element -> compound store_oper .)
    >               reduce using rule 48 (element -> compound store_oper .)
    GOETHAN         reduce using rule 48 (element -> compound store_oper .)
    ;               reduce using rule 48 (element -> compound store_oper .)
    )               reduce using rule 48 (element -> compound store_oper .)


state 87

    (49) element -> const store_const .
    /               reduce using rule 49 (element -> const store_const .)
    *               reduce using rule 49 (element -> const store_const .)
    -               reduce using rule 49 (element -> const store_const .)
    +               reduce using rule 49 (element -> const store_const .)
    OR              reduce using rule 49 (element -> const store_const .)
    EQEQ            reduce using rule 49 (element -> const store_const .)
    DIFF            reduce using rule 49 (element -> const store_const .)
    AND             reduce using rule 49 (element -> const store_const .)
    <               reduce using rule 49 (element -> const store_const .)
    LOETHAN         reduce using rule 49 (element -> const store_const .)
    >               reduce using rule 49 (element -> const store_const .)
    GOETHAN         reduce using rule 49 (element -> const store_const .)
    ;               reduce using rule 49 (element -> const store_const .)
    )               reduce using rule 49 (element -> const store_const .)


state 88

    (53) const -> FALSE store_const .
    /               reduce using rule 53 (const -> FALSE store_const .)
    *               reduce using rule 53 (const -> FALSE store_const .)
    -               reduce using rule 53 (const -> FALSE store_const .)
    +               reduce using rule 53 (const -> FALSE store_const .)
    OR              reduce using rule 53 (const -> FALSE store_const .)
    EQEQ            reduce using rule 53 (const -> FALSE store_const .)
    DIFF            reduce using rule 53 (const -> FALSE store_const .)
    AND             reduce using rule 53 (const -> FALSE store_const .)
    <               reduce using rule 53 (const -> FALSE store_const .)
    LOETHAN         reduce using rule 53 (const -> FALSE store_const .)
    >               reduce using rule 53 (const -> FALSE store_const .)
    GOETHAN         reduce using rule 53 (const -> FALSE store_const .)
    ;               reduce using rule 53 (const -> FALSE store_const .)
    )               reduce using rule 53 (const -> FALSE store_const .)


state 89

    (54) const -> TRUE store_const .
    /               reduce using rule 54 (const -> TRUE store_const .)
    *               reduce using rule 54 (const -> TRUE store_const .)
    -               reduce using rule 54 (const -> TRUE store_const .)
    +               reduce using rule 54 (const -> TRUE store_const .)
    OR              reduce using rule 54 (const -> TRUE store_const .)
    EQEQ            reduce using rule 54 (const -> TRUE store_const .)
    DIFF            reduce using rule 54 (const -> TRUE store_const .)
    AND             reduce using rule 54 (const -> TRUE store_const .)
    <               reduce using rule 54 (const -> TRUE store_const .)
    LOETHAN         reduce using rule 54 (const -> TRUE store_const .)
    >               reduce using rule 54 (const -> TRUE store_const .)
    GOETHAN         reduce using rule 54 (const -> TRUE store_const .)
    ;               reduce using rule 54 (const -> TRUE store_const .)
    )               reduce using rule 54 (const -> TRUE store_const .)


state 90

    (8) vars -> VAR datatype varids . store_type ;
    (12) store_type -> .
    ;               reduce using rule 12 (store_type -> .)

    store_type                     shift and go to state 102

state 91

    (10) varids -> ID .
    (11) varids -> ID . , varids
    ;               reduce using rule 10 (varids -> ID .)
    ,               shift and go to state 103


state 92

    (13) functions -> datatype FUNC ID ( params store_params ) store_funcv store_init_quad { vars . store_local_vars statement } functions
    (64) store_local_vars -> .
    ID              reduce using rule 64 (store_local_vars -> .)
    FLOAT           reduce using rule 64 (store_local_vars -> .)
    (               reduce using rule 64 (store_local_vars -> .)
    INT             reduce using rule 64 (store_local_vars -> .)
    FALSE           reduce using rule 64 (store_local_vars -> .)
    TRUE            reduce using rule 64 (store_local_vars -> .)
    }               reduce using rule 64 (store_local_vars -> .)

    store_local_vars               shift and go to state 104

state 93

    (47) factor -> ( store_op expr . ) store_op
    )               shift and go to state 105


state 94

    (51) compoundx -> ID .
    /               reduce using rule 51 (compoundx -> ID .)
    *               reduce using rule 51 (compoundx -> ID .)
    -               reduce using rule 51 (compoundx -> ID .)
    +               reduce using rule 51 (compoundx -> ID .)
    OR              reduce using rule 51 (compoundx -> ID .)
    EQEQ            reduce using rule 51 (compoundx -> ID .)
    DIFF            reduce using rule 51 (compoundx -> ID .)
    AND             reduce using rule 51 (compoundx -> ID .)
    <               reduce using rule 51 (compoundx -> ID .)
    LOETHAN         reduce using rule 51 (compoundx -> ID .)
    >               reduce using rule 51 (compoundx -> ID .)
    GOETHAN         reduce using rule 51 (compoundx -> ID .)
    )               reduce using rule 51 (compoundx -> ID .)
    ;               reduce using rule 51 (compoundx -> ID .)


state 95

    (18) main -> FUNC MAIN ( ) { vars statement } store_main .
    $end            reduce using rule 18 (main -> FUNC MAIN ( ) { vars statement } store_main .)


state 96

    (26) arexpx -> arexpxop store_op . arexp
    (35) arexp -> . term arexpextra
    (36) arexp -> . term
    (40) term -> . factor termx
    (41) term -> . factor
    (45) factor -> . FLOAT store_const
    (46) factor -> . element
    (47) factor -> . ( store_op expr ) store_op
    (48) element -> . compound store_oper
    (49) element -> . const store_const
    (50) compound -> . compoundx
    (52) const -> . INT
    (53) const -> . FALSE store_const
    (54) const -> . TRUE store_const
    (51) compoundx -> . ID
    FLOAT           shift and go to state 54
    (               shift and go to state 46
    INT             shift and go to state 59
    FALSE           shift and go to state 60
    TRUE            shift and go to state 61
    ID              shift and go to state 94

    arexp                          shift and go to state 106
    term                           shift and go to state 52
    factor                         shift and go to state 53
    element                        shift and go to state 55
    compound                       shift and go to state 56
    const                          shift and go to state 57
    compoundx                      shift and go to state 58

state 97

    (23) var_assign -> ID store_oper = . expr ;
    (24) expr -> . arexp arexpx
    (35) arexp -> . term arexpextra
    (36) arexp -> . term
    (40) term -> . factor termx
    (41) term -> . factor
    (45) factor -> . FLOAT store_const
    (46) factor -> . element
    (47) factor -> . ( store_op expr ) store_op
    (48) element -> . compound store_oper
    (49) element -> . const store_const
    (50) compound -> . compoundx
    (52) const -> . INT
    (53) const -> . FALSE store_const
    (54) const -> . TRUE store_const
    (51) compoundx -> . ID
    FLOAT           shift and go to state 54
    (               shift and go to state 46
    INT             shift and go to state 59
    FALSE           shift and go to state 60
    TRUE            shift and go to state 61
    ID              shift and go to state 94

    expr                           shift and go to state 107
    arexp                          shift and go to state 50
    term                           shift and go to state 52
    factor                         shift and go to state 53
    element                        shift and go to state 55
    compound                       shift and go to state 56
    const                          shift and go to state 57
    compoundx                      shift and go to state 58

state 98

    (38) arexpextra -> - term . arexpextra
    (37) arexpextra -> .
    (38) arexpextra -> . - term arexpextra
    (39) arexpextra -> . + term arexpextra
    OR              reduce using rule 37 (arexpextra -> .)
    EQEQ            reduce using rule 37 (arexpextra -> .)
    DIFF            reduce using rule 37 (arexpextra -> .)
    AND             reduce using rule 37 (arexpextra -> .)
    <               reduce using rule 37 (arexpextra -> .)
    LOETHAN         reduce using rule 37 (arexpextra -> .)
    >               reduce using rule 37 (arexpextra -> .)
    GOETHAN         reduce using rule 37 (arexpextra -> .)
    ;               reduce using rule 37 (arexpextra -> .)
    )               reduce using rule 37 (arexpextra -> .)
    -               shift and go to state 80
    +               shift and go to state 81

    arexpextra                     shift and go to state 108

state 99

    (39) arexpextra -> + term . arexpextra
    (37) arexpextra -> .
    (38) arexpextra -> . - term arexpextra
    (39) arexpextra -> . + term arexpextra
    OR              reduce using rule 37 (arexpextra -> .)
    EQEQ            reduce using rule 37 (arexpextra -> .)
    DIFF            reduce using rule 37 (arexpextra -> .)
    AND             reduce using rule 37 (arexpextra -> .)
    <               reduce using rule 37 (arexpextra -> .)
    LOETHAN         reduce using rule 37 (arexpextra -> .)
    >               reduce using rule 37 (arexpextra -> .)
    GOETHAN         reduce using rule 37 (arexpextra -> .)
    ;               reduce using rule 37 (arexpextra -> .)
    )               reduce using rule 37 (arexpextra -> .)
    -               shift and go to state 80
    +               shift and go to state 81

    arexpextra                     shift and go to state 109

state 100

    (43) termx -> / store_op . factor termx
    (45) factor -> . FLOAT store_const
    (46) factor -> . element
    (47) factor -> . ( store_op expr ) store_op
    (48) element -> . compound store_oper
    (49) element -> . const store_const
    (50) compound -> . compoundx
    (52) const -> . INT
    (53) const -> . FALSE store_const
    (54) const -> . TRUE store_const
    (51) compoundx -> . ID
    FLOAT           shift and go to state 54
    (               shift and go to state 46
    INT             shift and go to state 59
    FALSE           shift and go to state 60
    TRUE            shift and go to state 61
    ID              shift and go to state 94

    factor                         shift and go to state 110
    element                        shift and go to state 55
    compound                       shift and go to state 56
    const                          shift and go to state 57
    compoundx                      shift and go to state 58

state 101

    (44) termx -> * factor . termx
    (42) termx -> .
    (43) termx -> . / store_op factor termx
    (44) termx -> . * factor termx
    -               reduce using rule 42 (termx -> .)
    +               reduce using rule 42 (termx -> .)
    OR              reduce using rule 42 (termx -> .)
    EQEQ            reduce using rule 42 (termx -> .)
    DIFF            reduce using rule 42 (termx -> .)
    AND             reduce using rule 42 (termx -> .)
    <               reduce using rule 42 (termx -> .)
    LOETHAN         reduce using rule 42 (termx -> .)
    >               reduce using rule 42 (termx -> .)
    GOETHAN         reduce using rule 42 (termx -> .)
    ;               reduce using rule 42 (termx -> .)
    )               reduce using rule 42 (termx -> .)
    /               shift and go to state 83
    *               shift and go to state 84

    termx                          shift and go to state 111

state 102

    (8) vars -> VAR datatype varids store_type . ;
    ;               shift and go to state 112


state 103

    (11) varids -> ID , . varids
    (10) varids -> . ID
    (11) varids -> . ID , varids
    ID              shift and go to state 91

    varids                         shift and go to state 113

state 104

    (13) functions -> datatype FUNC ID ( params store_params ) store_funcv store_init_quad { vars store_local_vars . statement } functions
    (19) statement -> . expr ;
    (20) statement -> . var_assign
    (21) statement -> . statement statement
    (22) statement -> .
    (24) expr -> . arexp arexpx
    (23) var_assign -> . ID store_oper = expr ;
    (35) arexp -> . term arexpextra
    (36) arexp -> . term
    (40) term -> . factor termx
    (41) term -> . factor
    (45) factor -> . FLOAT store_const
    (46) factor -> . element
    (47) factor -> . ( store_op expr ) store_op
    (48) element -> . compound store_oper
    (49) element -> . const store_const
    (50) compound -> . compoundx
    (52) const -> . INT
    (53) const -> . FALSE store_const
    (54) const -> . TRUE store_const
    (51) compoundx -> . ID
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    }               reduce using rule 22 (statement -> .)
    ID              shift and go to state 51
    FLOAT           shift and go to state 54
    (               shift and go to state 46
    INT             shift and go to state 59
    FALSE           shift and go to state 60
    TRUE            shift and go to state 61

    statement                      shift and go to state 114
    expr                           shift and go to state 48
    var_assign                     shift and go to state 49
    arexp                          shift and go to state 50
    term                           shift and go to state 52
    factor                         shift and go to state 53
    element                        shift and go to state 55
    compound                       shift and go to state 56
    const                          shift and go to state 57
    compoundx                      shift and go to state 58

state 105

    (47) factor -> ( store_op expr ) . store_op
    (65) store_op -> .
    /               reduce using rule 65 (store_op -> .)
    *               reduce using rule 65 (store_op -> .)
    -               reduce using rule 65 (store_op -> .)
    +               reduce using rule 65 (store_op -> .)
    OR              reduce using rule 65 (store_op -> .)
    EQEQ            reduce using rule 65 (store_op -> .)
    DIFF            reduce using rule 65 (store_op -> .)
    AND             reduce using rule 65 (store_op -> .)
    <               reduce using rule 65 (store_op -> .)
    LOETHAN         reduce using rule 65 (store_op -> .)
    >               reduce using rule 65 (store_op -> .)
    GOETHAN         reduce using rule 65 (store_op -> .)
    ;               reduce using rule 65 (store_op -> .)
    )               reduce using rule 65 (store_op -> .)

    store_op                       shift and go to state 115

state 106

    (26) arexpx -> arexpxop store_op arexp .
    ;               reduce using rule 26 (arexpx -> arexpxop store_op arexp .)
    )               reduce using rule 26 (arexpx -> arexpxop store_op arexp .)


state 107

    (23) var_assign -> ID store_oper = expr . ;
    ;               shift and go to state 116


state 108

    (38) arexpextra -> - term arexpextra .
    OR              reduce using rule 38 (arexpextra -> - term arexpextra .)
    EQEQ            reduce using rule 38 (arexpextra -> - term arexpextra .)
    DIFF            reduce using rule 38 (arexpextra -> - term arexpextra .)
    AND             reduce using rule 38 (arexpextra -> - term arexpextra .)
    <               reduce using rule 38 (arexpextra -> - term arexpextra .)
    LOETHAN         reduce using rule 38 (arexpextra -> - term arexpextra .)
    >               reduce using rule 38 (arexpextra -> - term arexpextra .)
    GOETHAN         reduce using rule 38 (arexpextra -> - term arexpextra .)
    ;               reduce using rule 38 (arexpextra -> - term arexpextra .)
    )               reduce using rule 38 (arexpextra -> - term arexpextra .)


state 109

    (39) arexpextra -> + term arexpextra .
    OR              reduce using rule 39 (arexpextra -> + term arexpextra .)
    EQEQ            reduce using rule 39 (arexpextra -> + term arexpextra .)
    DIFF            reduce using rule 39 (arexpextra -> + term arexpextra .)
    AND             reduce using rule 39 (arexpextra -> + term arexpextra .)
    <               reduce using rule 39 (arexpextra -> + term arexpextra .)
    LOETHAN         reduce using rule 39 (arexpextra -> + term arexpextra .)
    >               reduce using rule 39 (arexpextra -> + term arexpextra .)
    GOETHAN         reduce using rule 39 (arexpextra -> + term arexpextra .)
    ;               reduce using rule 39 (arexpextra -> + term arexpextra .)
    )               reduce using rule 39 (arexpextra -> + term arexpextra .)


state 110

    (43) termx -> / store_op factor . termx
    (42) termx -> .
    (43) termx -> . / store_op factor termx
    (44) termx -> . * factor termx
    -               reduce using rule 42 (termx -> .)
    +               reduce using rule 42 (termx -> .)
    OR              reduce using rule 42 (termx -> .)
    EQEQ            reduce using rule 42 (termx -> .)
    DIFF            reduce using rule 42 (termx -> .)
    AND             reduce using rule 42 (termx -> .)
    <               reduce using rule 42 (termx -> .)
    LOETHAN         reduce using rule 42 (termx -> .)
    >               reduce using rule 42 (termx -> .)
    GOETHAN         reduce using rule 42 (termx -> .)
    ;               reduce using rule 42 (termx -> .)
    )               reduce using rule 42 (termx -> .)
    /               shift and go to state 83
    *               shift and go to state 84

    termx                          shift and go to state 117

state 111

    (44) termx -> * factor termx .
    -               reduce using rule 44 (termx -> * factor termx .)
    +               reduce using rule 44 (termx -> * factor termx .)
    OR              reduce using rule 44 (termx -> * factor termx .)
    EQEQ            reduce using rule 44 (termx -> * factor termx .)
    DIFF            reduce using rule 44 (termx -> * factor termx .)
    AND             reduce using rule 44 (termx -> * factor termx .)
    <               reduce using rule 44 (termx -> * factor termx .)
    LOETHAN         reduce using rule 44 (termx -> * factor termx .)
    >               reduce using rule 44 (termx -> * factor termx .)
    GOETHAN         reduce using rule 44 (termx -> * factor termx .)
    ;               reduce using rule 44 (termx -> * factor termx .)
    )               reduce using rule 44 (termx -> * factor termx .)


state 112

    (8) vars -> VAR datatype varids store_type ; .
    ID              reduce using rule 8 (vars -> VAR datatype varids store_type ; .)
    FLOAT           reduce using rule 8 (vars -> VAR datatype varids store_type ; .)
    (               reduce using rule 8 (vars -> VAR datatype varids store_type ; .)
    INT             reduce using rule 8 (vars -> VAR datatype varids store_type ; .)
    FALSE           reduce using rule 8 (vars -> VAR datatype varids store_type ; .)
    TRUE            reduce using rule 8 (vars -> VAR datatype varids store_type ; .)
    }               reduce using rule 8 (vars -> VAR datatype varids store_type ; .)


state 113

    (11) varids -> ID , varids .
    ;               reduce using rule 11 (varids -> ID , varids .)


state 114

    (13) functions -> datatype FUNC ID ( params store_params ) store_funcv store_init_quad { vars store_local_vars statement . } functions
    (21) statement -> statement . statement
    (19) statement -> . expr ;
    (20) statement -> . var_assign
    (21) statement -> . statement statement
    (22) statement -> .
    (24) expr -> . arexp arexpx
    (23) var_assign -> . ID store_oper = expr ;
    (35) arexp -> . term arexpextra
    (36) arexp -> . term
    (40) term -> . factor termx
    (41) term -> . factor
    (45) factor -> . FLOAT store_const
    (46) factor -> . element
    (47) factor -> . ( store_op expr ) store_op
    (48) element -> . compound store_oper
    (49) element -> . const store_const
    (50) compound -> . compoundx
    (52) const -> . INT
    (53) const -> . FALSE store_const
    (54) const -> . TRUE store_const
    (51) compoundx -> . ID
  ! shift/reduce conflict for } resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    }               shift and go to state 118
    ID              shift and go to state 51
    FLOAT           shift and go to state 54
    (               shift and go to state 46
    INT             shift and go to state 59
    FALSE           shift and go to state 60
    TRUE            shift and go to state 61

    statement                      shift and go to state 65
    expr                           shift and go to state 48
    var_assign                     shift and go to state 49
    arexp                          shift and go to state 50
    term                           shift and go to state 52
    factor                         shift and go to state 53
    element                        shift and go to state 55
    compound                       shift and go to state 56
    const                          shift and go to state 57
    compoundx                      shift and go to state 58

state 115

    (47) factor -> ( store_op expr ) store_op .
    /               reduce using rule 47 (factor -> ( store_op expr ) store_op .)
    *               reduce using rule 47 (factor -> ( store_op expr ) store_op .)
    -               reduce using rule 47 (factor -> ( store_op expr ) store_op .)
    +               reduce using rule 47 (factor -> ( store_op expr ) store_op .)
    OR              reduce using rule 47 (factor -> ( store_op expr ) store_op .)
    EQEQ            reduce using rule 47 (factor -> ( store_op expr ) store_op .)
    DIFF            reduce using rule 47 (factor -> ( store_op expr ) store_op .)
    AND             reduce using rule 47 (factor -> ( store_op expr ) store_op .)
    <               reduce using rule 47 (factor -> ( store_op expr ) store_op .)
    LOETHAN         reduce using rule 47 (factor -> ( store_op expr ) store_op .)
    >               reduce using rule 47 (factor -> ( store_op expr ) store_op .)
    GOETHAN         reduce using rule 47 (factor -> ( store_op expr ) store_op .)
    ;               reduce using rule 47 (factor -> ( store_op expr ) store_op .)
    )               reduce using rule 47 (factor -> ( store_op expr ) store_op .)


state 116

    (23) var_assign -> ID store_oper = expr ; .
    }               reduce using rule 23 (var_assign -> ID store_oper = expr ; .)
    ID              reduce using rule 23 (var_assign -> ID store_oper = expr ; .)
    FLOAT           reduce using rule 23 (var_assign -> ID store_oper = expr ; .)
    (               reduce using rule 23 (var_assign -> ID store_oper = expr ; .)
    INT             reduce using rule 23 (var_assign -> ID store_oper = expr ; .)
    FALSE           reduce using rule 23 (var_assign -> ID store_oper = expr ; .)
    TRUE            reduce using rule 23 (var_assign -> ID store_oper = expr ; .)


state 117

    (43) termx -> / store_op factor termx .
    -               reduce using rule 43 (termx -> / store_op factor termx .)
    +               reduce using rule 43 (termx -> / store_op factor termx .)
    OR              reduce using rule 43 (termx -> / store_op factor termx .)
    EQEQ            reduce using rule 43 (termx -> / store_op factor termx .)
    DIFF            reduce using rule 43 (termx -> / store_op factor termx .)
    AND             reduce using rule 43 (termx -> / store_op factor termx .)
    <               reduce using rule 43 (termx -> / store_op factor termx .)
    LOETHAN         reduce using rule 43 (termx -> / store_op factor termx .)
    >               reduce using rule 43 (termx -> / store_op factor termx .)
    GOETHAN         reduce using rule 43 (termx -> / store_op factor termx .)
    ;               reduce using rule 43 (termx -> / store_op factor termx .)
    )               reduce using rule 43 (termx -> / store_op factor termx .)


state 118

    (13) functions -> datatype FUNC ID ( params store_params ) store_funcv store_init_quad { vars store_local_vars statement } . functions
    (13) functions -> . datatype FUNC ID ( params store_params ) store_funcv store_init_quad { vars store_local_vars statement } functions
    (14) functions -> .
    (55) datatype -> . D_BOOL
    (56) datatype -> . D_STRING
    (57) datatype -> . D_FLOAT
    (58) datatype -> . D_INT
    VAR             reduce using rule 14 (functions -> .)
    FUNC            reduce using rule 14 (functions -> .)
    D_BOOL          shift and go to state 10
    D_STRING        shift and go to state 11
    D_FLOAT         shift and go to state 12
    D_INT           shift and go to state 13

    datatype                       shift and go to state 15
    functions                      shift and go to state 119

state 119

    (13) functions -> datatype FUNC ID ( params store_params ) store_funcv store_init_quad { vars store_local_vars statement } functions .
    VAR             reduce using rule 13 (functions -> datatype FUNC ID ( params store_params ) store_funcv store_init_quad { vars store_local_vars statement } functions .)
    FUNC            reduce using rule 13 (functions -> datatype FUNC ID ( params store_params ) store_funcv store_init_quad { vars store_local_vars statement } functions .)


Conflicts:

shift/reduce conflict for VAR in state 5 resolved as shift
shift/reduce conflict for VAR in state 24 resolved as shift
shift/reduce conflict for ID in state 42 resolved as shift
shift/reduce conflict for FLOAT in state 42 resolved as shift
shift/reduce conflict for ( in state 42 resolved as shift
shift/reduce conflict for INT in state 42 resolved as shift
shift/reduce conflict for FALSE in state 42 resolved as shift
shift/reduce conflict for TRUE in state 42 resolved as shift
shift/reduce conflict for } in state 47 resolved as shift
shift/reduce conflict for ID in state 47 resolved as shift
shift/reduce conflict for FLOAT in state 47 resolved as shift
shift/reduce conflict for ( in state 47 resolved as shift
shift/reduce conflict for INT in state 47 resolved as shift
shift/reduce conflict for FALSE in state 47 resolved as shift
shift/reduce conflict for TRUE in state 47 resolved as shift
shift/reduce conflict for ID in state 65 resolved as shift
shift/reduce conflict for FLOAT in state 65 resolved as shift
shift/reduce conflict for ( in state 65 resolved as shift
shift/reduce conflict for INT in state 65 resolved as shift
shift/reduce conflict for FALSE in state 65 resolved as shift
shift/reduce conflict for TRUE in state 65 resolved as shift
shift/reduce conflict for ID in state 104 resolved as shift
shift/reduce conflict for FLOAT in state 104 resolved as shift
shift/reduce conflict for ( in state 104 resolved as shift
shift/reduce conflict for INT in state 104 resolved as shift
shift/reduce conflict for FALSE in state 104 resolved as shift
shift/reduce conflict for TRUE in state 104 resolved as shift
shift/reduce conflict for } in state 114 resolved as shift
shift/reduce conflict for ID in state 114 resolved as shift
shift/reduce conflict for FLOAT in state 114 resolved as shift
shift/reduce conflict for ( in state 114 resolved as shift
shift/reduce conflict for INT in state 114 resolved as shift
shift/reduce conflict for FALSE in state 114 resolved as shift
shift/reduce conflict for TRUE in state 114 resolved as shift
reduce/reduce conflict in state 52 resolved using rule arexp -> term
rejected rule (arexpextra -> <empty>) in state 52
reduce/reduce conflict in state 53 resolved using rule term -> factor
rejected rule (termx -> <empty>) in state 53
reduce/reduce conflict in state 65 resolved using rule statement -> <empty>
rejected rule (statement -> statement statement) in state 65
Rule (statement -> statement statement) is never reduced