Grammar:

Rule 0     S' -> program
Rule 1     program -> PROG ID check_program ; gvars store_gvars functions gvars store_gvars main
Rule 2     gvars -> VAR datatype gvarids store_gtype ; gvars
Rule 3     gvars -> <empty>
Rule 4     gvarids -> ID
Rule 5     gvarids -> ID , gvarids
Rule 6     store_gvars -> <empty>
Rule 7     store_gtype -> <empty>
Rule 8     vars -> VAR datatype varids store_type ;
Rule 9     vars -> <empty>
Rule 10    varids -> ID
Rule 11    varids -> ID , varids
Rule 12    store_type -> <empty>
Rule 13    functions -> datatype FUNC ID ( params ) store_funcv store_params store_init_quad { vars store_local_vars funcontent } close_func functions
Rule 14    functions -> <empty>
Rule 15    funcontent -> <empty>
Rule 16    funcontent -> statement funcontent
Rule 17    params -> ID : datatype , params
Rule 18    params -> ID : datatype
Rule 19    params -> <empty>
Rule 20    main -> FUNC MAIN ( ) store_funcm { vars store_mainv maincontent }
Rule 21    maincontent -> <empty>
Rule 22    maincontent -> statement maincontent
Rule 23    statement -> loop unload_pv
Rule 24    statement -> input unload_pv
Rule 25    statement -> output unload_pv
Rule 26    statement -> ifelse unload_pv
Rule 27    statement -> returns unload_pv ;
Rule 28    statement -> expr ;
Rule 29    statement -> var_assign unload_pv
Rule 30    statement -> statement statement
Rule 31    statement -> <empty>
Rule 32    var_assign -> ID store_oper = expr ;
Rule 33    returns -> RETURN expr store_rquad
Rule 34    ifelse -> IF ( expr ) store_gotof { ifelsecont } store_endif
Rule 35    ifelse -> IF ( expr ) store_gotof { ifelsecont } ELSE store_goto { ifelsecont } store_endif
Rule 36    ifelsecont -> <empty>
Rule 37    ifelsecont -> statement ifelsecont
Rule 38    output -> OUTPUT ( expr outex ) ;
Rule 39    outex -> <empty>
Rule 40    outex -> , expr outex
Rule 41    input -> INPUT ( ID store_oper ) ;
Rule 42    loop -> WHILE store_jump ( expr ) store_gotof { loopcont } end_loop
Rule 43    loopcont -> <empty>
Rule 44    loopcont -> statement loopcont
Rule 45    expr -> arexp arexpx
Rule 46    arexpx -> <empty>
Rule 47    arexpx -> arexpxop arexp
Rule 48    arexpxop -> OR
Rule 49    arexpxop -> EQEQ
Rule 50    arexpxop -> DIFF
Rule 51    arexpxop -> AND
Rule 52    arexpxop -> <
Rule 53    arexpxop -> LOETHAN
Rule 54    arexpxop -> >
Rule 55    arexpxop -> GOETHAN
Rule 56    arexp -> term arexpextra
Rule 57    arexp -> term
Rule 58    arexpextra -> <empty>
Rule 59    arexpextra -> - term arexpextra  [precedence=left, level=1]
Rule 60    arexpextra -> + term arexpextra  [precedence=left, level=1]
Rule 61    term -> factor termx
Rule 62    term -> factor
Rule 63    termx -> <empty>
Rule 64    termx -> / factor termx  [precedence=left, level=2]
Rule 65    termx -> * factor termx  [precedence=left, level=2]
Rule 66    factor -> FLOAT store_const
Rule 67    factor -> element
Rule 68    factor -> ( store_op expr ) store_op
Rule 69    element -> callfunc store_oper
Rule 70    element -> compound store_oper
Rule 71    element -> const store_const
Rule 72    compound -> compoundx
Rule 73    compoundx -> ID store_oper
Rule 74    const -> INT
Rule 75    const -> FALSE store_const
Rule 76    const -> TRUE store_const
Rule 77    callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
Rule 78    callfuncpar -> <empty>
Rule 79    callfuncpar -> expr store_pquad callfuncparx
Rule 80    callfuncparx -> <empty>
Rule 81    callfuncparx -> , callfuncpar
Rule 82    datatype -> D_BOOL
Rule 83    datatype -> D_STRING
Rule 84    datatype -> D_FLOAT
Rule 85    datatype -> D_INT
Rule 86    check_program -> <empty>
Rule 87    store_init_quad -> <empty>
Rule 88    store_funcm -> <empty>
Rule 89    store_funcv -> <empty>
Rule 90    store_params -> <empty>
Rule 91    store_local_vars -> <empty>
Rule 92    store_mainv -> <empty>
Rule 93    store_op -> <empty>
Rule 94    store_oper -> <empty>
Rule 95    store_const -> <empty>
Rule 96    unload_pv -> <empty>
Rule 97    store_rquad -> <empty>
Rule 98    close_func -> <empty>
Rule 99    store_endif -> <empty>
Rule 100   store_pquad -> <empty>
Rule 101   ver_params -> <empty>
Rule 102   verify_func -> <empty>
Rule 103   add_fstack -> <empty>
Rule 104   end_fstack -> <empty>
Rule 105   store_gosub -> <empty>
Rule 106   store_gotof -> <empty>
Rule 107   store_goto -> <empty>
Rule 108   store_jump -> <empty>
Rule 109   end_loop -> <empty>

Unused terminals:

    THEN
    COMMENT
    BOOL
    TO
    FOR
    STRING
    ARROW

Terminals, with rules where they appear:

(                    : 13 20 34 35 38 41 42 68 77
)                    : 13 20 34 35 38 41 42 68 77
*                    : 65
+                    : 60
,                    : 5 11 17 40 81
-                    : 59
/                    : 64
:                    : 17 18
;                    : 1 2 8 27 28 32 38 41
<                    : 52
=                    : 32
>                    : 54
AND                  : 51
ARROW                : 
BOOL                 : 
COMMENT              : 
DIFF                 : 50
D_BOOL               : 82
D_FLOAT              : 84
D_INT                : 85
D_STRING             : 83
ELSE                 : 35
EQEQ                 : 49
FALSE                : 75
FLOAT                : 66
FOR                  : 
FUNC                 : 13 20
GOETHAN              : 55
ID                   : 1 4 5 10 11 13 17 18 32 41 73 77
IF                   : 34 35
INPUT                : 41
INT                  : 74
LOETHAN              : 53
MAIN                 : 20
OR                   : 48
OUTPUT               : 38
PROG                 : 1
RETURN               : 33
STRING               : 
THEN                 : 
TO                   : 
TRUE                 : 76
VAR                  : 2 8
WHILE                : 42
error                : 
{                    : 13 20 34 35 35 42
}                    : 13 20 34 35 35 42

Nonterminals, with rules where they appear:

add_fstack           : 77
arexp                : 45 47
arexpextra           : 56 59 60
arexpx               : 45
arexpxop             : 47
callfunc             : 69
callfuncpar          : 77 81
callfuncparx         : 79
check_program        : 1
close_func           : 13
compound             : 70
compoundx            : 72
const                : 71
datatype             : 2 8 13 17 18
element              : 67
end_fstack           : 77
end_loop             : 42
expr                 : 28 32 33 34 35 38 40 42 68 79
factor               : 61 62 64 65
funcontent           : 13 16
functions            : 1 13
gvarids              : 2 5
gvars                : 1 1 2
ifelse               : 26
ifelsecont           : 34 35 35 37
input                : 24
loop                 : 23
loopcont             : 42 44
main                 : 1
maincontent          : 20 22
outex                : 38 40
output               : 25
params               : 13 17
program              : 0
returns              : 27
statement            : 16 22 30 30 37 44
store_const          : 66 71 75 76
store_endif          : 34 35
store_funcm          : 20
store_funcv          : 13
store_gosub          : 77
store_goto           : 35
store_gotof          : 34 35 42
store_gtype          : 2
store_gvars          : 1 1
store_init_quad      : 13
store_jump           : 42
store_local_vars     : 13
store_mainv          : 20
store_op             : 68 68
store_oper           : 32 41 69 70 73
store_params         : 13
store_pquad          : 79
store_rquad          : 33
store_type           : 8
term                 : 56 57 59 60
termx                : 61 64 65
unload_pv            : 23 24 25 26 27 29
var_assign           : 29
varids               : 8 11
vars                 : 13 20
ver_params           : 77
verify_func          : 77


state 0

    (0) S' -> . program
    (1) program -> . PROG ID check_program ; gvars store_gvars functions gvars store_gvars main
    PROG            shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .


state 2

    (1) program -> PROG . ID check_program ; gvars store_gvars functions gvars store_gvars main
    ID              shift and go to state 3


state 3

    (1) program -> PROG ID . check_program ; gvars store_gvars functions gvars store_gvars main
    (86) check_program -> .
    ;               reduce using rule 86 (check_program -> .)

    check_program                  shift and go to state 4

state 4

    (1) program -> PROG ID check_program . ; gvars store_gvars functions gvars store_gvars main
    ;               shift and go to state 5


state 5

    (1) program -> PROG ID check_program ; . gvars store_gvars functions gvars store_gvars main
    (2) gvars -> . VAR datatype gvarids store_gtype ; gvars
    (3) gvars -> .
  ! shift/reduce conflict for VAR resolved as shift
    VAR             shift and go to state 7
    D_BOOL          reduce using rule 3 (gvars -> .)
    D_STRING        reduce using rule 3 (gvars -> .)
    D_FLOAT         reduce using rule 3 (gvars -> .)
    D_INT           reduce using rule 3 (gvars -> .)
    FUNC            reduce using rule 3 (gvars -> .)

    gvars                          shift and go to state 6

state 6

    (1) program -> PROG ID check_program ; gvars . store_gvars functions gvars store_gvars main
    (6) store_gvars -> .
    D_BOOL          reduce using rule 6 (store_gvars -> .)
    D_STRING        reduce using rule 6 (store_gvars -> .)
    D_FLOAT         reduce using rule 6 (store_gvars -> .)
    D_INT           reduce using rule 6 (store_gvars -> .)
    VAR             reduce using rule 6 (store_gvars -> .)
    FUNC            reduce using rule 6 (store_gvars -> .)

    store_gvars                    shift and go to state 8

state 7

    (2) gvars -> VAR . datatype gvarids store_gtype ; gvars
    (82) datatype -> . D_BOOL
    (83) datatype -> . D_STRING
    (84) datatype -> . D_FLOAT
    (85) datatype -> . D_INT
    D_BOOL          shift and go to state 10
    D_STRING        shift and go to state 11
    D_FLOAT         shift and go to state 12
    D_INT           shift and go to state 13

    datatype                       shift and go to state 9

state 8

    (1) program -> PROG ID check_program ; gvars store_gvars . functions gvars store_gvars main
    (13) functions -> . datatype FUNC ID ( params ) store_funcv store_params store_init_quad { vars store_local_vars funcontent } close_func functions
    (14) functions -> .
    (82) datatype -> . D_BOOL
    (83) datatype -> . D_STRING
    (84) datatype -> . D_FLOAT
    (85) datatype -> . D_INT
    VAR             reduce using rule 14 (functions -> .)
    FUNC            reduce using rule 14 (functions -> .)
    D_BOOL          shift and go to state 10
    D_STRING        shift and go to state 11
    D_FLOAT         shift and go to state 12
    D_INT           shift and go to state 13

    functions                      shift and go to state 14
    datatype                       shift and go to state 15

state 9

    (2) gvars -> VAR datatype . gvarids store_gtype ; gvars
    (4) gvarids -> . ID
    (5) gvarids -> . ID , gvarids
    ID              shift and go to state 17

    gvarids                        shift and go to state 16

state 10

    (82) datatype -> D_BOOL .
    ID              reduce using rule 82 (datatype -> D_BOOL .)
    FUNC            reduce using rule 82 (datatype -> D_BOOL .)
    ,               reduce using rule 82 (datatype -> D_BOOL .)
    )               reduce using rule 82 (datatype -> D_BOOL .)


state 11

    (83) datatype -> D_STRING .
    ID              reduce using rule 83 (datatype -> D_STRING .)
    FUNC            reduce using rule 83 (datatype -> D_STRING .)
    ,               reduce using rule 83 (datatype -> D_STRING .)
    )               reduce using rule 83 (datatype -> D_STRING .)


state 12

    (84) datatype -> D_FLOAT .
    ID              reduce using rule 84 (datatype -> D_FLOAT .)
    FUNC            reduce using rule 84 (datatype -> D_FLOAT .)
    ,               reduce using rule 84 (datatype -> D_FLOAT .)
    )               reduce using rule 84 (datatype -> D_FLOAT .)


state 13

    (85) datatype -> D_INT .
    ID              reduce using rule 85 (datatype -> D_INT .)
    FUNC            reduce using rule 85 (datatype -> D_INT .)
    ,               reduce using rule 85 (datatype -> D_INT .)
    )               reduce using rule 85 (datatype -> D_INT .)


state 14

    (1) program -> PROG ID check_program ; gvars store_gvars functions . gvars store_gvars main
    (2) gvars -> . VAR datatype gvarids store_gtype ; gvars
    (3) gvars -> .
    VAR             shift and go to state 7
    FUNC            reduce using rule 3 (gvars -> .)

    gvars                          shift and go to state 18

state 15

    (13) functions -> datatype . FUNC ID ( params ) store_funcv store_params store_init_quad { vars store_local_vars funcontent } close_func functions
    FUNC            shift and go to state 19


state 16

    (2) gvars -> VAR datatype gvarids . store_gtype ; gvars
    (7) store_gtype -> .
    ;               reduce using rule 7 (store_gtype -> .)

    store_gtype                    shift and go to state 20

state 17

    (4) gvarids -> ID .
    (5) gvarids -> ID . , gvarids
    ;               reduce using rule 4 (gvarids -> ID .)
    ,               shift and go to state 21


state 18

    (1) program -> PROG ID check_program ; gvars store_gvars functions gvars . store_gvars main
    (6) store_gvars -> .
    FUNC            reduce using rule 6 (store_gvars -> .)

    store_gvars                    shift and go to state 22

state 19

    (13) functions -> datatype FUNC . ID ( params ) store_funcv store_params store_init_quad { vars store_local_vars funcontent } close_func functions
    ID              shift and go to state 23


state 20

    (2) gvars -> VAR datatype gvarids store_gtype . ; gvars
    ;               shift and go to state 24


state 21

    (5) gvarids -> ID , . gvarids
    (4) gvarids -> . ID
    (5) gvarids -> . ID , gvarids
    ID              shift and go to state 17

    gvarids                        shift and go to state 25

state 22

    (1) program -> PROG ID check_program ; gvars store_gvars functions gvars store_gvars . main
    (20) main -> . FUNC MAIN ( ) store_funcm { vars store_mainv maincontent }
    FUNC            shift and go to state 27

    main                           shift and go to state 26

state 23

    (13) functions -> datatype FUNC ID . ( params ) store_funcv store_params store_init_quad { vars store_local_vars funcontent } close_func functions
    (               shift and go to state 28


state 24

    (2) gvars -> VAR datatype gvarids store_gtype ; . gvars
    (2) gvars -> . VAR datatype gvarids store_gtype ; gvars
    (3) gvars -> .
  ! shift/reduce conflict for VAR resolved as shift
    VAR             shift and go to state 7
    D_BOOL          reduce using rule 3 (gvars -> .)
    D_STRING        reduce using rule 3 (gvars -> .)
    D_FLOAT         reduce using rule 3 (gvars -> .)
    D_INT           reduce using rule 3 (gvars -> .)
    FUNC            reduce using rule 3 (gvars -> .)

    gvars                          shift and go to state 29

state 25

    (5) gvarids -> ID , gvarids .
    ;               reduce using rule 5 (gvarids -> ID , gvarids .)


state 26

    (1) program -> PROG ID check_program ; gvars store_gvars functions gvars store_gvars main .
    $end            reduce using rule 1 (program -> PROG ID check_program ; gvars store_gvars functions gvars store_gvars main .)


state 27

    (20) main -> FUNC . MAIN ( ) store_funcm { vars store_mainv maincontent }
    MAIN            shift and go to state 30


state 28

    (13) functions -> datatype FUNC ID ( . params ) store_funcv store_params store_init_quad { vars store_local_vars funcontent } close_func functions
    (17) params -> . ID : datatype , params
    (18) params -> . ID : datatype
    (19) params -> .
    ID              shift and go to state 31
    )               reduce using rule 19 (params -> .)

    params                         shift and go to state 32

state 29

    (2) gvars -> VAR datatype gvarids store_gtype ; gvars .
    D_BOOL          reduce using rule 2 (gvars -> VAR datatype gvarids store_gtype ; gvars .)
    D_STRING        reduce using rule 2 (gvars -> VAR datatype gvarids store_gtype ; gvars .)
    D_FLOAT         reduce using rule 2 (gvars -> VAR datatype gvarids store_gtype ; gvars .)
    D_INT           reduce using rule 2 (gvars -> VAR datatype gvarids store_gtype ; gvars .)
    VAR             reduce using rule 2 (gvars -> VAR datatype gvarids store_gtype ; gvars .)
    FUNC            reduce using rule 2 (gvars -> VAR datatype gvarids store_gtype ; gvars .)


state 30

    (20) main -> FUNC MAIN . ( ) store_funcm { vars store_mainv maincontent }
    (               shift and go to state 33


state 31

    (17) params -> ID . : datatype , params
    (18) params -> ID . : datatype
    :               shift and go to state 34


state 32

    (13) functions -> datatype FUNC ID ( params . ) store_funcv store_params store_init_quad { vars store_local_vars funcontent } close_func functions
    )               shift and go to state 35


state 33

    (20) main -> FUNC MAIN ( . ) store_funcm { vars store_mainv maincontent }
    )               shift and go to state 36


state 34

    (17) params -> ID : . datatype , params
    (18) params -> ID : . datatype
    (82) datatype -> . D_BOOL
    (83) datatype -> . D_STRING
    (84) datatype -> . D_FLOAT
    (85) datatype -> . D_INT
    D_BOOL          shift and go to state 10
    D_STRING        shift and go to state 11
    D_FLOAT         shift and go to state 12
    D_INT           shift and go to state 13

    datatype                       shift and go to state 37

state 35

    (13) functions -> datatype FUNC ID ( params ) . store_funcv store_params store_init_quad { vars store_local_vars funcontent } close_func functions
    (89) store_funcv -> .
    {               reduce using rule 89 (store_funcv -> .)

    store_funcv                    shift and go to state 38

state 36

    (20) main -> FUNC MAIN ( ) . store_funcm { vars store_mainv maincontent }
    (88) store_funcm -> .
    {               reduce using rule 88 (store_funcm -> .)

    store_funcm                    shift and go to state 39

state 37

    (17) params -> ID : datatype . , params
    (18) params -> ID : datatype .
    ,               shift and go to state 40
    )               reduce using rule 18 (params -> ID : datatype .)


state 38

    (13) functions -> datatype FUNC ID ( params ) store_funcv . store_params store_init_quad { vars store_local_vars funcontent } close_func functions
    (90) store_params -> .
    {               reduce using rule 90 (store_params -> .)

    store_params                   shift and go to state 41

state 39

    (20) main -> FUNC MAIN ( ) store_funcm . { vars store_mainv maincontent }
    {               shift and go to state 42


state 40

    (17) params -> ID : datatype , . params
    (17) params -> . ID : datatype , params
    (18) params -> . ID : datatype
    (19) params -> .
    ID              shift and go to state 31
    )               reduce using rule 19 (params -> .)

    params                         shift and go to state 43

state 41

    (13) functions -> datatype FUNC ID ( params ) store_funcv store_params . store_init_quad { vars store_local_vars funcontent } close_func functions
    (87) store_init_quad -> .
    {               reduce using rule 87 (store_init_quad -> .)

    store_init_quad                shift and go to state 44

state 42

    (20) main -> FUNC MAIN ( ) store_funcm { . vars store_mainv maincontent }
    (8) vars -> . VAR datatype varids store_type ;
    (9) vars -> .
    VAR             shift and go to state 46
    WHILE           reduce using rule 9 (vars -> .)
    INPUT           reduce using rule 9 (vars -> .)
    OUTPUT          reduce using rule 9 (vars -> .)
    IF              reduce using rule 9 (vars -> .)
    RETURN          reduce using rule 9 (vars -> .)
    ID              reduce using rule 9 (vars -> .)
    FLOAT           reduce using rule 9 (vars -> .)
    (               reduce using rule 9 (vars -> .)
    INT             reduce using rule 9 (vars -> .)
    FALSE           reduce using rule 9 (vars -> .)
    TRUE            reduce using rule 9 (vars -> .)
    }               reduce using rule 9 (vars -> .)

    vars                           shift and go to state 45

state 43

    (17) params -> ID : datatype , params .
    )               reduce using rule 17 (params -> ID : datatype , params .)


state 44

    (13) functions -> datatype FUNC ID ( params ) store_funcv store_params store_init_quad . { vars store_local_vars funcontent } close_func functions
    {               shift and go to state 47


state 45

    (20) main -> FUNC MAIN ( ) store_funcm { vars . store_mainv maincontent }
    (92) store_mainv -> .
    WHILE           reduce using rule 92 (store_mainv -> .)
    INPUT           reduce using rule 92 (store_mainv -> .)
    OUTPUT          reduce using rule 92 (store_mainv -> .)
    IF              reduce using rule 92 (store_mainv -> .)
    RETURN          reduce using rule 92 (store_mainv -> .)
    ID              reduce using rule 92 (store_mainv -> .)
    FLOAT           reduce using rule 92 (store_mainv -> .)
    (               reduce using rule 92 (store_mainv -> .)
    INT             reduce using rule 92 (store_mainv -> .)
    FALSE           reduce using rule 92 (store_mainv -> .)
    TRUE            reduce using rule 92 (store_mainv -> .)
    }               reduce using rule 92 (store_mainv -> .)

    store_mainv                    shift and go to state 48

state 46

    (8) vars -> VAR . datatype varids store_type ;
    (82) datatype -> . D_BOOL
    (83) datatype -> . D_STRING
    (84) datatype -> . D_FLOAT
    (85) datatype -> . D_INT
    D_BOOL          shift and go to state 10
    D_STRING        shift and go to state 11
    D_FLOAT         shift and go to state 12
    D_INT           shift and go to state 13

    datatype                       shift and go to state 49

state 47

    (13) functions -> datatype FUNC ID ( params ) store_funcv store_params store_init_quad { . vars store_local_vars funcontent } close_func functions
    (8) vars -> . VAR datatype varids store_type ;
    (9) vars -> .
    VAR             shift and go to state 46
    WHILE           reduce using rule 9 (vars -> .)
    INPUT           reduce using rule 9 (vars -> .)
    OUTPUT          reduce using rule 9 (vars -> .)
    IF              reduce using rule 9 (vars -> .)
    RETURN          reduce using rule 9 (vars -> .)
    ID              reduce using rule 9 (vars -> .)
    FLOAT           reduce using rule 9 (vars -> .)
    (               reduce using rule 9 (vars -> .)
    INT             reduce using rule 9 (vars -> .)
    FALSE           reduce using rule 9 (vars -> .)
    TRUE            reduce using rule 9 (vars -> .)
    }               reduce using rule 9 (vars -> .)

    vars                           shift and go to state 50

state 48

    (20) main -> FUNC MAIN ( ) store_funcm { vars store_mainv . maincontent }
    (21) maincontent -> .
    (22) maincontent -> . statement maincontent
    (23) statement -> . loop unload_pv
    (24) statement -> . input unload_pv
    (25) statement -> . output unload_pv
    (26) statement -> . ifelse unload_pv
    (27) statement -> . returns unload_pv ;
    (28) statement -> . expr ;
    (29) statement -> . var_assign unload_pv
    (30) statement -> . statement statement
    (31) statement -> .
    (42) loop -> . WHILE store_jump ( expr ) store_gotof { loopcont } end_loop
    (41) input -> . INPUT ( ID store_oper ) ;
    (38) output -> . OUTPUT ( expr outex ) ;
    (34) ifelse -> . IF ( expr ) store_gotof { ifelsecont } store_endif
    (35) ifelse -> . IF ( expr ) store_gotof { ifelsecont } ELSE store_goto { ifelsecont } store_endif
    (33) returns -> . RETURN expr store_rquad
    (45) expr -> . arexp arexpx
    (32) var_assign -> . ID store_oper = expr ;
    (56) arexp -> . term arexpextra
    (57) arexp -> . term
    (61) term -> . factor termx
    (62) term -> . factor
    (66) factor -> . FLOAT store_const
    (67) factor -> . element
    (68) factor -> . ( store_op expr ) store_op
    (69) element -> . callfunc store_oper
    (70) element -> . compound store_oper
    (71) element -> . const store_const
    (77) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (72) compound -> . compoundx
    (74) const -> . INT
    (75) const -> . FALSE store_const
    (76) const -> . TRUE store_const
    (73) compoundx -> . ID store_oper
  ! reduce/reduce conflict for } resolved using rule 21 (maincontent -> .)
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for OUTPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    }               reduce using rule 21 (maincontent -> .)
    WHILE           shift and go to state 61
    INPUT           shift and go to state 62
    OUTPUT          shift and go to state 64
    IF              shift and go to state 65
    RETURN          shift and go to state 66
    ID              shift and go to state 63
    FLOAT           shift and go to state 70
    (               shift and go to state 51
    INT             shift and go to state 76
    FALSE           shift and go to state 77
    TRUE            shift and go to state 78

    maincontent                    shift and go to state 52
    statement                      shift and go to state 53
    loop                           shift and go to state 54
    input                          shift and go to state 55
    output                         shift and go to state 56
    ifelse                         shift and go to state 57
    returns                        shift and go to state 58
    expr                           shift and go to state 59
    var_assign                     shift and go to state 60
    arexp                          shift and go to state 67
    term                           shift and go to state 68
    factor                         shift and go to state 69
    element                        shift and go to state 71
    callfunc                       shift and go to state 72
    compound                       shift and go to state 73
    const                          shift and go to state 74
    compoundx                      shift and go to state 75

state 49

    (8) vars -> VAR datatype . varids store_type ;
    (10) varids -> . ID
    (11) varids -> . ID , varids
    ID              shift and go to state 80

    varids                         shift and go to state 79

state 50

    (13) functions -> datatype FUNC ID ( params ) store_funcv store_params store_init_quad { vars . store_local_vars funcontent } close_func functions
    (91) store_local_vars -> .
    WHILE           reduce using rule 91 (store_local_vars -> .)
    INPUT           reduce using rule 91 (store_local_vars -> .)
    OUTPUT          reduce using rule 91 (store_local_vars -> .)
    IF              reduce using rule 91 (store_local_vars -> .)
    RETURN          reduce using rule 91 (store_local_vars -> .)
    ID              reduce using rule 91 (store_local_vars -> .)
    FLOAT           reduce using rule 91 (store_local_vars -> .)
    (               reduce using rule 91 (store_local_vars -> .)
    INT             reduce using rule 91 (store_local_vars -> .)
    FALSE           reduce using rule 91 (store_local_vars -> .)
    TRUE            reduce using rule 91 (store_local_vars -> .)
    }               reduce using rule 91 (store_local_vars -> .)

    store_local_vars               shift and go to state 81

state 51

    (68) factor -> ( . store_op expr ) store_op
    (93) store_op -> .
    FLOAT           reduce using rule 93 (store_op -> .)
    (               reduce using rule 93 (store_op -> .)
    ID              reduce using rule 93 (store_op -> .)
    INT             reduce using rule 93 (store_op -> .)
    FALSE           reduce using rule 93 (store_op -> .)
    TRUE            reduce using rule 93 (store_op -> .)

    store_op                       shift and go to state 82

state 52

    (20) main -> FUNC MAIN ( ) store_funcm { vars store_mainv maincontent . }
    }               shift and go to state 83


state 53

    (22) maincontent -> statement . maincontent
    (30) statement -> statement . statement
    (21) maincontent -> .
    (22) maincontent -> . statement maincontent
    (23) statement -> . loop unload_pv
    (24) statement -> . input unload_pv
    (25) statement -> . output unload_pv
    (26) statement -> . ifelse unload_pv
    (27) statement -> . returns unload_pv ;
    (28) statement -> . expr ;
    (29) statement -> . var_assign unload_pv
    (30) statement -> . statement statement
    (31) statement -> .
    (42) loop -> . WHILE store_jump ( expr ) store_gotof { loopcont } end_loop
    (41) input -> . INPUT ( ID store_oper ) ;
    (38) output -> . OUTPUT ( expr outex ) ;
    (34) ifelse -> . IF ( expr ) store_gotof { ifelsecont } store_endif
    (35) ifelse -> . IF ( expr ) store_gotof { ifelsecont } ELSE store_goto { ifelsecont } store_endif
    (33) returns -> . RETURN expr store_rquad
    (45) expr -> . arexp arexpx
    (32) var_assign -> . ID store_oper = expr ;
    (56) arexp -> . term arexpextra
    (57) arexp -> . term
    (61) term -> . factor termx
    (62) term -> . factor
    (66) factor -> . FLOAT store_const
    (67) factor -> . element
    (68) factor -> . ( store_op expr ) store_op
    (69) element -> . callfunc store_oper
    (70) element -> . compound store_oper
    (71) element -> . const store_const
    (77) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (72) compound -> . compoundx
    (74) const -> . INT
    (75) const -> . FALSE store_const
    (76) const -> . TRUE store_const
    (73) compoundx -> . ID store_oper
  ! reduce/reduce conflict for } resolved using rule 21 (maincontent -> .)
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for OUTPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    }               reduce using rule 21 (maincontent -> .)
    WHILE           shift and go to state 61
    INPUT           shift and go to state 62
    OUTPUT          shift and go to state 64
    IF              shift and go to state 65
    RETURN          shift and go to state 66
    ID              shift and go to state 63
    FLOAT           shift and go to state 70
    (               shift and go to state 51
    INT             shift and go to state 76
    FALSE           shift and go to state 77
    TRUE            shift and go to state 78

    statement                      shift and go to state 84
    maincontent                    shift and go to state 85
    loop                           shift and go to state 54
    input                          shift and go to state 55
    output                         shift and go to state 56
    ifelse                         shift and go to state 57
    returns                        shift and go to state 58
    expr                           shift and go to state 59
    var_assign                     shift and go to state 60
    arexp                          shift and go to state 67
    term                           shift and go to state 68
    factor                         shift and go to state 69
    element                        shift and go to state 71
    callfunc                       shift and go to state 72
    compound                       shift and go to state 73
    const                          shift and go to state 74
    compoundx                      shift and go to state 75

state 54

    (23) statement -> loop . unload_pv
    (96) unload_pv -> .
    WHILE           reduce using rule 96 (unload_pv -> .)
    INPUT           reduce using rule 96 (unload_pv -> .)
    OUTPUT          reduce using rule 96 (unload_pv -> .)
    IF              reduce using rule 96 (unload_pv -> .)
    RETURN          reduce using rule 96 (unload_pv -> .)
    ID              reduce using rule 96 (unload_pv -> .)
    FLOAT           reduce using rule 96 (unload_pv -> .)
    (               reduce using rule 96 (unload_pv -> .)
    INT             reduce using rule 96 (unload_pv -> .)
    FALSE           reduce using rule 96 (unload_pv -> .)
    TRUE            reduce using rule 96 (unload_pv -> .)
    }               reduce using rule 96 (unload_pv -> .)

    unload_pv                      shift and go to state 86

state 55

    (24) statement -> input . unload_pv
    (96) unload_pv -> .
    WHILE           reduce using rule 96 (unload_pv -> .)
    INPUT           reduce using rule 96 (unload_pv -> .)
    OUTPUT          reduce using rule 96 (unload_pv -> .)
    IF              reduce using rule 96 (unload_pv -> .)
    RETURN          reduce using rule 96 (unload_pv -> .)
    ID              reduce using rule 96 (unload_pv -> .)
    FLOAT           reduce using rule 96 (unload_pv -> .)
    (               reduce using rule 96 (unload_pv -> .)
    INT             reduce using rule 96 (unload_pv -> .)
    FALSE           reduce using rule 96 (unload_pv -> .)
    TRUE            reduce using rule 96 (unload_pv -> .)
    }               reduce using rule 96 (unload_pv -> .)

    unload_pv                      shift and go to state 87

state 56

    (25) statement -> output . unload_pv
    (96) unload_pv -> .
    WHILE           reduce using rule 96 (unload_pv -> .)
    INPUT           reduce using rule 96 (unload_pv -> .)
    OUTPUT          reduce using rule 96 (unload_pv -> .)
    IF              reduce using rule 96 (unload_pv -> .)
    RETURN          reduce using rule 96 (unload_pv -> .)
    ID              reduce using rule 96 (unload_pv -> .)
    FLOAT           reduce using rule 96 (unload_pv -> .)
    (               reduce using rule 96 (unload_pv -> .)
    INT             reduce using rule 96 (unload_pv -> .)
    FALSE           reduce using rule 96 (unload_pv -> .)
    TRUE            reduce using rule 96 (unload_pv -> .)
    }               reduce using rule 96 (unload_pv -> .)

    unload_pv                      shift and go to state 88

state 57

    (26) statement -> ifelse . unload_pv
    (96) unload_pv -> .
    WHILE           reduce using rule 96 (unload_pv -> .)
    INPUT           reduce using rule 96 (unload_pv -> .)
    OUTPUT          reduce using rule 96 (unload_pv -> .)
    IF              reduce using rule 96 (unload_pv -> .)
    RETURN          reduce using rule 96 (unload_pv -> .)
    ID              reduce using rule 96 (unload_pv -> .)
    FLOAT           reduce using rule 96 (unload_pv -> .)
    (               reduce using rule 96 (unload_pv -> .)
    INT             reduce using rule 96 (unload_pv -> .)
    FALSE           reduce using rule 96 (unload_pv -> .)
    TRUE            reduce using rule 96 (unload_pv -> .)
    }               reduce using rule 96 (unload_pv -> .)

    unload_pv                      shift and go to state 89

state 58

    (27) statement -> returns . unload_pv ;
    (96) unload_pv -> .
    ;               reduce using rule 96 (unload_pv -> .)

    unload_pv                      shift and go to state 90

state 59

    (28) statement -> expr . ;
    ;               shift and go to state 91


state 60

    (29) statement -> var_assign . unload_pv
    (96) unload_pv -> .
    WHILE           reduce using rule 96 (unload_pv -> .)
    INPUT           reduce using rule 96 (unload_pv -> .)
    OUTPUT          reduce using rule 96 (unload_pv -> .)
    IF              reduce using rule 96 (unload_pv -> .)
    RETURN          reduce using rule 96 (unload_pv -> .)
    ID              reduce using rule 96 (unload_pv -> .)
    FLOAT           reduce using rule 96 (unload_pv -> .)
    (               reduce using rule 96 (unload_pv -> .)
    INT             reduce using rule 96 (unload_pv -> .)
    FALSE           reduce using rule 96 (unload_pv -> .)
    TRUE            reduce using rule 96 (unload_pv -> .)
    }               reduce using rule 96 (unload_pv -> .)

    unload_pv                      shift and go to state 92

state 61

    (42) loop -> WHILE . store_jump ( expr ) store_gotof { loopcont } end_loop
    (108) store_jump -> .
    (               reduce using rule 108 (store_jump -> .)

    store_jump                     shift and go to state 93

state 62

    (41) input -> INPUT . ( ID store_oper ) ;
    (               shift and go to state 94


state 63

    (32) var_assign -> ID . store_oper = expr ;
    (77) callfunc -> ID . verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (73) compoundx -> ID . store_oper
    (94) store_oper -> .
    (102) verify_func -> .
    =               reduce using rule 94 (store_oper -> .)
    /               reduce using rule 94 (store_oper -> .)
    *               reduce using rule 94 (store_oper -> .)
    -               reduce using rule 94 (store_oper -> .)
    +               reduce using rule 94 (store_oper -> .)
    OR              reduce using rule 94 (store_oper -> .)
    EQEQ            reduce using rule 94 (store_oper -> .)
    DIFF            reduce using rule 94 (store_oper -> .)
    AND             reduce using rule 94 (store_oper -> .)
    <               reduce using rule 94 (store_oper -> .)
    LOETHAN         reduce using rule 94 (store_oper -> .)
    >               reduce using rule 94 (store_oper -> .)
    GOETHAN         reduce using rule 94 (store_oper -> .)
    ;               reduce using rule 94 (store_oper -> .)
    (               reduce using rule 102 (verify_func -> .)

    store_oper                     shift and go to state 95
    verify_func                    shift and go to state 96

state 64

    (38) output -> OUTPUT . ( expr outex ) ;
    (               shift and go to state 97


state 65

    (34) ifelse -> IF . ( expr ) store_gotof { ifelsecont } store_endif
    (35) ifelse -> IF . ( expr ) store_gotof { ifelsecont } ELSE store_goto { ifelsecont } store_endif
    (               shift and go to state 98


state 66

    (33) returns -> RETURN . expr store_rquad
    (45) expr -> . arexp arexpx
    (56) arexp -> . term arexpextra
    (57) arexp -> . term
    (61) term -> . factor termx
    (62) term -> . factor
    (66) factor -> . FLOAT store_const
    (67) factor -> . element
    (68) factor -> . ( store_op expr ) store_op
    (69) element -> . callfunc store_oper
    (70) element -> . compound store_oper
    (71) element -> . const store_const
    (77) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (72) compound -> . compoundx
    (74) const -> . INT
    (75) const -> . FALSE store_const
    (76) const -> . TRUE store_const
    (73) compoundx -> . ID store_oper
    FLOAT           shift and go to state 70
    (               shift and go to state 51
    ID              shift and go to state 100
    INT             shift and go to state 76
    FALSE           shift and go to state 77
    TRUE            shift and go to state 78

    expr                           shift and go to state 99
    arexp                          shift and go to state 67
    term                           shift and go to state 68
    factor                         shift and go to state 69
    element                        shift and go to state 71
    callfunc                       shift and go to state 72
    compound                       shift and go to state 73
    const                          shift and go to state 74
    compoundx                      shift and go to state 75

state 67

    (45) expr -> arexp . arexpx
    (46) arexpx -> .
    (47) arexpx -> . arexpxop arexp
    (48) arexpxop -> . OR
    (49) arexpxop -> . EQEQ
    (50) arexpxop -> . DIFF
    (51) arexpxop -> . AND
    (52) arexpxop -> . <
    (53) arexpxop -> . LOETHAN
    (54) arexpxop -> . >
    (55) arexpxop -> . GOETHAN
    ;               reduce using rule 46 (arexpx -> .)
    )               reduce using rule 46 (arexpx -> .)
    ,               reduce using rule 46 (arexpx -> .)
    OR              shift and go to state 103
    EQEQ            shift and go to state 104
    DIFF            shift and go to state 105
    AND             shift and go to state 106
    <               shift and go to state 107
    LOETHAN         shift and go to state 108
    >               shift and go to state 109
    GOETHAN         shift and go to state 110

    arexpx                         shift and go to state 101
    arexpxop                       shift and go to state 102

state 68

    (56) arexp -> term . arexpextra
    (57) arexp -> term .
    (58) arexpextra -> .
    (59) arexpextra -> . - term arexpextra
    (60) arexpextra -> . + term arexpextra
  ! reduce/reduce conflict for OR resolved using rule 57 (arexp -> term .)
  ! reduce/reduce conflict for EQEQ resolved using rule 57 (arexp -> term .)
  ! reduce/reduce conflict for DIFF resolved using rule 57 (arexp -> term .)
  ! reduce/reduce conflict for AND resolved using rule 57 (arexp -> term .)
  ! reduce/reduce conflict for < resolved using rule 57 (arexp -> term .)
  ! reduce/reduce conflict for LOETHAN resolved using rule 57 (arexp -> term .)
  ! reduce/reduce conflict for > resolved using rule 57 (arexp -> term .)
  ! reduce/reduce conflict for GOETHAN resolved using rule 57 (arexp -> term .)
  ! reduce/reduce conflict for ; resolved using rule 57 (arexp -> term .)
  ! reduce/reduce conflict for ) resolved using rule 57 (arexp -> term .)
  ! reduce/reduce conflict for , resolved using rule 57 (arexp -> term .)
    OR              reduce using rule 57 (arexp -> term .)
    EQEQ            reduce using rule 57 (arexp -> term .)
    DIFF            reduce using rule 57 (arexp -> term .)
    AND             reduce using rule 57 (arexp -> term .)
    <               reduce using rule 57 (arexp -> term .)
    LOETHAN         reduce using rule 57 (arexp -> term .)
    >               reduce using rule 57 (arexp -> term .)
    GOETHAN         reduce using rule 57 (arexp -> term .)
    ;               reduce using rule 57 (arexp -> term .)
    )               reduce using rule 57 (arexp -> term .)
    ,               reduce using rule 57 (arexp -> term .)
    -               shift and go to state 112
    +               shift and go to state 113

    arexpextra                     shift and go to state 111

state 69

    (61) term -> factor . termx
    (62) term -> factor .
    (63) termx -> .
    (64) termx -> . / factor termx
    (65) termx -> . * factor termx
  ! reduce/reduce conflict for - resolved using rule 62 (term -> factor .)
  ! reduce/reduce conflict for + resolved using rule 62 (term -> factor .)
  ! reduce/reduce conflict for OR resolved using rule 62 (term -> factor .)
  ! reduce/reduce conflict for EQEQ resolved using rule 62 (term -> factor .)
  ! reduce/reduce conflict for DIFF resolved using rule 62 (term -> factor .)
  ! reduce/reduce conflict for AND resolved using rule 62 (term -> factor .)
  ! reduce/reduce conflict for < resolved using rule 62 (term -> factor .)
  ! reduce/reduce conflict for LOETHAN resolved using rule 62 (term -> factor .)
  ! reduce/reduce conflict for > resolved using rule 62 (term -> factor .)
  ! reduce/reduce conflict for GOETHAN resolved using rule 62 (term -> factor .)
  ! reduce/reduce conflict for ; resolved using rule 62 (term -> factor .)
  ! reduce/reduce conflict for ) resolved using rule 62 (term -> factor .)
  ! reduce/reduce conflict for , resolved using rule 62 (term -> factor .)
    -               reduce using rule 62 (term -> factor .)
    +               reduce using rule 62 (term -> factor .)
    OR              reduce using rule 62 (term -> factor .)
    EQEQ            reduce using rule 62 (term -> factor .)
    DIFF            reduce using rule 62 (term -> factor .)
    AND             reduce using rule 62 (term -> factor .)
    <               reduce using rule 62 (term -> factor .)
    LOETHAN         reduce using rule 62 (term -> factor .)
    >               reduce using rule 62 (term -> factor .)
    GOETHAN         reduce using rule 62 (term -> factor .)
    ;               reduce using rule 62 (term -> factor .)
    )               reduce using rule 62 (term -> factor .)
    ,               reduce using rule 62 (term -> factor .)
    /               shift and go to state 115
    *               shift and go to state 116

    termx                          shift and go to state 114

state 70

    (66) factor -> FLOAT . store_const
    (95) store_const -> .
    /               reduce using rule 95 (store_const -> .)
    *               reduce using rule 95 (store_const -> .)
    -               reduce using rule 95 (store_const -> .)
    +               reduce using rule 95 (store_const -> .)
    OR              reduce using rule 95 (store_const -> .)
    EQEQ            reduce using rule 95 (store_const -> .)
    DIFF            reduce using rule 95 (store_const -> .)
    AND             reduce using rule 95 (store_const -> .)
    <               reduce using rule 95 (store_const -> .)
    LOETHAN         reduce using rule 95 (store_const -> .)
    >               reduce using rule 95 (store_const -> .)
    GOETHAN         reduce using rule 95 (store_const -> .)
    ;               reduce using rule 95 (store_const -> .)
    )               reduce using rule 95 (store_const -> .)
    ,               reduce using rule 95 (store_const -> .)

    store_const                    shift and go to state 117

state 71

    (67) factor -> element .
    /               reduce using rule 67 (factor -> element .)
    *               reduce using rule 67 (factor -> element .)
    -               reduce using rule 67 (factor -> element .)
    +               reduce using rule 67 (factor -> element .)
    OR              reduce using rule 67 (factor -> element .)
    EQEQ            reduce using rule 67 (factor -> element .)
    DIFF            reduce using rule 67 (factor -> element .)
    AND             reduce using rule 67 (factor -> element .)
    <               reduce using rule 67 (factor -> element .)
    LOETHAN         reduce using rule 67 (factor -> element .)
    >               reduce using rule 67 (factor -> element .)
    GOETHAN         reduce using rule 67 (factor -> element .)
    ;               reduce using rule 67 (factor -> element .)
    )               reduce using rule 67 (factor -> element .)
    ,               reduce using rule 67 (factor -> element .)


state 72

    (69) element -> callfunc . store_oper
    (94) store_oper -> .
    /               reduce using rule 94 (store_oper -> .)
    *               reduce using rule 94 (store_oper -> .)
    -               reduce using rule 94 (store_oper -> .)
    +               reduce using rule 94 (store_oper -> .)
    OR              reduce using rule 94 (store_oper -> .)
    EQEQ            reduce using rule 94 (store_oper -> .)
    DIFF            reduce using rule 94 (store_oper -> .)
    AND             reduce using rule 94 (store_oper -> .)
    <               reduce using rule 94 (store_oper -> .)
    LOETHAN         reduce using rule 94 (store_oper -> .)
    >               reduce using rule 94 (store_oper -> .)
    GOETHAN         reduce using rule 94 (store_oper -> .)
    ;               reduce using rule 94 (store_oper -> .)
    )               reduce using rule 94 (store_oper -> .)
    ,               reduce using rule 94 (store_oper -> .)

    store_oper                     shift and go to state 118

state 73

    (70) element -> compound . store_oper
    (94) store_oper -> .
    /               reduce using rule 94 (store_oper -> .)
    *               reduce using rule 94 (store_oper -> .)
    -               reduce using rule 94 (store_oper -> .)
    +               reduce using rule 94 (store_oper -> .)
    OR              reduce using rule 94 (store_oper -> .)
    EQEQ            reduce using rule 94 (store_oper -> .)
    DIFF            reduce using rule 94 (store_oper -> .)
    AND             reduce using rule 94 (store_oper -> .)
    <               reduce using rule 94 (store_oper -> .)
    LOETHAN         reduce using rule 94 (store_oper -> .)
    >               reduce using rule 94 (store_oper -> .)
    GOETHAN         reduce using rule 94 (store_oper -> .)
    ;               reduce using rule 94 (store_oper -> .)
    )               reduce using rule 94 (store_oper -> .)
    ,               reduce using rule 94 (store_oper -> .)

    store_oper                     shift and go to state 119

state 74

    (71) element -> const . store_const
    (95) store_const -> .
    /               reduce using rule 95 (store_const -> .)
    *               reduce using rule 95 (store_const -> .)
    -               reduce using rule 95 (store_const -> .)
    +               reduce using rule 95 (store_const -> .)
    OR              reduce using rule 95 (store_const -> .)
    EQEQ            reduce using rule 95 (store_const -> .)
    DIFF            reduce using rule 95 (store_const -> .)
    AND             reduce using rule 95 (store_const -> .)
    <               reduce using rule 95 (store_const -> .)
    LOETHAN         reduce using rule 95 (store_const -> .)
    >               reduce using rule 95 (store_const -> .)
    GOETHAN         reduce using rule 95 (store_const -> .)
    ;               reduce using rule 95 (store_const -> .)
    )               reduce using rule 95 (store_const -> .)
    ,               reduce using rule 95 (store_const -> .)

    store_const                    shift and go to state 120

state 75

    (72) compound -> compoundx .
    /               reduce using rule 72 (compound -> compoundx .)
    *               reduce using rule 72 (compound -> compoundx .)
    -               reduce using rule 72 (compound -> compoundx .)
    +               reduce using rule 72 (compound -> compoundx .)
    OR              reduce using rule 72 (compound -> compoundx .)
    EQEQ            reduce using rule 72 (compound -> compoundx .)
    DIFF            reduce using rule 72 (compound -> compoundx .)
    AND             reduce using rule 72 (compound -> compoundx .)
    <               reduce using rule 72 (compound -> compoundx .)
    LOETHAN         reduce using rule 72 (compound -> compoundx .)
    >               reduce using rule 72 (compound -> compoundx .)
    GOETHAN         reduce using rule 72 (compound -> compoundx .)
    ;               reduce using rule 72 (compound -> compoundx .)
    )               reduce using rule 72 (compound -> compoundx .)
    ,               reduce using rule 72 (compound -> compoundx .)


state 76

    (74) const -> INT .
    /               reduce using rule 74 (const -> INT .)
    *               reduce using rule 74 (const -> INT .)
    -               reduce using rule 74 (const -> INT .)
    +               reduce using rule 74 (const -> INT .)
    OR              reduce using rule 74 (const -> INT .)
    EQEQ            reduce using rule 74 (const -> INT .)
    DIFF            reduce using rule 74 (const -> INT .)
    AND             reduce using rule 74 (const -> INT .)
    <               reduce using rule 74 (const -> INT .)
    LOETHAN         reduce using rule 74 (const -> INT .)
    >               reduce using rule 74 (const -> INT .)
    GOETHAN         reduce using rule 74 (const -> INT .)
    ;               reduce using rule 74 (const -> INT .)
    )               reduce using rule 74 (const -> INT .)
    ,               reduce using rule 74 (const -> INT .)


state 77

    (75) const -> FALSE . store_const
    (95) store_const -> .
    /               reduce using rule 95 (store_const -> .)
    *               reduce using rule 95 (store_const -> .)
    -               reduce using rule 95 (store_const -> .)
    +               reduce using rule 95 (store_const -> .)
    OR              reduce using rule 95 (store_const -> .)
    EQEQ            reduce using rule 95 (store_const -> .)
    DIFF            reduce using rule 95 (store_const -> .)
    AND             reduce using rule 95 (store_const -> .)
    <               reduce using rule 95 (store_const -> .)
    LOETHAN         reduce using rule 95 (store_const -> .)
    >               reduce using rule 95 (store_const -> .)
    GOETHAN         reduce using rule 95 (store_const -> .)
    ;               reduce using rule 95 (store_const -> .)
    )               reduce using rule 95 (store_const -> .)
    ,               reduce using rule 95 (store_const -> .)

    store_const                    shift and go to state 121

state 78

    (76) const -> TRUE . store_const
    (95) store_const -> .
    /               reduce using rule 95 (store_const -> .)
    *               reduce using rule 95 (store_const -> .)
    -               reduce using rule 95 (store_const -> .)
    +               reduce using rule 95 (store_const -> .)
    OR              reduce using rule 95 (store_const -> .)
    EQEQ            reduce using rule 95 (store_const -> .)
    DIFF            reduce using rule 95 (store_const -> .)
    AND             reduce using rule 95 (store_const -> .)
    <               reduce using rule 95 (store_const -> .)
    LOETHAN         reduce using rule 95 (store_const -> .)
    >               reduce using rule 95 (store_const -> .)
    GOETHAN         reduce using rule 95 (store_const -> .)
    ;               reduce using rule 95 (store_const -> .)
    )               reduce using rule 95 (store_const -> .)
    ,               reduce using rule 95 (store_const -> .)

    store_const                    shift and go to state 122

state 79

    (8) vars -> VAR datatype varids . store_type ;
    (12) store_type -> .
    ;               reduce using rule 12 (store_type -> .)

    store_type                     shift and go to state 123

state 80

    (10) varids -> ID .
    (11) varids -> ID . , varids
    ;               reduce using rule 10 (varids -> ID .)
    ,               shift and go to state 124


state 81

    (13) functions -> datatype FUNC ID ( params ) store_funcv store_params store_init_quad { vars store_local_vars . funcontent } close_func functions
    (15) funcontent -> .
    (16) funcontent -> . statement funcontent
    (23) statement -> . loop unload_pv
    (24) statement -> . input unload_pv
    (25) statement -> . output unload_pv
    (26) statement -> . ifelse unload_pv
    (27) statement -> . returns unload_pv ;
    (28) statement -> . expr ;
    (29) statement -> . var_assign unload_pv
    (30) statement -> . statement statement
    (31) statement -> .
    (42) loop -> . WHILE store_jump ( expr ) store_gotof { loopcont } end_loop
    (41) input -> . INPUT ( ID store_oper ) ;
    (38) output -> . OUTPUT ( expr outex ) ;
    (34) ifelse -> . IF ( expr ) store_gotof { ifelsecont } store_endif
    (35) ifelse -> . IF ( expr ) store_gotof { ifelsecont } ELSE store_goto { ifelsecont } store_endif
    (33) returns -> . RETURN expr store_rquad
    (45) expr -> . arexp arexpx
    (32) var_assign -> . ID store_oper = expr ;
    (56) arexp -> . term arexpextra
    (57) arexp -> . term
    (61) term -> . factor termx
    (62) term -> . factor
    (66) factor -> . FLOAT store_const
    (67) factor -> . element
    (68) factor -> . ( store_op expr ) store_op
    (69) element -> . callfunc store_oper
    (70) element -> . compound store_oper
    (71) element -> . const store_const
    (77) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (72) compound -> . compoundx
    (74) const -> . INT
    (75) const -> . FALSE store_const
    (76) const -> . TRUE store_const
    (73) compoundx -> . ID store_oper
  ! reduce/reduce conflict for } resolved using rule 15 (funcontent -> .)
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for OUTPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    }               reduce using rule 15 (funcontent -> .)
    WHILE           shift and go to state 61
    INPUT           shift and go to state 62
    OUTPUT          shift and go to state 64
    IF              shift and go to state 65
    RETURN          shift and go to state 66
    ID              shift and go to state 63
    FLOAT           shift and go to state 70
    (               shift and go to state 51
    INT             shift and go to state 76
    FALSE           shift and go to state 77
    TRUE            shift and go to state 78

    funcontent                     shift and go to state 125
    statement                      shift and go to state 126
    loop                           shift and go to state 54
    input                          shift and go to state 55
    output                         shift and go to state 56
    ifelse                         shift and go to state 57
    returns                        shift and go to state 58
    expr                           shift and go to state 59
    var_assign                     shift and go to state 60
    arexp                          shift and go to state 67
    term                           shift and go to state 68
    factor                         shift and go to state 69
    element                        shift and go to state 71
    callfunc                       shift and go to state 72
    compound                       shift and go to state 73
    const                          shift and go to state 74
    compoundx                      shift and go to state 75

state 82

    (68) factor -> ( store_op . expr ) store_op
    (45) expr -> . arexp arexpx
    (56) arexp -> . term arexpextra
    (57) arexp -> . term
    (61) term -> . factor termx
    (62) term -> . factor
    (66) factor -> . FLOAT store_const
    (67) factor -> . element
    (68) factor -> . ( store_op expr ) store_op
    (69) element -> . callfunc store_oper
    (70) element -> . compound store_oper
    (71) element -> . const store_const
    (77) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (72) compound -> . compoundx
    (74) const -> . INT
    (75) const -> . FALSE store_const
    (76) const -> . TRUE store_const
    (73) compoundx -> . ID store_oper
    FLOAT           shift and go to state 70
    (               shift and go to state 51
    ID              shift and go to state 100
    INT             shift and go to state 76
    FALSE           shift and go to state 77
    TRUE            shift and go to state 78

    expr                           shift and go to state 127
    arexp                          shift and go to state 67
    term                           shift and go to state 68
    factor                         shift and go to state 69
    element                        shift and go to state 71
    callfunc                       shift and go to state 72
    compound                       shift and go to state 73
    const                          shift and go to state 74
    compoundx                      shift and go to state 75

state 83

    (20) main -> FUNC MAIN ( ) store_funcm { vars store_mainv maincontent } .
    $end            reduce using rule 20 (main -> FUNC MAIN ( ) store_funcm { vars store_mainv maincontent } .)


state 84

    (30) statement -> statement statement .
    (22) maincontent -> statement . maincontent
    (30) statement -> statement . statement
    (21) maincontent -> .
    (22) maincontent -> . statement maincontent
    (23) statement -> . loop unload_pv
    (24) statement -> . input unload_pv
    (25) statement -> . output unload_pv
    (26) statement -> . ifelse unload_pv
    (27) statement -> . returns unload_pv ;
    (28) statement -> . expr ;
    (29) statement -> . var_assign unload_pv
    (30) statement -> . statement statement
    (31) statement -> .
    (42) loop -> . WHILE store_jump ( expr ) store_gotof { loopcont } end_loop
    (41) input -> . INPUT ( ID store_oper ) ;
    (38) output -> . OUTPUT ( expr outex ) ;
    (34) ifelse -> . IF ( expr ) store_gotof { ifelsecont } store_endif
    (35) ifelse -> . IF ( expr ) store_gotof { ifelsecont } ELSE store_goto { ifelsecont } store_endif
    (33) returns -> . RETURN expr store_rquad
    (45) expr -> . arexp arexpx
    (32) var_assign -> . ID store_oper = expr ;
    (56) arexp -> . term arexpextra
    (57) arexp -> . term
    (61) term -> . factor termx
    (62) term -> . factor
    (66) factor -> . FLOAT store_const
    (67) factor -> . element
    (68) factor -> . ( store_op expr ) store_op
    (69) element -> . callfunc store_oper
    (70) element -> . compound store_oper
    (71) element -> . const store_const
    (77) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (72) compound -> . compoundx
    (74) const -> . INT
    (75) const -> . FALSE store_const
    (76) const -> . TRUE store_const
    (73) compoundx -> . ID store_oper
  ! reduce/reduce conflict for } resolved using rule 21 (maincontent -> .)
  ! reduce/reduce conflict for WHILE resolved using rule 31 (statement -> .)
  ! reduce/reduce conflict for INPUT resolved using rule 31 (statement -> .)
  ! reduce/reduce conflict for OUTPUT resolved using rule 31 (statement -> .)
  ! reduce/reduce conflict for IF resolved using rule 31 (statement -> .)
  ! reduce/reduce conflict for RETURN resolved using rule 31 (statement -> .)
  ! reduce/reduce conflict for ID resolved using rule 31 (statement -> .)
  ! reduce/reduce conflict for FLOAT resolved using rule 31 (statement -> .)
  ! reduce/reduce conflict for ( resolved using rule 31 (statement -> .)
  ! reduce/reduce conflict for INT resolved using rule 31 (statement -> .)
  ! reduce/reduce conflict for FALSE resolved using rule 31 (statement -> .)
  ! reduce/reduce conflict for TRUE resolved using rule 31 (statement -> .)
  ! reduce/reduce conflict for } resolved using rule 21 (maincontent -> .)
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for OUTPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    }               reduce using rule 21 (maincontent -> .)
    WHILE           shift and go to state 61
    INPUT           shift and go to state 62
    OUTPUT          shift and go to state 64
    IF              shift and go to state 65
    RETURN          shift and go to state 66
    ID              shift and go to state 63
    FLOAT           shift and go to state 70
    (               shift and go to state 51
    INT             shift and go to state 76
    FALSE           shift and go to state 77
    TRUE            shift and go to state 78

    statement                      shift and go to state 84
    maincontent                    shift and go to state 85
    loop                           shift and go to state 54
    input                          shift and go to state 55
    output                         shift and go to state 56
    ifelse                         shift and go to state 57
    returns                        shift and go to state 58
    expr                           shift and go to state 59
    var_assign                     shift and go to state 60
    arexp                          shift and go to state 67
    term                           shift and go to state 68
    factor                         shift and go to state 69
    element                        shift and go to state 71
    callfunc                       shift and go to state 72
    compound                       shift and go to state 73
    const                          shift and go to state 74
    compoundx                      shift and go to state 75

state 85

    (22) maincontent -> statement maincontent .
    }               reduce using rule 22 (maincontent -> statement maincontent .)


state 86

    (23) statement -> loop unload_pv .
    WHILE           reduce using rule 23 (statement -> loop unload_pv .)
    INPUT           reduce using rule 23 (statement -> loop unload_pv .)
    OUTPUT          reduce using rule 23 (statement -> loop unload_pv .)
    IF              reduce using rule 23 (statement -> loop unload_pv .)
    RETURN          reduce using rule 23 (statement -> loop unload_pv .)
    ID              reduce using rule 23 (statement -> loop unload_pv .)
    FLOAT           reduce using rule 23 (statement -> loop unload_pv .)
    (               reduce using rule 23 (statement -> loop unload_pv .)
    INT             reduce using rule 23 (statement -> loop unload_pv .)
    FALSE           reduce using rule 23 (statement -> loop unload_pv .)
    TRUE            reduce using rule 23 (statement -> loop unload_pv .)
    }               reduce using rule 23 (statement -> loop unload_pv .)


state 87

    (24) statement -> input unload_pv .
    WHILE           reduce using rule 24 (statement -> input unload_pv .)
    INPUT           reduce using rule 24 (statement -> input unload_pv .)
    OUTPUT          reduce using rule 24 (statement -> input unload_pv .)
    IF              reduce using rule 24 (statement -> input unload_pv .)
    RETURN          reduce using rule 24 (statement -> input unload_pv .)
    ID              reduce using rule 24 (statement -> input unload_pv .)
    FLOAT           reduce using rule 24 (statement -> input unload_pv .)
    (               reduce using rule 24 (statement -> input unload_pv .)
    INT             reduce using rule 24 (statement -> input unload_pv .)
    FALSE           reduce using rule 24 (statement -> input unload_pv .)
    TRUE            reduce using rule 24 (statement -> input unload_pv .)
    }               reduce using rule 24 (statement -> input unload_pv .)


state 88

    (25) statement -> output unload_pv .
    WHILE           reduce using rule 25 (statement -> output unload_pv .)
    INPUT           reduce using rule 25 (statement -> output unload_pv .)
    OUTPUT          reduce using rule 25 (statement -> output unload_pv .)
    IF              reduce using rule 25 (statement -> output unload_pv .)
    RETURN          reduce using rule 25 (statement -> output unload_pv .)
    ID              reduce using rule 25 (statement -> output unload_pv .)
    FLOAT           reduce using rule 25 (statement -> output unload_pv .)
    (               reduce using rule 25 (statement -> output unload_pv .)
    INT             reduce using rule 25 (statement -> output unload_pv .)
    FALSE           reduce using rule 25 (statement -> output unload_pv .)
    TRUE            reduce using rule 25 (statement -> output unload_pv .)
    }               reduce using rule 25 (statement -> output unload_pv .)


state 89

    (26) statement -> ifelse unload_pv .
    WHILE           reduce using rule 26 (statement -> ifelse unload_pv .)
    INPUT           reduce using rule 26 (statement -> ifelse unload_pv .)
    OUTPUT          reduce using rule 26 (statement -> ifelse unload_pv .)
    IF              reduce using rule 26 (statement -> ifelse unload_pv .)
    RETURN          reduce using rule 26 (statement -> ifelse unload_pv .)
    ID              reduce using rule 26 (statement -> ifelse unload_pv .)
    FLOAT           reduce using rule 26 (statement -> ifelse unload_pv .)
    (               reduce using rule 26 (statement -> ifelse unload_pv .)
    INT             reduce using rule 26 (statement -> ifelse unload_pv .)
    FALSE           reduce using rule 26 (statement -> ifelse unload_pv .)
    TRUE            reduce using rule 26 (statement -> ifelse unload_pv .)
    }               reduce using rule 26 (statement -> ifelse unload_pv .)


state 90

    (27) statement -> returns unload_pv . ;
    ;               shift and go to state 128


state 91

    (28) statement -> expr ; .
    WHILE           reduce using rule 28 (statement -> expr ; .)
    INPUT           reduce using rule 28 (statement -> expr ; .)
    OUTPUT          reduce using rule 28 (statement -> expr ; .)
    IF              reduce using rule 28 (statement -> expr ; .)
    RETURN          reduce using rule 28 (statement -> expr ; .)
    ID              reduce using rule 28 (statement -> expr ; .)
    FLOAT           reduce using rule 28 (statement -> expr ; .)
    (               reduce using rule 28 (statement -> expr ; .)
    INT             reduce using rule 28 (statement -> expr ; .)
    FALSE           reduce using rule 28 (statement -> expr ; .)
    TRUE            reduce using rule 28 (statement -> expr ; .)
    }               reduce using rule 28 (statement -> expr ; .)


state 92

    (29) statement -> var_assign unload_pv .
    WHILE           reduce using rule 29 (statement -> var_assign unload_pv .)
    INPUT           reduce using rule 29 (statement -> var_assign unload_pv .)
    OUTPUT          reduce using rule 29 (statement -> var_assign unload_pv .)
    IF              reduce using rule 29 (statement -> var_assign unload_pv .)
    RETURN          reduce using rule 29 (statement -> var_assign unload_pv .)
    ID              reduce using rule 29 (statement -> var_assign unload_pv .)
    FLOAT           reduce using rule 29 (statement -> var_assign unload_pv .)
    (               reduce using rule 29 (statement -> var_assign unload_pv .)
    INT             reduce using rule 29 (statement -> var_assign unload_pv .)
    FALSE           reduce using rule 29 (statement -> var_assign unload_pv .)
    TRUE            reduce using rule 29 (statement -> var_assign unload_pv .)
    }               reduce using rule 29 (statement -> var_assign unload_pv .)


state 93

    (42) loop -> WHILE store_jump . ( expr ) store_gotof { loopcont } end_loop
    (               shift and go to state 129


state 94

    (41) input -> INPUT ( . ID store_oper ) ;
    ID              shift and go to state 130


state 95

    (32) var_assign -> ID store_oper . = expr ;
    (73) compoundx -> ID store_oper .
    =               shift and go to state 131
    /               reduce using rule 73 (compoundx -> ID store_oper .)
    *               reduce using rule 73 (compoundx -> ID store_oper .)
    -               reduce using rule 73 (compoundx -> ID store_oper .)
    +               reduce using rule 73 (compoundx -> ID store_oper .)
    OR              reduce using rule 73 (compoundx -> ID store_oper .)
    EQEQ            reduce using rule 73 (compoundx -> ID store_oper .)
    DIFF            reduce using rule 73 (compoundx -> ID store_oper .)
    AND             reduce using rule 73 (compoundx -> ID store_oper .)
    <               reduce using rule 73 (compoundx -> ID store_oper .)
    LOETHAN         reduce using rule 73 (compoundx -> ID store_oper .)
    >               reduce using rule 73 (compoundx -> ID store_oper .)
    GOETHAN         reduce using rule 73 (compoundx -> ID store_oper .)
    ;               reduce using rule 73 (compoundx -> ID store_oper .)


state 96

    (77) callfunc -> ID verify_func . add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (103) add_fstack -> .
    (               reduce using rule 103 (add_fstack -> .)

    add_fstack                     shift and go to state 132

state 97

    (38) output -> OUTPUT ( . expr outex ) ;
    (45) expr -> . arexp arexpx
    (56) arexp -> . term arexpextra
    (57) arexp -> . term
    (61) term -> . factor termx
    (62) term -> . factor
    (66) factor -> . FLOAT store_const
    (67) factor -> . element
    (68) factor -> . ( store_op expr ) store_op
    (69) element -> . callfunc store_oper
    (70) element -> . compound store_oper
    (71) element -> . const store_const
    (77) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (72) compound -> . compoundx
    (74) const -> . INT
    (75) const -> . FALSE store_const
    (76) const -> . TRUE store_const
    (73) compoundx -> . ID store_oper
    FLOAT           shift and go to state 70
    (               shift and go to state 51
    ID              shift and go to state 100
    INT             shift and go to state 76
    FALSE           shift and go to state 77
    TRUE            shift and go to state 78

    expr                           shift and go to state 133
    arexp                          shift and go to state 67
    term                           shift and go to state 68
    factor                         shift and go to state 69
    element                        shift and go to state 71
    callfunc                       shift and go to state 72
    compound                       shift and go to state 73
    const                          shift and go to state 74
    compoundx                      shift and go to state 75

state 98

    (34) ifelse -> IF ( . expr ) store_gotof { ifelsecont } store_endif
    (35) ifelse -> IF ( . expr ) store_gotof { ifelsecont } ELSE store_goto { ifelsecont } store_endif
    (45) expr -> . arexp arexpx
    (56) arexp -> . term arexpextra
    (57) arexp -> . term
    (61) term -> . factor termx
    (62) term -> . factor
    (66) factor -> . FLOAT store_const
    (67) factor -> . element
    (68) factor -> . ( store_op expr ) store_op
    (69) element -> . callfunc store_oper
    (70) element -> . compound store_oper
    (71) element -> . const store_const
    (77) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (72) compound -> . compoundx
    (74) const -> . INT
    (75) const -> . FALSE store_const
    (76) const -> . TRUE store_const
    (73) compoundx -> . ID store_oper
    FLOAT           shift and go to state 70
    (               shift and go to state 51
    ID              shift and go to state 100
    INT             shift and go to state 76
    FALSE           shift and go to state 77
    TRUE            shift and go to state 78

    expr                           shift and go to state 134
    arexp                          shift and go to state 67
    term                           shift and go to state 68
    factor                         shift and go to state 69
    element                        shift and go to state 71
    callfunc                       shift and go to state 72
    compound                       shift and go to state 73
    const                          shift and go to state 74
    compoundx                      shift and go to state 75

state 99

    (33) returns -> RETURN expr . store_rquad
    (97) store_rquad -> .
    ;               reduce using rule 97 (store_rquad -> .)

    store_rquad                    shift and go to state 135

state 100

    (77) callfunc -> ID . verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (73) compoundx -> ID . store_oper
    (102) verify_func -> .
    (94) store_oper -> .
    (               reduce using rule 102 (verify_func -> .)
    /               reduce using rule 94 (store_oper -> .)
    *               reduce using rule 94 (store_oper -> .)
    -               reduce using rule 94 (store_oper -> .)
    +               reduce using rule 94 (store_oper -> .)
    OR              reduce using rule 94 (store_oper -> .)
    EQEQ            reduce using rule 94 (store_oper -> .)
    DIFF            reduce using rule 94 (store_oper -> .)
    AND             reduce using rule 94 (store_oper -> .)
    <               reduce using rule 94 (store_oper -> .)
    LOETHAN         reduce using rule 94 (store_oper -> .)
    >               reduce using rule 94 (store_oper -> .)
    GOETHAN         reduce using rule 94 (store_oper -> .)
    ;               reduce using rule 94 (store_oper -> .)
    )               reduce using rule 94 (store_oper -> .)
    ,               reduce using rule 94 (store_oper -> .)

    verify_func                    shift and go to state 96
    store_oper                     shift and go to state 136

state 101

    (45) expr -> arexp arexpx .
    ;               reduce using rule 45 (expr -> arexp arexpx .)
    )               reduce using rule 45 (expr -> arexp arexpx .)
    ,               reduce using rule 45 (expr -> arexp arexpx .)


state 102

    (47) arexpx -> arexpxop . arexp
    (56) arexp -> . term arexpextra
    (57) arexp -> . term
    (61) term -> . factor termx
    (62) term -> . factor
    (66) factor -> . FLOAT store_const
    (67) factor -> . element
    (68) factor -> . ( store_op expr ) store_op
    (69) element -> . callfunc store_oper
    (70) element -> . compound store_oper
    (71) element -> . const store_const
    (77) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (72) compound -> . compoundx
    (74) const -> . INT
    (75) const -> . FALSE store_const
    (76) const -> . TRUE store_const
    (73) compoundx -> . ID store_oper
    FLOAT           shift and go to state 70
    (               shift and go to state 51
    ID              shift and go to state 100
    INT             shift and go to state 76
    FALSE           shift and go to state 77
    TRUE            shift and go to state 78

    arexp                          shift and go to state 137
    term                           shift and go to state 68
    factor                         shift and go to state 69
    element                        shift and go to state 71
    callfunc                       shift and go to state 72
    compound                       shift and go to state 73
    const                          shift and go to state 74
    compoundx                      shift and go to state 75

state 103

    (48) arexpxop -> OR .
    FLOAT           reduce using rule 48 (arexpxop -> OR .)
    (               reduce using rule 48 (arexpxop -> OR .)
    ID              reduce using rule 48 (arexpxop -> OR .)
    INT             reduce using rule 48 (arexpxop -> OR .)
    FALSE           reduce using rule 48 (arexpxop -> OR .)
    TRUE            reduce using rule 48 (arexpxop -> OR .)


state 104

    (49) arexpxop -> EQEQ .
    FLOAT           reduce using rule 49 (arexpxop -> EQEQ .)
    (               reduce using rule 49 (arexpxop -> EQEQ .)
    ID              reduce using rule 49 (arexpxop -> EQEQ .)
    INT             reduce using rule 49 (arexpxop -> EQEQ .)
    FALSE           reduce using rule 49 (arexpxop -> EQEQ .)
    TRUE            reduce using rule 49 (arexpxop -> EQEQ .)


state 105

    (50) arexpxop -> DIFF .
    FLOAT           reduce using rule 50 (arexpxop -> DIFF .)
    (               reduce using rule 50 (arexpxop -> DIFF .)
    ID              reduce using rule 50 (arexpxop -> DIFF .)
    INT             reduce using rule 50 (arexpxop -> DIFF .)
    FALSE           reduce using rule 50 (arexpxop -> DIFF .)
    TRUE            reduce using rule 50 (arexpxop -> DIFF .)


state 106

    (51) arexpxop -> AND .
    FLOAT           reduce using rule 51 (arexpxop -> AND .)
    (               reduce using rule 51 (arexpxop -> AND .)
    ID              reduce using rule 51 (arexpxop -> AND .)
    INT             reduce using rule 51 (arexpxop -> AND .)
    FALSE           reduce using rule 51 (arexpxop -> AND .)
    TRUE            reduce using rule 51 (arexpxop -> AND .)


state 107

    (52) arexpxop -> < .
    FLOAT           reduce using rule 52 (arexpxop -> < .)
    (               reduce using rule 52 (arexpxop -> < .)
    ID              reduce using rule 52 (arexpxop -> < .)
    INT             reduce using rule 52 (arexpxop -> < .)
    FALSE           reduce using rule 52 (arexpxop -> < .)
    TRUE            reduce using rule 52 (arexpxop -> < .)


state 108

    (53) arexpxop -> LOETHAN .
    FLOAT           reduce using rule 53 (arexpxop -> LOETHAN .)
    (               reduce using rule 53 (arexpxop -> LOETHAN .)
    ID              reduce using rule 53 (arexpxop -> LOETHAN .)
    INT             reduce using rule 53 (arexpxop -> LOETHAN .)
    FALSE           reduce using rule 53 (arexpxop -> LOETHAN .)
    TRUE            reduce using rule 53 (arexpxop -> LOETHAN .)


state 109

    (54) arexpxop -> > .
    FLOAT           reduce using rule 54 (arexpxop -> > .)
    (               reduce using rule 54 (arexpxop -> > .)
    ID              reduce using rule 54 (arexpxop -> > .)
    INT             reduce using rule 54 (arexpxop -> > .)
    FALSE           reduce using rule 54 (arexpxop -> > .)
    TRUE            reduce using rule 54 (arexpxop -> > .)


state 110

    (55) arexpxop -> GOETHAN .
    FLOAT           reduce using rule 55 (arexpxop -> GOETHAN .)
    (               reduce using rule 55 (arexpxop -> GOETHAN .)
    ID              reduce using rule 55 (arexpxop -> GOETHAN .)
    INT             reduce using rule 55 (arexpxop -> GOETHAN .)
    FALSE           reduce using rule 55 (arexpxop -> GOETHAN .)
    TRUE            reduce using rule 55 (arexpxop -> GOETHAN .)


state 111

    (56) arexp -> term arexpextra .
    OR              reduce using rule 56 (arexp -> term arexpextra .)
    EQEQ            reduce using rule 56 (arexp -> term arexpextra .)
    DIFF            reduce using rule 56 (arexp -> term arexpextra .)
    AND             reduce using rule 56 (arexp -> term arexpextra .)
    <               reduce using rule 56 (arexp -> term arexpextra .)
    LOETHAN         reduce using rule 56 (arexp -> term arexpextra .)
    >               reduce using rule 56 (arexp -> term arexpextra .)
    GOETHAN         reduce using rule 56 (arexp -> term arexpextra .)
    ;               reduce using rule 56 (arexp -> term arexpextra .)
    )               reduce using rule 56 (arexp -> term arexpextra .)
    ,               reduce using rule 56 (arexp -> term arexpextra .)


state 112

    (59) arexpextra -> - . term arexpextra
    (61) term -> . factor termx
    (62) term -> . factor
    (66) factor -> . FLOAT store_const
    (67) factor -> . element
    (68) factor -> . ( store_op expr ) store_op
    (69) element -> . callfunc store_oper
    (70) element -> . compound store_oper
    (71) element -> . const store_const
    (77) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (72) compound -> . compoundx
    (74) const -> . INT
    (75) const -> . FALSE store_const
    (76) const -> . TRUE store_const
    (73) compoundx -> . ID store_oper
    FLOAT           shift and go to state 70
    (               shift and go to state 51
    ID              shift and go to state 100
    INT             shift and go to state 76
    FALSE           shift and go to state 77
    TRUE            shift and go to state 78

    term                           shift and go to state 138
    factor                         shift and go to state 69
    element                        shift and go to state 71
    callfunc                       shift and go to state 72
    compound                       shift and go to state 73
    const                          shift and go to state 74
    compoundx                      shift and go to state 75

state 113

    (60) arexpextra -> + . term arexpextra
    (61) term -> . factor termx
    (62) term -> . factor
    (66) factor -> . FLOAT store_const
    (67) factor -> . element
    (68) factor -> . ( store_op expr ) store_op
    (69) element -> . callfunc store_oper
    (70) element -> . compound store_oper
    (71) element -> . const store_const
    (77) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (72) compound -> . compoundx
    (74) const -> . INT
    (75) const -> . FALSE store_const
    (76) const -> . TRUE store_const
    (73) compoundx -> . ID store_oper
    FLOAT           shift and go to state 70
    (               shift and go to state 51
    ID              shift and go to state 100
    INT             shift and go to state 76
    FALSE           shift and go to state 77
    TRUE            shift and go to state 78

    term                           shift and go to state 139
    factor                         shift and go to state 69
    element                        shift and go to state 71
    callfunc                       shift and go to state 72
    compound                       shift and go to state 73
    const                          shift and go to state 74
    compoundx                      shift and go to state 75

state 114

    (61) term -> factor termx .
    -               reduce using rule 61 (term -> factor termx .)
    +               reduce using rule 61 (term -> factor termx .)
    OR              reduce using rule 61 (term -> factor termx .)
    EQEQ            reduce using rule 61 (term -> factor termx .)
    DIFF            reduce using rule 61 (term -> factor termx .)
    AND             reduce using rule 61 (term -> factor termx .)
    <               reduce using rule 61 (term -> factor termx .)
    LOETHAN         reduce using rule 61 (term -> factor termx .)
    >               reduce using rule 61 (term -> factor termx .)
    GOETHAN         reduce using rule 61 (term -> factor termx .)
    ;               reduce using rule 61 (term -> factor termx .)
    )               reduce using rule 61 (term -> factor termx .)
    ,               reduce using rule 61 (term -> factor termx .)


state 115

    (64) termx -> / . factor termx
    (66) factor -> . FLOAT store_const
    (67) factor -> . element
    (68) factor -> . ( store_op expr ) store_op
    (69) element -> . callfunc store_oper
    (70) element -> . compound store_oper
    (71) element -> . const store_const
    (77) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (72) compound -> . compoundx
    (74) const -> . INT
    (75) const -> . FALSE store_const
    (76) const -> . TRUE store_const
    (73) compoundx -> . ID store_oper
    FLOAT           shift and go to state 70
    (               shift and go to state 51
    ID              shift and go to state 100
    INT             shift and go to state 76
    FALSE           shift and go to state 77
    TRUE            shift and go to state 78

    factor                         shift and go to state 140
    element                        shift and go to state 71
    callfunc                       shift and go to state 72
    compound                       shift and go to state 73
    const                          shift and go to state 74
    compoundx                      shift and go to state 75

state 116

    (65) termx -> * . factor termx
    (66) factor -> . FLOAT store_const
    (67) factor -> . element
    (68) factor -> . ( store_op expr ) store_op
    (69) element -> . callfunc store_oper
    (70) element -> . compound store_oper
    (71) element -> . const store_const
    (77) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (72) compound -> . compoundx
    (74) const -> . INT
    (75) const -> . FALSE store_const
    (76) const -> . TRUE store_const
    (73) compoundx -> . ID store_oper
    FLOAT           shift and go to state 70
    (               shift and go to state 51
    ID              shift and go to state 100
    INT             shift and go to state 76
    FALSE           shift and go to state 77
    TRUE            shift and go to state 78

    factor                         shift and go to state 141
    element                        shift and go to state 71
    callfunc                       shift and go to state 72
    compound                       shift and go to state 73
    const                          shift and go to state 74
    compoundx                      shift and go to state 75

state 117

    (66) factor -> FLOAT store_const .
    /               reduce using rule 66 (factor -> FLOAT store_const .)
    *               reduce using rule 66 (factor -> FLOAT store_const .)
    -               reduce using rule 66 (factor -> FLOAT store_const .)
    +               reduce using rule 66 (factor -> FLOAT store_const .)
    OR              reduce using rule 66 (factor -> FLOAT store_const .)
    EQEQ            reduce using rule 66 (factor -> FLOAT store_const .)
    DIFF            reduce using rule 66 (factor -> FLOAT store_const .)
    AND             reduce using rule 66 (factor -> FLOAT store_const .)
    <               reduce using rule 66 (factor -> FLOAT store_const .)
    LOETHAN         reduce using rule 66 (factor -> FLOAT store_const .)
    >               reduce using rule 66 (factor -> FLOAT store_const .)
    GOETHAN         reduce using rule 66 (factor -> FLOAT store_const .)
    ;               reduce using rule 66 (factor -> FLOAT store_const .)
    )               reduce using rule 66 (factor -> FLOAT store_const .)
    ,               reduce using rule 66 (factor -> FLOAT store_const .)


state 118

    (69) element -> callfunc store_oper .
    /               reduce using rule 69 (element -> callfunc store_oper .)
    *               reduce using rule 69 (element -> callfunc store_oper .)
    -               reduce using rule 69 (element -> callfunc store_oper .)
    +               reduce using rule 69 (element -> callfunc store_oper .)
    OR              reduce using rule 69 (element -> callfunc store_oper .)
    EQEQ            reduce using rule 69 (element -> callfunc store_oper .)
    DIFF            reduce using rule 69 (element -> callfunc store_oper .)
    AND             reduce using rule 69 (element -> callfunc store_oper .)
    <               reduce using rule 69 (element -> callfunc store_oper .)
    LOETHAN         reduce using rule 69 (element -> callfunc store_oper .)
    >               reduce using rule 69 (element -> callfunc store_oper .)
    GOETHAN         reduce using rule 69 (element -> callfunc store_oper .)
    ;               reduce using rule 69 (element -> callfunc store_oper .)
    )               reduce using rule 69 (element -> callfunc store_oper .)
    ,               reduce using rule 69 (element -> callfunc store_oper .)


state 119

    (70) element -> compound store_oper .
    /               reduce using rule 70 (element -> compound store_oper .)
    *               reduce using rule 70 (element -> compound store_oper .)
    -               reduce using rule 70 (element -> compound store_oper .)
    +               reduce using rule 70 (element -> compound store_oper .)
    OR              reduce using rule 70 (element -> compound store_oper .)
    EQEQ            reduce using rule 70 (element -> compound store_oper .)
    DIFF            reduce using rule 70 (element -> compound store_oper .)
    AND             reduce using rule 70 (element -> compound store_oper .)
    <               reduce using rule 70 (element -> compound store_oper .)
    LOETHAN         reduce using rule 70 (element -> compound store_oper .)
    >               reduce using rule 70 (element -> compound store_oper .)
    GOETHAN         reduce using rule 70 (element -> compound store_oper .)
    ;               reduce using rule 70 (element -> compound store_oper .)
    )               reduce using rule 70 (element -> compound store_oper .)
    ,               reduce using rule 70 (element -> compound store_oper .)


state 120

    (71) element -> const store_const .
    /               reduce using rule 71 (element -> const store_const .)
    *               reduce using rule 71 (element -> const store_const .)
    -               reduce using rule 71 (element -> const store_const .)
    +               reduce using rule 71 (element -> const store_const .)
    OR              reduce using rule 71 (element -> const store_const .)
    EQEQ            reduce using rule 71 (element -> const store_const .)
    DIFF            reduce using rule 71 (element -> const store_const .)
    AND             reduce using rule 71 (element -> const store_const .)
    <               reduce using rule 71 (element -> const store_const .)
    LOETHAN         reduce using rule 71 (element -> const store_const .)
    >               reduce using rule 71 (element -> const store_const .)
    GOETHAN         reduce using rule 71 (element -> const store_const .)
    ;               reduce using rule 71 (element -> const store_const .)
    )               reduce using rule 71 (element -> const store_const .)
    ,               reduce using rule 71 (element -> const store_const .)


state 121

    (75) const -> FALSE store_const .
    /               reduce using rule 75 (const -> FALSE store_const .)
    *               reduce using rule 75 (const -> FALSE store_const .)
    -               reduce using rule 75 (const -> FALSE store_const .)
    +               reduce using rule 75 (const -> FALSE store_const .)
    OR              reduce using rule 75 (const -> FALSE store_const .)
    EQEQ            reduce using rule 75 (const -> FALSE store_const .)
    DIFF            reduce using rule 75 (const -> FALSE store_const .)
    AND             reduce using rule 75 (const -> FALSE store_const .)
    <               reduce using rule 75 (const -> FALSE store_const .)
    LOETHAN         reduce using rule 75 (const -> FALSE store_const .)
    >               reduce using rule 75 (const -> FALSE store_const .)
    GOETHAN         reduce using rule 75 (const -> FALSE store_const .)
    ;               reduce using rule 75 (const -> FALSE store_const .)
    )               reduce using rule 75 (const -> FALSE store_const .)
    ,               reduce using rule 75 (const -> FALSE store_const .)


state 122

    (76) const -> TRUE store_const .
    /               reduce using rule 76 (const -> TRUE store_const .)
    *               reduce using rule 76 (const -> TRUE store_const .)
    -               reduce using rule 76 (const -> TRUE store_const .)
    +               reduce using rule 76 (const -> TRUE store_const .)
    OR              reduce using rule 76 (const -> TRUE store_const .)
    EQEQ            reduce using rule 76 (const -> TRUE store_const .)
    DIFF            reduce using rule 76 (const -> TRUE store_const .)
    AND             reduce using rule 76 (const -> TRUE store_const .)
    <               reduce using rule 76 (const -> TRUE store_const .)
    LOETHAN         reduce using rule 76 (const -> TRUE store_const .)
    >               reduce using rule 76 (const -> TRUE store_const .)
    GOETHAN         reduce using rule 76 (const -> TRUE store_const .)
    ;               reduce using rule 76 (const -> TRUE store_const .)
    )               reduce using rule 76 (const -> TRUE store_const .)
    ,               reduce using rule 76 (const -> TRUE store_const .)


state 123

    (8) vars -> VAR datatype varids store_type . ;
    ;               shift and go to state 142


state 124

    (11) varids -> ID , . varids
    (10) varids -> . ID
    (11) varids -> . ID , varids
    ID              shift and go to state 80

    varids                         shift and go to state 143

state 125

    (13) functions -> datatype FUNC ID ( params ) store_funcv store_params store_init_quad { vars store_local_vars funcontent . } close_func functions
    }               shift and go to state 144


state 126

    (16) funcontent -> statement . funcontent
    (30) statement -> statement . statement
    (15) funcontent -> .
    (16) funcontent -> . statement funcontent
    (23) statement -> . loop unload_pv
    (24) statement -> . input unload_pv
    (25) statement -> . output unload_pv
    (26) statement -> . ifelse unload_pv
    (27) statement -> . returns unload_pv ;
    (28) statement -> . expr ;
    (29) statement -> . var_assign unload_pv
    (30) statement -> . statement statement
    (31) statement -> .
    (42) loop -> . WHILE store_jump ( expr ) store_gotof { loopcont } end_loop
    (41) input -> . INPUT ( ID store_oper ) ;
    (38) output -> . OUTPUT ( expr outex ) ;
    (34) ifelse -> . IF ( expr ) store_gotof { ifelsecont } store_endif
    (35) ifelse -> . IF ( expr ) store_gotof { ifelsecont } ELSE store_goto { ifelsecont } store_endif
    (33) returns -> . RETURN expr store_rquad
    (45) expr -> . arexp arexpx
    (32) var_assign -> . ID store_oper = expr ;
    (56) arexp -> . term arexpextra
    (57) arexp -> . term
    (61) term -> . factor termx
    (62) term -> . factor
    (66) factor -> . FLOAT store_const
    (67) factor -> . element
    (68) factor -> . ( store_op expr ) store_op
    (69) element -> . callfunc store_oper
    (70) element -> . compound store_oper
    (71) element -> . const store_const
    (77) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (72) compound -> . compoundx
    (74) const -> . INT
    (75) const -> . FALSE store_const
    (76) const -> . TRUE store_const
    (73) compoundx -> . ID store_oper
  ! reduce/reduce conflict for } resolved using rule 15 (funcontent -> .)
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for OUTPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    }               reduce using rule 15 (funcontent -> .)
    WHILE           shift and go to state 61
    INPUT           shift and go to state 62
    OUTPUT          shift and go to state 64
    IF              shift and go to state 65
    RETURN          shift and go to state 66
    ID              shift and go to state 63
    FLOAT           shift and go to state 70
    (               shift and go to state 51
    INT             shift and go to state 76
    FALSE           shift and go to state 77
    TRUE            shift and go to state 78

    statement                      shift and go to state 145
    funcontent                     shift and go to state 146
    loop                           shift and go to state 54
    input                          shift and go to state 55
    output                         shift and go to state 56
    ifelse                         shift and go to state 57
    returns                        shift and go to state 58
    expr                           shift and go to state 59
    var_assign                     shift and go to state 60
    arexp                          shift and go to state 67
    term                           shift and go to state 68
    factor                         shift and go to state 69
    element                        shift and go to state 71
    callfunc                       shift and go to state 72
    compound                       shift and go to state 73
    const                          shift and go to state 74
    compoundx                      shift and go to state 75

state 127

    (68) factor -> ( store_op expr . ) store_op
    )               shift and go to state 147


state 128

    (27) statement -> returns unload_pv ; .
    WHILE           reduce using rule 27 (statement -> returns unload_pv ; .)
    INPUT           reduce using rule 27 (statement -> returns unload_pv ; .)
    OUTPUT          reduce using rule 27 (statement -> returns unload_pv ; .)
    IF              reduce using rule 27 (statement -> returns unload_pv ; .)
    RETURN          reduce using rule 27 (statement -> returns unload_pv ; .)
    ID              reduce using rule 27 (statement -> returns unload_pv ; .)
    FLOAT           reduce using rule 27 (statement -> returns unload_pv ; .)
    (               reduce using rule 27 (statement -> returns unload_pv ; .)
    INT             reduce using rule 27 (statement -> returns unload_pv ; .)
    FALSE           reduce using rule 27 (statement -> returns unload_pv ; .)
    TRUE            reduce using rule 27 (statement -> returns unload_pv ; .)
    }               reduce using rule 27 (statement -> returns unload_pv ; .)


state 129

    (42) loop -> WHILE store_jump ( . expr ) store_gotof { loopcont } end_loop
    (45) expr -> . arexp arexpx
    (56) arexp -> . term arexpextra
    (57) arexp -> . term
    (61) term -> . factor termx
    (62) term -> . factor
    (66) factor -> . FLOAT store_const
    (67) factor -> . element
    (68) factor -> . ( store_op expr ) store_op
    (69) element -> . callfunc store_oper
    (70) element -> . compound store_oper
    (71) element -> . const store_const
    (77) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (72) compound -> . compoundx
    (74) const -> . INT
    (75) const -> . FALSE store_const
    (76) const -> . TRUE store_const
    (73) compoundx -> . ID store_oper
    FLOAT           shift and go to state 70
    (               shift and go to state 51
    ID              shift and go to state 100
    INT             shift and go to state 76
    FALSE           shift and go to state 77
    TRUE            shift and go to state 78

    expr                           shift and go to state 148
    arexp                          shift and go to state 67
    term                           shift and go to state 68
    factor                         shift and go to state 69
    element                        shift and go to state 71
    callfunc                       shift and go to state 72
    compound                       shift and go to state 73
    const                          shift and go to state 74
    compoundx                      shift and go to state 75

state 130

    (41) input -> INPUT ( ID . store_oper ) ;
    (94) store_oper -> .
    )               reduce using rule 94 (store_oper -> .)

    store_oper                     shift and go to state 149

state 131

    (32) var_assign -> ID store_oper = . expr ;
    (45) expr -> . arexp arexpx
    (56) arexp -> . term arexpextra
    (57) arexp -> . term
    (61) term -> . factor termx
    (62) term -> . factor
    (66) factor -> . FLOAT store_const
    (67) factor -> . element
    (68) factor -> . ( store_op expr ) store_op
    (69) element -> . callfunc store_oper
    (70) element -> . compound store_oper
    (71) element -> . const store_const
    (77) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (72) compound -> . compoundx
    (74) const -> . INT
    (75) const -> . FALSE store_const
    (76) const -> . TRUE store_const
    (73) compoundx -> . ID store_oper
    FLOAT           shift and go to state 70
    (               shift and go to state 51
    ID              shift and go to state 100
    INT             shift and go to state 76
    FALSE           shift and go to state 77
    TRUE            shift and go to state 78

    expr                           shift and go to state 150
    arexp                          shift and go to state 67
    term                           shift and go to state 68
    factor                         shift and go to state 69
    element                        shift and go to state 71
    callfunc                       shift and go to state 72
    compound                       shift and go to state 73
    const                          shift and go to state 74
    compoundx                      shift and go to state 75

state 132

    (77) callfunc -> ID verify_func add_fstack . ( callfuncpar ver_params ) end_fstack store_gosub
    (               shift and go to state 151


state 133

    (38) output -> OUTPUT ( expr . outex ) ;
    (39) outex -> .
    (40) outex -> . , expr outex
    )               reduce using rule 39 (outex -> .)
    ,               shift and go to state 153

    outex                          shift and go to state 152

state 134

    (34) ifelse -> IF ( expr . ) store_gotof { ifelsecont } store_endif
    (35) ifelse -> IF ( expr . ) store_gotof { ifelsecont } ELSE store_goto { ifelsecont } store_endif
    )               shift and go to state 154


state 135

    (33) returns -> RETURN expr store_rquad .
    ;               reduce using rule 33 (returns -> RETURN expr store_rquad .)


state 136

    (73) compoundx -> ID store_oper .
    /               reduce using rule 73 (compoundx -> ID store_oper .)
    *               reduce using rule 73 (compoundx -> ID store_oper .)
    -               reduce using rule 73 (compoundx -> ID store_oper .)
    +               reduce using rule 73 (compoundx -> ID store_oper .)
    OR              reduce using rule 73 (compoundx -> ID store_oper .)
    EQEQ            reduce using rule 73 (compoundx -> ID store_oper .)
    DIFF            reduce using rule 73 (compoundx -> ID store_oper .)
    AND             reduce using rule 73 (compoundx -> ID store_oper .)
    <               reduce using rule 73 (compoundx -> ID store_oper .)
    LOETHAN         reduce using rule 73 (compoundx -> ID store_oper .)
    >               reduce using rule 73 (compoundx -> ID store_oper .)
    GOETHAN         reduce using rule 73 (compoundx -> ID store_oper .)
    ;               reduce using rule 73 (compoundx -> ID store_oper .)
    )               reduce using rule 73 (compoundx -> ID store_oper .)
    ,               reduce using rule 73 (compoundx -> ID store_oper .)


state 137

    (47) arexpx -> arexpxop arexp .
    ;               reduce using rule 47 (arexpx -> arexpxop arexp .)
    )               reduce using rule 47 (arexpx -> arexpxop arexp .)
    ,               reduce using rule 47 (arexpx -> arexpxop arexp .)


state 138

    (59) arexpextra -> - term . arexpextra
    (58) arexpextra -> .
    (59) arexpextra -> . - term arexpextra
    (60) arexpextra -> . + term arexpextra
    OR              reduce using rule 58 (arexpextra -> .)
    EQEQ            reduce using rule 58 (arexpextra -> .)
    DIFF            reduce using rule 58 (arexpextra -> .)
    AND             reduce using rule 58 (arexpextra -> .)
    <               reduce using rule 58 (arexpextra -> .)
    LOETHAN         reduce using rule 58 (arexpextra -> .)
    >               reduce using rule 58 (arexpextra -> .)
    GOETHAN         reduce using rule 58 (arexpextra -> .)
    ;               reduce using rule 58 (arexpextra -> .)
    )               reduce using rule 58 (arexpextra -> .)
    ,               reduce using rule 58 (arexpextra -> .)
    -               shift and go to state 112
    +               shift and go to state 113

    arexpextra                     shift and go to state 155

state 139

    (60) arexpextra -> + term . arexpextra
    (58) arexpextra -> .
    (59) arexpextra -> . - term arexpextra
    (60) arexpextra -> . + term arexpextra
    OR              reduce using rule 58 (arexpextra -> .)
    EQEQ            reduce using rule 58 (arexpextra -> .)
    DIFF            reduce using rule 58 (arexpextra -> .)
    AND             reduce using rule 58 (arexpextra -> .)
    <               reduce using rule 58 (arexpextra -> .)
    LOETHAN         reduce using rule 58 (arexpextra -> .)
    >               reduce using rule 58 (arexpextra -> .)
    GOETHAN         reduce using rule 58 (arexpextra -> .)
    ;               reduce using rule 58 (arexpextra -> .)
    )               reduce using rule 58 (arexpextra -> .)
    ,               reduce using rule 58 (arexpextra -> .)
    -               shift and go to state 112
    +               shift and go to state 113

    arexpextra                     shift and go to state 156

state 140

    (64) termx -> / factor . termx
    (63) termx -> .
    (64) termx -> . / factor termx
    (65) termx -> . * factor termx
    -               reduce using rule 63 (termx -> .)
    +               reduce using rule 63 (termx -> .)
    OR              reduce using rule 63 (termx -> .)
    EQEQ            reduce using rule 63 (termx -> .)
    DIFF            reduce using rule 63 (termx -> .)
    AND             reduce using rule 63 (termx -> .)
    <               reduce using rule 63 (termx -> .)
    LOETHAN         reduce using rule 63 (termx -> .)
    >               reduce using rule 63 (termx -> .)
    GOETHAN         reduce using rule 63 (termx -> .)
    ;               reduce using rule 63 (termx -> .)
    )               reduce using rule 63 (termx -> .)
    ,               reduce using rule 63 (termx -> .)
    /               shift and go to state 115
    *               shift and go to state 116

    termx                          shift and go to state 157

state 141

    (65) termx -> * factor . termx
    (63) termx -> .
    (64) termx -> . / factor termx
    (65) termx -> . * factor termx
    -               reduce using rule 63 (termx -> .)
    +               reduce using rule 63 (termx -> .)
    OR              reduce using rule 63 (termx -> .)
    EQEQ            reduce using rule 63 (termx -> .)
    DIFF            reduce using rule 63 (termx -> .)
    AND             reduce using rule 63 (termx -> .)
    <               reduce using rule 63 (termx -> .)
    LOETHAN         reduce using rule 63 (termx -> .)
    >               reduce using rule 63 (termx -> .)
    GOETHAN         reduce using rule 63 (termx -> .)
    ;               reduce using rule 63 (termx -> .)
    )               reduce using rule 63 (termx -> .)
    ,               reduce using rule 63 (termx -> .)
    /               shift and go to state 115
    *               shift and go to state 116

    termx                          shift and go to state 158

state 142

    (8) vars -> VAR datatype varids store_type ; .
    WHILE           reduce using rule 8 (vars -> VAR datatype varids store_type ; .)
    INPUT           reduce using rule 8 (vars -> VAR datatype varids store_type ; .)
    OUTPUT          reduce using rule 8 (vars -> VAR datatype varids store_type ; .)
    IF              reduce using rule 8 (vars -> VAR datatype varids store_type ; .)
    RETURN          reduce using rule 8 (vars -> VAR datatype varids store_type ; .)
    ID              reduce using rule 8 (vars -> VAR datatype varids store_type ; .)
    FLOAT           reduce using rule 8 (vars -> VAR datatype varids store_type ; .)
    (               reduce using rule 8 (vars -> VAR datatype varids store_type ; .)
    INT             reduce using rule 8 (vars -> VAR datatype varids store_type ; .)
    FALSE           reduce using rule 8 (vars -> VAR datatype varids store_type ; .)
    TRUE            reduce using rule 8 (vars -> VAR datatype varids store_type ; .)
    }               reduce using rule 8 (vars -> VAR datatype varids store_type ; .)


state 143

    (11) varids -> ID , varids .
    ;               reduce using rule 11 (varids -> ID , varids .)


state 144

    (13) functions -> datatype FUNC ID ( params ) store_funcv store_params store_init_quad { vars store_local_vars funcontent } . close_func functions
    (98) close_func -> .
    D_BOOL          reduce using rule 98 (close_func -> .)
    D_STRING        reduce using rule 98 (close_func -> .)
    D_FLOAT         reduce using rule 98 (close_func -> .)
    D_INT           reduce using rule 98 (close_func -> .)
    VAR             reduce using rule 98 (close_func -> .)
    FUNC            reduce using rule 98 (close_func -> .)

    close_func                     shift and go to state 159

state 145

    (30) statement -> statement statement .
    (16) funcontent -> statement . funcontent
    (30) statement -> statement . statement
    (15) funcontent -> .
    (16) funcontent -> . statement funcontent
    (23) statement -> . loop unload_pv
    (24) statement -> . input unload_pv
    (25) statement -> . output unload_pv
    (26) statement -> . ifelse unload_pv
    (27) statement -> . returns unload_pv ;
    (28) statement -> . expr ;
    (29) statement -> . var_assign unload_pv
    (30) statement -> . statement statement
    (31) statement -> .
    (42) loop -> . WHILE store_jump ( expr ) store_gotof { loopcont } end_loop
    (41) input -> . INPUT ( ID store_oper ) ;
    (38) output -> . OUTPUT ( expr outex ) ;
    (34) ifelse -> . IF ( expr ) store_gotof { ifelsecont } store_endif
    (35) ifelse -> . IF ( expr ) store_gotof { ifelsecont } ELSE store_goto { ifelsecont } store_endif
    (33) returns -> . RETURN expr store_rquad
    (45) expr -> . arexp arexpx
    (32) var_assign -> . ID store_oper = expr ;
    (56) arexp -> . term arexpextra
    (57) arexp -> . term
    (61) term -> . factor termx
    (62) term -> . factor
    (66) factor -> . FLOAT store_const
    (67) factor -> . element
    (68) factor -> . ( store_op expr ) store_op
    (69) element -> . callfunc store_oper
    (70) element -> . compound store_oper
    (71) element -> . const store_const
    (77) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (72) compound -> . compoundx
    (74) const -> . INT
    (75) const -> . FALSE store_const
    (76) const -> . TRUE store_const
    (73) compoundx -> . ID store_oper
  ! reduce/reduce conflict for } resolved using rule 15 (funcontent -> .)
  ! reduce/reduce conflict for WHILE resolved using rule 31 (statement -> .)
  ! reduce/reduce conflict for INPUT resolved using rule 31 (statement -> .)
  ! reduce/reduce conflict for OUTPUT resolved using rule 31 (statement -> .)
  ! reduce/reduce conflict for IF resolved using rule 31 (statement -> .)
  ! reduce/reduce conflict for RETURN resolved using rule 31 (statement -> .)
  ! reduce/reduce conflict for ID resolved using rule 31 (statement -> .)
  ! reduce/reduce conflict for FLOAT resolved using rule 31 (statement -> .)
  ! reduce/reduce conflict for ( resolved using rule 31 (statement -> .)
  ! reduce/reduce conflict for INT resolved using rule 31 (statement -> .)
  ! reduce/reduce conflict for FALSE resolved using rule 31 (statement -> .)
  ! reduce/reduce conflict for TRUE resolved using rule 31 (statement -> .)
  ! reduce/reduce conflict for } resolved using rule 15 (funcontent -> .)
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for OUTPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    }               reduce using rule 15 (funcontent -> .)
    WHILE           shift and go to state 61
    INPUT           shift and go to state 62
    OUTPUT          shift and go to state 64
    IF              shift and go to state 65
    RETURN          shift and go to state 66
    ID              shift and go to state 63
    FLOAT           shift and go to state 70
    (               shift and go to state 51
    INT             shift and go to state 76
    FALSE           shift and go to state 77
    TRUE            shift and go to state 78

    statement                      shift and go to state 145
    funcontent                     shift and go to state 146
    loop                           shift and go to state 54
    input                          shift and go to state 55
    output                         shift and go to state 56
    ifelse                         shift and go to state 57
    returns                        shift and go to state 58
    expr                           shift and go to state 59
    var_assign                     shift and go to state 60
    arexp                          shift and go to state 67
    term                           shift and go to state 68
    factor                         shift and go to state 69
    element                        shift and go to state 71
    callfunc                       shift and go to state 72
    compound                       shift and go to state 73
    const                          shift and go to state 74
    compoundx                      shift and go to state 75

state 146

    (16) funcontent -> statement funcontent .
    }               reduce using rule 16 (funcontent -> statement funcontent .)


state 147

    (68) factor -> ( store_op expr ) . store_op
    (93) store_op -> .
    /               reduce using rule 93 (store_op -> .)
    *               reduce using rule 93 (store_op -> .)
    -               reduce using rule 93 (store_op -> .)
    +               reduce using rule 93 (store_op -> .)
    OR              reduce using rule 93 (store_op -> .)
    EQEQ            reduce using rule 93 (store_op -> .)
    DIFF            reduce using rule 93 (store_op -> .)
    AND             reduce using rule 93 (store_op -> .)
    <               reduce using rule 93 (store_op -> .)
    LOETHAN         reduce using rule 93 (store_op -> .)
    >               reduce using rule 93 (store_op -> .)
    GOETHAN         reduce using rule 93 (store_op -> .)
    ;               reduce using rule 93 (store_op -> .)
    )               reduce using rule 93 (store_op -> .)
    ,               reduce using rule 93 (store_op -> .)

    store_op                       shift and go to state 160

state 148

    (42) loop -> WHILE store_jump ( expr . ) store_gotof { loopcont } end_loop
    )               shift and go to state 161


state 149

    (41) input -> INPUT ( ID store_oper . ) ;
    )               shift and go to state 162


state 150

    (32) var_assign -> ID store_oper = expr . ;
    ;               shift and go to state 163


state 151

    (77) callfunc -> ID verify_func add_fstack ( . callfuncpar ver_params ) end_fstack store_gosub
    (78) callfuncpar -> .
    (79) callfuncpar -> . expr store_pquad callfuncparx
    (45) expr -> . arexp arexpx
    (56) arexp -> . term arexpextra
    (57) arexp -> . term
    (61) term -> . factor termx
    (62) term -> . factor
    (66) factor -> . FLOAT store_const
    (67) factor -> . element
    (68) factor -> . ( store_op expr ) store_op
    (69) element -> . callfunc store_oper
    (70) element -> . compound store_oper
    (71) element -> . const store_const
    (77) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (72) compound -> . compoundx
    (74) const -> . INT
    (75) const -> . FALSE store_const
    (76) const -> . TRUE store_const
    (73) compoundx -> . ID store_oper
    )               reduce using rule 78 (callfuncpar -> .)
    FLOAT           shift and go to state 70
    (               shift and go to state 51
    ID              shift and go to state 100
    INT             shift and go to state 76
    FALSE           shift and go to state 77
    TRUE            shift and go to state 78

    callfuncpar                    shift and go to state 164
    expr                           shift and go to state 165
    arexp                          shift and go to state 67
    term                           shift and go to state 68
    factor                         shift and go to state 69
    element                        shift and go to state 71
    callfunc                       shift and go to state 72
    compound                       shift and go to state 73
    const                          shift and go to state 74
    compoundx                      shift and go to state 75

state 152

    (38) output -> OUTPUT ( expr outex . ) ;
    )               shift and go to state 166


state 153

    (40) outex -> , . expr outex
    (45) expr -> . arexp arexpx
    (56) arexp -> . term arexpextra
    (57) arexp -> . term
    (61) term -> . factor termx
    (62) term -> . factor
    (66) factor -> . FLOAT store_const
    (67) factor -> . element
    (68) factor -> . ( store_op expr ) store_op
    (69) element -> . callfunc store_oper
    (70) element -> . compound store_oper
    (71) element -> . const store_const
    (77) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (72) compound -> . compoundx
    (74) const -> . INT
    (75) const -> . FALSE store_const
    (76) const -> . TRUE store_const
    (73) compoundx -> . ID store_oper
    FLOAT           shift and go to state 70
    (               shift and go to state 51
    ID              shift and go to state 100
    INT             shift and go to state 76
    FALSE           shift and go to state 77
    TRUE            shift and go to state 78

    expr                           shift and go to state 167
    arexp                          shift and go to state 67
    term                           shift and go to state 68
    factor                         shift and go to state 69
    element                        shift and go to state 71
    callfunc                       shift and go to state 72
    compound                       shift and go to state 73
    const                          shift and go to state 74
    compoundx                      shift and go to state 75

state 154

    (34) ifelse -> IF ( expr ) . store_gotof { ifelsecont } store_endif
    (35) ifelse -> IF ( expr ) . store_gotof { ifelsecont } ELSE store_goto { ifelsecont } store_endif
    (106) store_gotof -> .
    {               reduce using rule 106 (store_gotof -> .)

    store_gotof                    shift and go to state 168

state 155

    (59) arexpextra -> - term arexpextra .
    OR              reduce using rule 59 (arexpextra -> - term arexpextra .)
    EQEQ            reduce using rule 59 (arexpextra -> - term arexpextra .)
    DIFF            reduce using rule 59 (arexpextra -> - term arexpextra .)
    AND             reduce using rule 59 (arexpextra -> - term arexpextra .)
    <               reduce using rule 59 (arexpextra -> - term arexpextra .)
    LOETHAN         reduce using rule 59 (arexpextra -> - term arexpextra .)
    >               reduce using rule 59 (arexpextra -> - term arexpextra .)
    GOETHAN         reduce using rule 59 (arexpextra -> - term arexpextra .)
    ;               reduce using rule 59 (arexpextra -> - term arexpextra .)
    )               reduce using rule 59 (arexpextra -> - term arexpextra .)
    ,               reduce using rule 59 (arexpextra -> - term arexpextra .)


state 156

    (60) arexpextra -> + term arexpextra .
    OR              reduce using rule 60 (arexpextra -> + term arexpextra .)
    EQEQ            reduce using rule 60 (arexpextra -> + term arexpextra .)
    DIFF            reduce using rule 60 (arexpextra -> + term arexpextra .)
    AND             reduce using rule 60 (arexpextra -> + term arexpextra .)
    <               reduce using rule 60 (arexpextra -> + term arexpextra .)
    LOETHAN         reduce using rule 60 (arexpextra -> + term arexpextra .)
    >               reduce using rule 60 (arexpextra -> + term arexpextra .)
    GOETHAN         reduce using rule 60 (arexpextra -> + term arexpextra .)
    ;               reduce using rule 60 (arexpextra -> + term arexpextra .)
    )               reduce using rule 60 (arexpextra -> + term arexpextra .)
    ,               reduce using rule 60 (arexpextra -> + term arexpextra .)


state 157

    (64) termx -> / factor termx .
    -               reduce using rule 64 (termx -> / factor termx .)
    +               reduce using rule 64 (termx -> / factor termx .)
    OR              reduce using rule 64 (termx -> / factor termx .)
    EQEQ            reduce using rule 64 (termx -> / factor termx .)
    DIFF            reduce using rule 64 (termx -> / factor termx .)
    AND             reduce using rule 64 (termx -> / factor termx .)
    <               reduce using rule 64 (termx -> / factor termx .)
    LOETHAN         reduce using rule 64 (termx -> / factor termx .)
    >               reduce using rule 64 (termx -> / factor termx .)
    GOETHAN         reduce using rule 64 (termx -> / factor termx .)
    ;               reduce using rule 64 (termx -> / factor termx .)
    )               reduce using rule 64 (termx -> / factor termx .)
    ,               reduce using rule 64 (termx -> / factor termx .)


state 158

    (65) termx -> * factor termx .
    -               reduce using rule 65 (termx -> * factor termx .)
    +               reduce using rule 65 (termx -> * factor termx .)
    OR              reduce using rule 65 (termx -> * factor termx .)
    EQEQ            reduce using rule 65 (termx -> * factor termx .)
    DIFF            reduce using rule 65 (termx -> * factor termx .)
    AND             reduce using rule 65 (termx -> * factor termx .)
    <               reduce using rule 65 (termx -> * factor termx .)
    LOETHAN         reduce using rule 65 (termx -> * factor termx .)
    >               reduce using rule 65 (termx -> * factor termx .)
    GOETHAN         reduce using rule 65 (termx -> * factor termx .)
    ;               reduce using rule 65 (termx -> * factor termx .)
    )               reduce using rule 65 (termx -> * factor termx .)
    ,               reduce using rule 65 (termx -> * factor termx .)


state 159

    (13) functions -> datatype FUNC ID ( params ) store_funcv store_params store_init_quad { vars store_local_vars funcontent } close_func . functions
    (13) functions -> . datatype FUNC ID ( params ) store_funcv store_params store_init_quad { vars store_local_vars funcontent } close_func functions
    (14) functions -> .
    (82) datatype -> . D_BOOL
    (83) datatype -> . D_STRING
    (84) datatype -> . D_FLOAT
    (85) datatype -> . D_INT
    VAR             reduce using rule 14 (functions -> .)
    FUNC            reduce using rule 14 (functions -> .)
    D_BOOL          shift and go to state 10
    D_STRING        shift and go to state 11
    D_FLOAT         shift and go to state 12
    D_INT           shift and go to state 13

    datatype                       shift and go to state 15
    functions                      shift and go to state 169

state 160

    (68) factor -> ( store_op expr ) store_op .
    /               reduce using rule 68 (factor -> ( store_op expr ) store_op .)
    *               reduce using rule 68 (factor -> ( store_op expr ) store_op .)
    -               reduce using rule 68 (factor -> ( store_op expr ) store_op .)
    +               reduce using rule 68 (factor -> ( store_op expr ) store_op .)
    OR              reduce using rule 68 (factor -> ( store_op expr ) store_op .)
    EQEQ            reduce using rule 68 (factor -> ( store_op expr ) store_op .)
    DIFF            reduce using rule 68 (factor -> ( store_op expr ) store_op .)
    AND             reduce using rule 68 (factor -> ( store_op expr ) store_op .)
    <               reduce using rule 68 (factor -> ( store_op expr ) store_op .)
    LOETHAN         reduce using rule 68 (factor -> ( store_op expr ) store_op .)
    >               reduce using rule 68 (factor -> ( store_op expr ) store_op .)
    GOETHAN         reduce using rule 68 (factor -> ( store_op expr ) store_op .)
    ;               reduce using rule 68 (factor -> ( store_op expr ) store_op .)
    )               reduce using rule 68 (factor -> ( store_op expr ) store_op .)
    ,               reduce using rule 68 (factor -> ( store_op expr ) store_op .)


state 161

    (42) loop -> WHILE store_jump ( expr ) . store_gotof { loopcont } end_loop
    (106) store_gotof -> .
    {               reduce using rule 106 (store_gotof -> .)

    store_gotof                    shift and go to state 170

state 162

    (41) input -> INPUT ( ID store_oper ) . ;
    ;               shift and go to state 171


state 163

    (32) var_assign -> ID store_oper = expr ; .
    WHILE           reduce using rule 32 (var_assign -> ID store_oper = expr ; .)
    INPUT           reduce using rule 32 (var_assign -> ID store_oper = expr ; .)
    OUTPUT          reduce using rule 32 (var_assign -> ID store_oper = expr ; .)
    IF              reduce using rule 32 (var_assign -> ID store_oper = expr ; .)
    RETURN          reduce using rule 32 (var_assign -> ID store_oper = expr ; .)
    ID              reduce using rule 32 (var_assign -> ID store_oper = expr ; .)
    FLOAT           reduce using rule 32 (var_assign -> ID store_oper = expr ; .)
    (               reduce using rule 32 (var_assign -> ID store_oper = expr ; .)
    INT             reduce using rule 32 (var_assign -> ID store_oper = expr ; .)
    FALSE           reduce using rule 32 (var_assign -> ID store_oper = expr ; .)
    TRUE            reduce using rule 32 (var_assign -> ID store_oper = expr ; .)
    }               reduce using rule 32 (var_assign -> ID store_oper = expr ; .)


state 164

    (77) callfunc -> ID verify_func add_fstack ( callfuncpar . ver_params ) end_fstack store_gosub
    (101) ver_params -> .
    )               reduce using rule 101 (ver_params -> .)

    ver_params                     shift and go to state 172

state 165

    (79) callfuncpar -> expr . store_pquad callfuncparx
    (100) store_pquad -> .
    ,               reduce using rule 100 (store_pquad -> .)
    )               reduce using rule 100 (store_pquad -> .)

    store_pquad                    shift and go to state 173

state 166

    (38) output -> OUTPUT ( expr outex ) . ;
    ;               shift and go to state 174


state 167

    (40) outex -> , expr . outex
    (39) outex -> .
    (40) outex -> . , expr outex
    )               reduce using rule 39 (outex -> .)
    ,               shift and go to state 153

    outex                          shift and go to state 175

state 168

    (34) ifelse -> IF ( expr ) store_gotof . { ifelsecont } store_endif
    (35) ifelse -> IF ( expr ) store_gotof . { ifelsecont } ELSE store_goto { ifelsecont } store_endif
    {               shift and go to state 176


state 169

    (13) functions -> datatype FUNC ID ( params ) store_funcv store_params store_init_quad { vars store_local_vars funcontent } close_func functions .
    VAR             reduce using rule 13 (functions -> datatype FUNC ID ( params ) store_funcv store_params store_init_quad { vars store_local_vars funcontent } close_func functions .)
    FUNC            reduce using rule 13 (functions -> datatype FUNC ID ( params ) store_funcv store_params store_init_quad { vars store_local_vars funcontent } close_func functions .)


state 170

    (42) loop -> WHILE store_jump ( expr ) store_gotof . { loopcont } end_loop
    {               shift and go to state 177


state 171

    (41) input -> INPUT ( ID store_oper ) ; .
    WHILE           reduce using rule 41 (input -> INPUT ( ID store_oper ) ; .)
    INPUT           reduce using rule 41 (input -> INPUT ( ID store_oper ) ; .)
    OUTPUT          reduce using rule 41 (input -> INPUT ( ID store_oper ) ; .)
    IF              reduce using rule 41 (input -> INPUT ( ID store_oper ) ; .)
    RETURN          reduce using rule 41 (input -> INPUT ( ID store_oper ) ; .)
    ID              reduce using rule 41 (input -> INPUT ( ID store_oper ) ; .)
    FLOAT           reduce using rule 41 (input -> INPUT ( ID store_oper ) ; .)
    (               reduce using rule 41 (input -> INPUT ( ID store_oper ) ; .)
    INT             reduce using rule 41 (input -> INPUT ( ID store_oper ) ; .)
    FALSE           reduce using rule 41 (input -> INPUT ( ID store_oper ) ; .)
    TRUE            reduce using rule 41 (input -> INPUT ( ID store_oper ) ; .)
    }               reduce using rule 41 (input -> INPUT ( ID store_oper ) ; .)


state 172

    (77) callfunc -> ID verify_func add_fstack ( callfuncpar ver_params . ) end_fstack store_gosub
    )               shift and go to state 178


state 173

    (79) callfuncpar -> expr store_pquad . callfuncparx
    (80) callfuncparx -> .
    (81) callfuncparx -> . , callfuncpar
    )               reduce using rule 80 (callfuncparx -> .)
    ,               shift and go to state 180

    callfuncparx                   shift and go to state 179

state 174

    (38) output -> OUTPUT ( expr outex ) ; .
    WHILE           reduce using rule 38 (output -> OUTPUT ( expr outex ) ; .)
    INPUT           reduce using rule 38 (output -> OUTPUT ( expr outex ) ; .)
    OUTPUT          reduce using rule 38 (output -> OUTPUT ( expr outex ) ; .)
    IF              reduce using rule 38 (output -> OUTPUT ( expr outex ) ; .)
    RETURN          reduce using rule 38 (output -> OUTPUT ( expr outex ) ; .)
    ID              reduce using rule 38 (output -> OUTPUT ( expr outex ) ; .)
    FLOAT           reduce using rule 38 (output -> OUTPUT ( expr outex ) ; .)
    (               reduce using rule 38 (output -> OUTPUT ( expr outex ) ; .)
    INT             reduce using rule 38 (output -> OUTPUT ( expr outex ) ; .)
    FALSE           reduce using rule 38 (output -> OUTPUT ( expr outex ) ; .)
    TRUE            reduce using rule 38 (output -> OUTPUT ( expr outex ) ; .)
    }               reduce using rule 38 (output -> OUTPUT ( expr outex ) ; .)


state 175

    (40) outex -> , expr outex .
    )               reduce using rule 40 (outex -> , expr outex .)


state 176

    (34) ifelse -> IF ( expr ) store_gotof { . ifelsecont } store_endif
    (35) ifelse -> IF ( expr ) store_gotof { . ifelsecont } ELSE store_goto { ifelsecont } store_endif
    (36) ifelsecont -> .
    (37) ifelsecont -> . statement ifelsecont
    (23) statement -> . loop unload_pv
    (24) statement -> . input unload_pv
    (25) statement -> . output unload_pv
    (26) statement -> . ifelse unload_pv
    (27) statement -> . returns unload_pv ;
    (28) statement -> . expr ;
    (29) statement -> . var_assign unload_pv
    (30) statement -> . statement statement
    (31) statement -> .
    (42) loop -> . WHILE store_jump ( expr ) store_gotof { loopcont } end_loop
    (41) input -> . INPUT ( ID store_oper ) ;
    (38) output -> . OUTPUT ( expr outex ) ;
    (34) ifelse -> . IF ( expr ) store_gotof { ifelsecont } store_endif
    (35) ifelse -> . IF ( expr ) store_gotof { ifelsecont } ELSE store_goto { ifelsecont } store_endif
    (33) returns -> . RETURN expr store_rquad
    (45) expr -> . arexp arexpx
    (32) var_assign -> . ID store_oper = expr ;
    (56) arexp -> . term arexpextra
    (57) arexp -> . term
    (61) term -> . factor termx
    (62) term -> . factor
    (66) factor -> . FLOAT store_const
    (67) factor -> . element
    (68) factor -> . ( store_op expr ) store_op
    (69) element -> . callfunc store_oper
    (70) element -> . compound store_oper
    (71) element -> . const store_const
    (77) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (72) compound -> . compoundx
    (74) const -> . INT
    (75) const -> . FALSE store_const
    (76) const -> . TRUE store_const
    (73) compoundx -> . ID store_oper
  ! reduce/reduce conflict for } resolved using rule 31 (statement -> .)
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for OUTPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    }               reduce using rule 31 (statement -> .)
    WHILE           shift and go to state 61
    INPUT           shift and go to state 62
    OUTPUT          shift and go to state 64
    IF              shift and go to state 65
    RETURN          shift and go to state 66
    ID              shift and go to state 63
    FLOAT           shift and go to state 70
    (               shift and go to state 51
    INT             shift and go to state 76
    FALSE           shift and go to state 77
    TRUE            shift and go to state 78

    expr                           shift and go to state 59
    ifelsecont                     shift and go to state 181
    statement                      shift and go to state 182
    loop                           shift and go to state 54
    input                          shift and go to state 55
    output                         shift and go to state 56
    ifelse                         shift and go to state 57
    returns                        shift and go to state 58
    var_assign                     shift and go to state 60
    arexp                          shift and go to state 67
    term                           shift and go to state 68
    factor                         shift and go to state 69
    element                        shift and go to state 71
    callfunc                       shift and go to state 72
    compound                       shift and go to state 73
    const                          shift and go to state 74
    compoundx                      shift and go to state 75

state 177

    (42) loop -> WHILE store_jump ( expr ) store_gotof { . loopcont } end_loop
    (43) loopcont -> .
    (44) loopcont -> . statement loopcont
    (23) statement -> . loop unload_pv
    (24) statement -> . input unload_pv
    (25) statement -> . output unload_pv
    (26) statement -> . ifelse unload_pv
    (27) statement -> . returns unload_pv ;
    (28) statement -> . expr ;
    (29) statement -> . var_assign unload_pv
    (30) statement -> . statement statement
    (31) statement -> .
    (42) loop -> . WHILE store_jump ( expr ) store_gotof { loopcont } end_loop
    (41) input -> . INPUT ( ID store_oper ) ;
    (38) output -> . OUTPUT ( expr outex ) ;
    (34) ifelse -> . IF ( expr ) store_gotof { ifelsecont } store_endif
    (35) ifelse -> . IF ( expr ) store_gotof { ifelsecont } ELSE store_goto { ifelsecont } store_endif
    (33) returns -> . RETURN expr store_rquad
    (45) expr -> . arexp arexpx
    (32) var_assign -> . ID store_oper = expr ;
    (56) arexp -> . term arexpextra
    (57) arexp -> . term
    (61) term -> . factor termx
    (62) term -> . factor
    (66) factor -> . FLOAT store_const
    (67) factor -> . element
    (68) factor -> . ( store_op expr ) store_op
    (69) element -> . callfunc store_oper
    (70) element -> . compound store_oper
    (71) element -> . const store_const
    (77) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (72) compound -> . compoundx
    (74) const -> . INT
    (75) const -> . FALSE store_const
    (76) const -> . TRUE store_const
    (73) compoundx -> . ID store_oper
  ! reduce/reduce conflict for } resolved using rule 31 (statement -> .)
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for OUTPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    }               reduce using rule 31 (statement -> .)
    WHILE           shift and go to state 61
    INPUT           shift and go to state 62
    OUTPUT          shift and go to state 64
    IF              shift and go to state 65
    RETURN          shift and go to state 66
    ID              shift and go to state 63
    FLOAT           shift and go to state 70
    (               shift and go to state 51
    INT             shift and go to state 76
    FALSE           shift and go to state 77
    TRUE            shift and go to state 78

    expr                           shift and go to state 59
    loopcont                       shift and go to state 183
    statement                      shift and go to state 184
    loop                           shift and go to state 54
    input                          shift and go to state 55
    output                         shift and go to state 56
    ifelse                         shift and go to state 57
    returns                        shift and go to state 58
    var_assign                     shift and go to state 60
    arexp                          shift and go to state 67
    term                           shift and go to state 68
    factor                         shift and go to state 69
    element                        shift and go to state 71
    callfunc                       shift and go to state 72
    compound                       shift and go to state 73
    const                          shift and go to state 74
    compoundx                      shift and go to state 75

state 178

    (77) callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) . end_fstack store_gosub
    (104) end_fstack -> .
    /               reduce using rule 104 (end_fstack -> .)
    *               reduce using rule 104 (end_fstack -> .)
    -               reduce using rule 104 (end_fstack -> .)
    +               reduce using rule 104 (end_fstack -> .)
    OR              reduce using rule 104 (end_fstack -> .)
    EQEQ            reduce using rule 104 (end_fstack -> .)
    DIFF            reduce using rule 104 (end_fstack -> .)
    AND             reduce using rule 104 (end_fstack -> .)
    <               reduce using rule 104 (end_fstack -> .)
    LOETHAN         reduce using rule 104 (end_fstack -> .)
    >               reduce using rule 104 (end_fstack -> .)
    GOETHAN         reduce using rule 104 (end_fstack -> .)
    ;               reduce using rule 104 (end_fstack -> .)
    )               reduce using rule 104 (end_fstack -> .)
    ,               reduce using rule 104 (end_fstack -> .)

    end_fstack                     shift and go to state 185

state 179

    (79) callfuncpar -> expr store_pquad callfuncparx .
    )               reduce using rule 79 (callfuncpar -> expr store_pquad callfuncparx .)


state 180

    (81) callfuncparx -> , . callfuncpar
    (78) callfuncpar -> .
    (79) callfuncpar -> . expr store_pquad callfuncparx
    (45) expr -> . arexp arexpx
    (56) arexp -> . term arexpextra
    (57) arexp -> . term
    (61) term -> . factor termx
    (62) term -> . factor
    (66) factor -> . FLOAT store_const
    (67) factor -> . element
    (68) factor -> . ( store_op expr ) store_op
    (69) element -> . callfunc store_oper
    (70) element -> . compound store_oper
    (71) element -> . const store_const
    (77) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (72) compound -> . compoundx
    (74) const -> . INT
    (75) const -> . FALSE store_const
    (76) const -> . TRUE store_const
    (73) compoundx -> . ID store_oper
    )               reduce using rule 78 (callfuncpar -> .)
    FLOAT           shift and go to state 70
    (               shift and go to state 51
    ID              shift and go to state 100
    INT             shift and go to state 76
    FALSE           shift and go to state 77
    TRUE            shift and go to state 78

    callfuncpar                    shift and go to state 186
    expr                           shift and go to state 165
    arexp                          shift and go to state 67
    term                           shift and go to state 68
    factor                         shift and go to state 69
    element                        shift and go to state 71
    callfunc                       shift and go to state 72
    compound                       shift and go to state 73
    const                          shift and go to state 74
    compoundx                      shift and go to state 75

state 181

    (34) ifelse -> IF ( expr ) store_gotof { ifelsecont . } store_endif
    (35) ifelse -> IF ( expr ) store_gotof { ifelsecont . } ELSE store_goto { ifelsecont } store_endif
    }               shift and go to state 187


state 182

    (37) ifelsecont -> statement . ifelsecont
    (30) statement -> statement . statement
    (36) ifelsecont -> .
    (37) ifelsecont -> . statement ifelsecont
    (23) statement -> . loop unload_pv
    (24) statement -> . input unload_pv
    (25) statement -> . output unload_pv
    (26) statement -> . ifelse unload_pv
    (27) statement -> . returns unload_pv ;
    (28) statement -> . expr ;
    (29) statement -> . var_assign unload_pv
    (30) statement -> . statement statement
    (31) statement -> .
    (42) loop -> . WHILE store_jump ( expr ) store_gotof { loopcont } end_loop
    (41) input -> . INPUT ( ID store_oper ) ;
    (38) output -> . OUTPUT ( expr outex ) ;
    (34) ifelse -> . IF ( expr ) store_gotof { ifelsecont } store_endif
    (35) ifelse -> . IF ( expr ) store_gotof { ifelsecont } ELSE store_goto { ifelsecont } store_endif
    (33) returns -> . RETURN expr store_rquad
    (45) expr -> . arexp arexpx
    (32) var_assign -> . ID store_oper = expr ;
    (56) arexp -> . term arexpextra
    (57) arexp -> . term
    (61) term -> . factor termx
    (62) term -> . factor
    (66) factor -> . FLOAT store_const
    (67) factor -> . element
    (68) factor -> . ( store_op expr ) store_op
    (69) element -> . callfunc store_oper
    (70) element -> . compound store_oper
    (71) element -> . const store_const
    (77) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (72) compound -> . compoundx
    (74) const -> . INT
    (75) const -> . FALSE store_const
    (76) const -> . TRUE store_const
    (73) compoundx -> . ID store_oper
  ! reduce/reduce conflict for } resolved using rule 31 (statement -> .)
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for OUTPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    }               reduce using rule 31 (statement -> .)
    WHILE           shift and go to state 61
    INPUT           shift and go to state 62
    OUTPUT          shift and go to state 64
    IF              shift and go to state 65
    RETURN          shift and go to state 66
    ID              shift and go to state 63
    FLOAT           shift and go to state 70
    (               shift and go to state 51
    INT             shift and go to state 76
    FALSE           shift and go to state 77
    TRUE            shift and go to state 78

    statement                      shift and go to state 188
    ifelsecont                     shift and go to state 189
    loop                           shift and go to state 54
    input                          shift and go to state 55
    output                         shift and go to state 56
    ifelse                         shift and go to state 57
    returns                        shift and go to state 58
    expr                           shift and go to state 59
    var_assign                     shift and go to state 60
    arexp                          shift and go to state 67
    term                           shift and go to state 68
    factor                         shift and go to state 69
    element                        shift and go to state 71
    callfunc                       shift and go to state 72
    compound                       shift and go to state 73
    const                          shift and go to state 74
    compoundx                      shift and go to state 75

state 183

    (42) loop -> WHILE store_jump ( expr ) store_gotof { loopcont . } end_loop
    }               shift and go to state 190


state 184

    (44) loopcont -> statement . loopcont
    (30) statement -> statement . statement
    (43) loopcont -> .
    (44) loopcont -> . statement loopcont
    (23) statement -> . loop unload_pv
    (24) statement -> . input unload_pv
    (25) statement -> . output unload_pv
    (26) statement -> . ifelse unload_pv
    (27) statement -> . returns unload_pv ;
    (28) statement -> . expr ;
    (29) statement -> . var_assign unload_pv
    (30) statement -> . statement statement
    (31) statement -> .
    (42) loop -> . WHILE store_jump ( expr ) store_gotof { loopcont } end_loop
    (41) input -> . INPUT ( ID store_oper ) ;
    (38) output -> . OUTPUT ( expr outex ) ;
    (34) ifelse -> . IF ( expr ) store_gotof { ifelsecont } store_endif
    (35) ifelse -> . IF ( expr ) store_gotof { ifelsecont } ELSE store_goto { ifelsecont } store_endif
    (33) returns -> . RETURN expr store_rquad
    (45) expr -> . arexp arexpx
    (32) var_assign -> . ID store_oper = expr ;
    (56) arexp -> . term arexpextra
    (57) arexp -> . term
    (61) term -> . factor termx
    (62) term -> . factor
    (66) factor -> . FLOAT store_const
    (67) factor -> . element
    (68) factor -> . ( store_op expr ) store_op
    (69) element -> . callfunc store_oper
    (70) element -> . compound store_oper
    (71) element -> . const store_const
    (77) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (72) compound -> . compoundx
    (74) const -> . INT
    (75) const -> . FALSE store_const
    (76) const -> . TRUE store_const
    (73) compoundx -> . ID store_oper
  ! reduce/reduce conflict for } resolved using rule 31 (statement -> .)
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for OUTPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    }               reduce using rule 31 (statement -> .)
    WHILE           shift and go to state 61
    INPUT           shift and go to state 62
    OUTPUT          shift and go to state 64
    IF              shift and go to state 65
    RETURN          shift and go to state 66
    ID              shift and go to state 63
    FLOAT           shift and go to state 70
    (               shift and go to state 51
    INT             shift and go to state 76
    FALSE           shift and go to state 77
    TRUE            shift and go to state 78

    statement                      shift and go to state 191
    loopcont                       shift and go to state 192
    loop                           shift and go to state 54
    input                          shift and go to state 55
    output                         shift and go to state 56
    ifelse                         shift and go to state 57
    returns                        shift and go to state 58
    expr                           shift and go to state 59
    var_assign                     shift and go to state 60
    arexp                          shift and go to state 67
    term                           shift and go to state 68
    factor                         shift and go to state 69
    element                        shift and go to state 71
    callfunc                       shift and go to state 72
    compound                       shift and go to state 73
    const                          shift and go to state 74
    compoundx                      shift and go to state 75

state 185

    (77) callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack . store_gosub
    (105) store_gosub -> .
    /               reduce using rule 105 (store_gosub -> .)
    *               reduce using rule 105 (store_gosub -> .)
    -               reduce using rule 105 (store_gosub -> .)
    +               reduce using rule 105 (store_gosub -> .)
    OR              reduce using rule 105 (store_gosub -> .)
    EQEQ            reduce using rule 105 (store_gosub -> .)
    DIFF            reduce using rule 105 (store_gosub -> .)
    AND             reduce using rule 105 (store_gosub -> .)
    <               reduce using rule 105 (store_gosub -> .)
    LOETHAN         reduce using rule 105 (store_gosub -> .)
    >               reduce using rule 105 (store_gosub -> .)
    GOETHAN         reduce using rule 105 (store_gosub -> .)
    ;               reduce using rule 105 (store_gosub -> .)
    )               reduce using rule 105 (store_gosub -> .)
    ,               reduce using rule 105 (store_gosub -> .)

    store_gosub                    shift and go to state 193

state 186

    (81) callfuncparx -> , callfuncpar .
    )               reduce using rule 81 (callfuncparx -> , callfuncpar .)


state 187

    (34) ifelse -> IF ( expr ) store_gotof { ifelsecont } . store_endif
    (35) ifelse -> IF ( expr ) store_gotof { ifelsecont } . ELSE store_goto { ifelsecont } store_endif
    (99) store_endif -> .
    ELSE            shift and go to state 195
    WHILE           reduce using rule 99 (store_endif -> .)
    INPUT           reduce using rule 99 (store_endif -> .)
    OUTPUT          reduce using rule 99 (store_endif -> .)
    IF              reduce using rule 99 (store_endif -> .)
    RETURN          reduce using rule 99 (store_endif -> .)
    ID              reduce using rule 99 (store_endif -> .)
    FLOAT           reduce using rule 99 (store_endif -> .)
    (               reduce using rule 99 (store_endif -> .)
    INT             reduce using rule 99 (store_endif -> .)
    FALSE           reduce using rule 99 (store_endif -> .)
    TRUE            reduce using rule 99 (store_endif -> .)
    }               reduce using rule 99 (store_endif -> .)

    store_endif                    shift and go to state 194

state 188

    (30) statement -> statement statement .
    (37) ifelsecont -> statement . ifelsecont
    (30) statement -> statement . statement
    (36) ifelsecont -> .
    (37) ifelsecont -> . statement ifelsecont
    (23) statement -> . loop unload_pv
    (24) statement -> . input unload_pv
    (25) statement -> . output unload_pv
    (26) statement -> . ifelse unload_pv
    (27) statement -> . returns unload_pv ;
    (28) statement -> . expr ;
    (29) statement -> . var_assign unload_pv
    (30) statement -> . statement statement
    (31) statement -> .
    (42) loop -> . WHILE store_jump ( expr ) store_gotof { loopcont } end_loop
    (41) input -> . INPUT ( ID store_oper ) ;
    (38) output -> . OUTPUT ( expr outex ) ;
    (34) ifelse -> . IF ( expr ) store_gotof { ifelsecont } store_endif
    (35) ifelse -> . IF ( expr ) store_gotof { ifelsecont } ELSE store_goto { ifelsecont } store_endif
    (33) returns -> . RETURN expr store_rquad
    (45) expr -> . arexp arexpx
    (32) var_assign -> . ID store_oper = expr ;
    (56) arexp -> . term arexpextra
    (57) arexp -> . term
    (61) term -> . factor termx
    (62) term -> . factor
    (66) factor -> . FLOAT store_const
    (67) factor -> . element
    (68) factor -> . ( store_op expr ) store_op
    (69) element -> . callfunc store_oper
    (70) element -> . compound store_oper
    (71) element -> . const store_const
    (77) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (72) compound -> . compoundx
    (74) const -> . INT
    (75) const -> . FALSE store_const
    (76) const -> . TRUE store_const
    (73) compoundx -> . ID store_oper
  ! reduce/reduce conflict for } resolved using rule 30 (statement -> statement statement .)
  ! reduce/reduce conflict for WHILE resolved using rule 31 (statement -> .)
  ! reduce/reduce conflict for INPUT resolved using rule 31 (statement -> .)
  ! reduce/reduce conflict for OUTPUT resolved using rule 31 (statement -> .)
  ! reduce/reduce conflict for IF resolved using rule 31 (statement -> .)
  ! reduce/reduce conflict for RETURN resolved using rule 31 (statement -> .)
  ! reduce/reduce conflict for ID resolved using rule 31 (statement -> .)
  ! reduce/reduce conflict for FLOAT resolved using rule 31 (statement -> .)
  ! reduce/reduce conflict for ( resolved using rule 31 (statement -> .)
  ! reduce/reduce conflict for INT resolved using rule 31 (statement -> .)
  ! reduce/reduce conflict for FALSE resolved using rule 31 (statement -> .)
  ! reduce/reduce conflict for TRUE resolved using rule 31 (statement -> .)
  ! reduce/reduce conflict for } resolved using rule 31 (statement -> .)
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for OUTPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    }               reduce using rule 31 (statement -> .)
    WHILE           shift and go to state 61
    INPUT           shift and go to state 62
    OUTPUT          shift and go to state 64
    IF              shift and go to state 65
    RETURN          shift and go to state 66
    ID              shift and go to state 63
    FLOAT           shift and go to state 70
    (               shift and go to state 51
    INT             shift and go to state 76
    FALSE           shift and go to state 77
    TRUE            shift and go to state 78

    statement                      shift and go to state 188
    ifelsecont                     shift and go to state 189
    loop                           shift and go to state 54
    input                          shift and go to state 55
    output                         shift and go to state 56
    ifelse                         shift and go to state 57
    returns                        shift and go to state 58
    expr                           shift and go to state 59
    var_assign                     shift and go to state 60
    arexp                          shift and go to state 67
    term                           shift and go to state 68
    factor                         shift and go to state 69
    element                        shift and go to state 71
    callfunc                       shift and go to state 72
    compound                       shift and go to state 73
    const                          shift and go to state 74
    compoundx                      shift and go to state 75

state 189

    (37) ifelsecont -> statement ifelsecont .
    }               reduce using rule 37 (ifelsecont -> statement ifelsecont .)


state 190

    (42) loop -> WHILE store_jump ( expr ) store_gotof { loopcont } . end_loop
    (109) end_loop -> .
    WHILE           reduce using rule 109 (end_loop -> .)
    INPUT           reduce using rule 109 (end_loop -> .)
    OUTPUT          reduce using rule 109 (end_loop -> .)
    IF              reduce using rule 109 (end_loop -> .)
    RETURN          reduce using rule 109 (end_loop -> .)
    ID              reduce using rule 109 (end_loop -> .)
    FLOAT           reduce using rule 109 (end_loop -> .)
    (               reduce using rule 109 (end_loop -> .)
    INT             reduce using rule 109 (end_loop -> .)
    FALSE           reduce using rule 109 (end_loop -> .)
    TRUE            reduce using rule 109 (end_loop -> .)
    }               reduce using rule 109 (end_loop -> .)

    end_loop                       shift and go to state 196

state 191

    (30) statement -> statement statement .
    (44) loopcont -> statement . loopcont
    (30) statement -> statement . statement
    (43) loopcont -> .
    (44) loopcont -> . statement loopcont
    (23) statement -> . loop unload_pv
    (24) statement -> . input unload_pv
    (25) statement -> . output unload_pv
    (26) statement -> . ifelse unload_pv
    (27) statement -> . returns unload_pv ;
    (28) statement -> . expr ;
    (29) statement -> . var_assign unload_pv
    (30) statement -> . statement statement
    (31) statement -> .
    (42) loop -> . WHILE store_jump ( expr ) store_gotof { loopcont } end_loop
    (41) input -> . INPUT ( ID store_oper ) ;
    (38) output -> . OUTPUT ( expr outex ) ;
    (34) ifelse -> . IF ( expr ) store_gotof { ifelsecont } store_endif
    (35) ifelse -> . IF ( expr ) store_gotof { ifelsecont } ELSE store_goto { ifelsecont } store_endif
    (33) returns -> . RETURN expr store_rquad
    (45) expr -> . arexp arexpx
    (32) var_assign -> . ID store_oper = expr ;
    (56) arexp -> . term arexpextra
    (57) arexp -> . term
    (61) term -> . factor termx
    (62) term -> . factor
    (66) factor -> . FLOAT store_const
    (67) factor -> . element
    (68) factor -> . ( store_op expr ) store_op
    (69) element -> . callfunc store_oper
    (70) element -> . compound store_oper
    (71) element -> . const store_const
    (77) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (72) compound -> . compoundx
    (74) const -> . INT
    (75) const -> . FALSE store_const
    (76) const -> . TRUE store_const
    (73) compoundx -> . ID store_oper
  ! reduce/reduce conflict for } resolved using rule 30 (statement -> statement statement .)
  ! reduce/reduce conflict for WHILE resolved using rule 31 (statement -> .)
  ! reduce/reduce conflict for INPUT resolved using rule 31 (statement -> .)
  ! reduce/reduce conflict for OUTPUT resolved using rule 31 (statement -> .)
  ! reduce/reduce conflict for IF resolved using rule 31 (statement -> .)
  ! reduce/reduce conflict for RETURN resolved using rule 31 (statement -> .)
  ! reduce/reduce conflict for ID resolved using rule 31 (statement -> .)
  ! reduce/reduce conflict for FLOAT resolved using rule 31 (statement -> .)
  ! reduce/reduce conflict for ( resolved using rule 31 (statement -> .)
  ! reduce/reduce conflict for INT resolved using rule 31 (statement -> .)
  ! reduce/reduce conflict for FALSE resolved using rule 31 (statement -> .)
  ! reduce/reduce conflict for TRUE resolved using rule 31 (statement -> .)
  ! reduce/reduce conflict for } resolved using rule 31 (statement -> .)
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for OUTPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    }               reduce using rule 31 (statement -> .)
    WHILE           shift and go to state 61
    INPUT           shift and go to state 62
    OUTPUT          shift and go to state 64
    IF              shift and go to state 65
    RETURN          shift and go to state 66
    ID              shift and go to state 63
    FLOAT           shift and go to state 70
    (               shift and go to state 51
    INT             shift and go to state 76
    FALSE           shift and go to state 77
    TRUE            shift and go to state 78

    statement                      shift and go to state 191
    loopcont                       shift and go to state 192
    loop                           shift and go to state 54
    input                          shift and go to state 55
    output                         shift and go to state 56
    ifelse                         shift and go to state 57
    returns                        shift and go to state 58
    expr                           shift and go to state 59
    var_assign                     shift and go to state 60
    arexp                          shift and go to state 67
    term                           shift and go to state 68
    factor                         shift and go to state 69
    element                        shift and go to state 71
    callfunc                       shift and go to state 72
    compound                       shift and go to state 73
    const                          shift and go to state 74
    compoundx                      shift and go to state 75

state 192

    (44) loopcont -> statement loopcont .
    }               reduce using rule 44 (loopcont -> statement loopcont .)


state 193

    (77) callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub .
    /               reduce using rule 77 (callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub .)
    *               reduce using rule 77 (callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub .)
    -               reduce using rule 77 (callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub .)
    +               reduce using rule 77 (callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub .)
    OR              reduce using rule 77 (callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub .)
    EQEQ            reduce using rule 77 (callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub .)
    DIFF            reduce using rule 77 (callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub .)
    AND             reduce using rule 77 (callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub .)
    <               reduce using rule 77 (callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub .)
    LOETHAN         reduce using rule 77 (callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub .)
    >               reduce using rule 77 (callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub .)
    GOETHAN         reduce using rule 77 (callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub .)
    ;               reduce using rule 77 (callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub .)
    )               reduce using rule 77 (callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub .)
    ,               reduce using rule 77 (callfunc -> ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub .)


state 194

    (34) ifelse -> IF ( expr ) store_gotof { ifelsecont } store_endif .
    WHILE           reduce using rule 34 (ifelse -> IF ( expr ) store_gotof { ifelsecont } store_endif .)
    INPUT           reduce using rule 34 (ifelse -> IF ( expr ) store_gotof { ifelsecont } store_endif .)
    OUTPUT          reduce using rule 34 (ifelse -> IF ( expr ) store_gotof { ifelsecont } store_endif .)
    IF              reduce using rule 34 (ifelse -> IF ( expr ) store_gotof { ifelsecont } store_endif .)
    RETURN          reduce using rule 34 (ifelse -> IF ( expr ) store_gotof { ifelsecont } store_endif .)
    ID              reduce using rule 34 (ifelse -> IF ( expr ) store_gotof { ifelsecont } store_endif .)
    FLOAT           reduce using rule 34 (ifelse -> IF ( expr ) store_gotof { ifelsecont } store_endif .)
    (               reduce using rule 34 (ifelse -> IF ( expr ) store_gotof { ifelsecont } store_endif .)
    INT             reduce using rule 34 (ifelse -> IF ( expr ) store_gotof { ifelsecont } store_endif .)
    FALSE           reduce using rule 34 (ifelse -> IF ( expr ) store_gotof { ifelsecont } store_endif .)
    TRUE            reduce using rule 34 (ifelse -> IF ( expr ) store_gotof { ifelsecont } store_endif .)
    }               reduce using rule 34 (ifelse -> IF ( expr ) store_gotof { ifelsecont } store_endif .)


state 195

    (35) ifelse -> IF ( expr ) store_gotof { ifelsecont } ELSE . store_goto { ifelsecont } store_endif
    (107) store_goto -> .
    {               reduce using rule 107 (store_goto -> .)

    store_goto                     shift and go to state 197

state 196

    (42) loop -> WHILE store_jump ( expr ) store_gotof { loopcont } end_loop .
    WHILE           reduce using rule 42 (loop -> WHILE store_jump ( expr ) store_gotof { loopcont } end_loop .)
    INPUT           reduce using rule 42 (loop -> WHILE store_jump ( expr ) store_gotof { loopcont } end_loop .)
    OUTPUT          reduce using rule 42 (loop -> WHILE store_jump ( expr ) store_gotof { loopcont } end_loop .)
    IF              reduce using rule 42 (loop -> WHILE store_jump ( expr ) store_gotof { loopcont } end_loop .)
    RETURN          reduce using rule 42 (loop -> WHILE store_jump ( expr ) store_gotof { loopcont } end_loop .)
    ID              reduce using rule 42 (loop -> WHILE store_jump ( expr ) store_gotof { loopcont } end_loop .)
    FLOAT           reduce using rule 42 (loop -> WHILE store_jump ( expr ) store_gotof { loopcont } end_loop .)
    (               reduce using rule 42 (loop -> WHILE store_jump ( expr ) store_gotof { loopcont } end_loop .)
    INT             reduce using rule 42 (loop -> WHILE store_jump ( expr ) store_gotof { loopcont } end_loop .)
    FALSE           reduce using rule 42 (loop -> WHILE store_jump ( expr ) store_gotof { loopcont } end_loop .)
    TRUE            reduce using rule 42 (loop -> WHILE store_jump ( expr ) store_gotof { loopcont } end_loop .)
    }               reduce using rule 42 (loop -> WHILE store_jump ( expr ) store_gotof { loopcont } end_loop .)


state 197

    (35) ifelse -> IF ( expr ) store_gotof { ifelsecont } ELSE store_goto . { ifelsecont } store_endif
    {               shift and go to state 198


state 198

    (35) ifelse -> IF ( expr ) store_gotof { ifelsecont } ELSE store_goto { . ifelsecont } store_endif
    (36) ifelsecont -> .
    (37) ifelsecont -> . statement ifelsecont
    (23) statement -> . loop unload_pv
    (24) statement -> . input unload_pv
    (25) statement -> . output unload_pv
    (26) statement -> . ifelse unload_pv
    (27) statement -> . returns unload_pv ;
    (28) statement -> . expr ;
    (29) statement -> . var_assign unload_pv
    (30) statement -> . statement statement
    (31) statement -> .
    (42) loop -> . WHILE store_jump ( expr ) store_gotof { loopcont } end_loop
    (41) input -> . INPUT ( ID store_oper ) ;
    (38) output -> . OUTPUT ( expr outex ) ;
    (34) ifelse -> . IF ( expr ) store_gotof { ifelsecont } store_endif
    (35) ifelse -> . IF ( expr ) store_gotof { ifelsecont } ELSE store_goto { ifelsecont } store_endif
    (33) returns -> . RETURN expr store_rquad
    (45) expr -> . arexp arexpx
    (32) var_assign -> . ID store_oper = expr ;
    (56) arexp -> . term arexpextra
    (57) arexp -> . term
    (61) term -> . factor termx
    (62) term -> . factor
    (66) factor -> . FLOAT store_const
    (67) factor -> . element
    (68) factor -> . ( store_op expr ) store_op
    (69) element -> . callfunc store_oper
    (70) element -> . compound store_oper
    (71) element -> . const store_const
    (77) callfunc -> . ID verify_func add_fstack ( callfuncpar ver_params ) end_fstack store_gosub
    (72) compound -> . compoundx
    (74) const -> . INT
    (75) const -> . FALSE store_const
    (76) const -> . TRUE store_const
    (73) compoundx -> . ID store_oper
  ! reduce/reduce conflict for } resolved using rule 31 (statement -> .)
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for INPUT resolved as shift
  ! shift/reduce conflict for OUTPUT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    }               reduce using rule 31 (statement -> .)
    WHILE           shift and go to state 61
    INPUT           shift and go to state 62
    OUTPUT          shift and go to state 64
    IF              shift and go to state 65
    RETURN          shift and go to state 66
    ID              shift and go to state 63
    FLOAT           shift and go to state 70
    (               shift and go to state 51
    INT             shift and go to state 76
    FALSE           shift and go to state 77
    TRUE            shift and go to state 78

    expr                           shift and go to state 59
    ifelsecont                     shift and go to state 199
    statement                      shift and go to state 182
    loop                           shift and go to state 54
    input                          shift and go to state 55
    output                         shift and go to state 56
    ifelse                         shift and go to state 57
    returns                        shift and go to state 58
    var_assign                     shift and go to state 60
    arexp                          shift and go to state 67
    term                           shift and go to state 68
    factor                         shift and go to state 69
    element                        shift and go to state 71
    callfunc                       shift and go to state 72
    compound                       shift and go to state 73
    const                          shift and go to state 74
    compoundx                      shift and go to state 75

state 199

    (35) ifelse -> IF ( expr ) store_gotof { ifelsecont } ELSE store_goto { ifelsecont . } store_endif
    }               shift and go to state 200


state 200

    (35) ifelse -> IF ( expr ) store_gotof { ifelsecont } ELSE store_goto { ifelsecont } . store_endif
    (99) store_endif -> .
    WHILE           reduce using rule 99 (store_endif -> .)
    INPUT           reduce using rule 99 (store_endif -> .)
    OUTPUT          reduce using rule 99 (store_endif -> .)
    IF              reduce using rule 99 (store_endif -> .)
    RETURN          reduce using rule 99 (store_endif -> .)
    ID              reduce using rule 99 (store_endif -> .)
    FLOAT           reduce using rule 99 (store_endif -> .)
    (               reduce using rule 99 (store_endif -> .)
    INT             reduce using rule 99 (store_endif -> .)
    FALSE           reduce using rule 99 (store_endif -> .)
    TRUE            reduce using rule 99 (store_endif -> .)
    }               reduce using rule 99 (store_endif -> .)

    store_endif                    shift and go to state 201

state 201

    (35) ifelse -> IF ( expr ) store_gotof { ifelsecont } ELSE store_goto { ifelsecont } store_endif .
    WHILE           reduce using rule 35 (ifelse -> IF ( expr ) store_gotof { ifelsecont } ELSE store_goto { ifelsecont } store_endif .)
    INPUT           reduce using rule 35 (ifelse -> IF ( expr ) store_gotof { ifelsecont } ELSE store_goto { ifelsecont } store_endif .)
    OUTPUT          reduce using rule 35 (ifelse -> IF ( expr ) store_gotof { ifelsecont } ELSE store_goto { ifelsecont } store_endif .)
    IF              reduce using rule 35 (ifelse -> IF ( expr ) store_gotof { ifelsecont } ELSE store_goto { ifelsecont } store_endif .)
    RETURN          reduce using rule 35 (ifelse -> IF ( expr ) store_gotof { ifelsecont } ELSE store_goto { ifelsecont } store_endif .)
    ID              reduce using rule 35 (ifelse -> IF ( expr ) store_gotof { ifelsecont } ELSE store_goto { ifelsecont } store_endif .)
    FLOAT           reduce using rule 35 (ifelse -> IF ( expr ) store_gotof { ifelsecont } ELSE store_goto { ifelsecont } store_endif .)
    (               reduce using rule 35 (ifelse -> IF ( expr ) store_gotof { ifelsecont } ELSE store_goto { ifelsecont } store_endif .)
    INT             reduce using rule 35 (ifelse -> IF ( expr ) store_gotof { ifelsecont } ELSE store_goto { ifelsecont } store_endif .)
    FALSE           reduce using rule 35 (ifelse -> IF ( expr ) store_gotof { ifelsecont } ELSE store_goto { ifelsecont } store_endif .)
    TRUE            reduce using rule 35 (ifelse -> IF ( expr ) store_gotof { ifelsecont } ELSE store_goto { ifelsecont } store_endif .)
    }               reduce using rule 35 (ifelse -> IF ( expr ) store_gotof { ifelsecont } ELSE store_goto { ifelsecont } store_endif .)


Conflicts:

shift/reduce conflict for VAR in state 5 resolved as shift
shift/reduce conflict for VAR in state 24 resolved as shift
shift/reduce conflict for WHILE in state 48 resolved as shift
shift/reduce conflict for INPUT in state 48 resolved as shift
shift/reduce conflict for OUTPUT in state 48 resolved as shift
shift/reduce conflict for IF in state 48 resolved as shift
shift/reduce conflict for RETURN in state 48 resolved as shift
shift/reduce conflict for ID in state 48 resolved as shift
shift/reduce conflict for FLOAT in state 48 resolved as shift
shift/reduce conflict for ( in state 48 resolved as shift
shift/reduce conflict for INT in state 48 resolved as shift
shift/reduce conflict for FALSE in state 48 resolved as shift
shift/reduce conflict for TRUE in state 48 resolved as shift
shift/reduce conflict for WHILE in state 53 resolved as shift
shift/reduce conflict for INPUT in state 53 resolved as shift
shift/reduce conflict for OUTPUT in state 53 resolved as shift
shift/reduce conflict for IF in state 53 resolved as shift
shift/reduce conflict for RETURN in state 53 resolved as shift
shift/reduce conflict for ID in state 53 resolved as shift
shift/reduce conflict for FLOAT in state 53 resolved as shift
shift/reduce conflict for ( in state 53 resolved as shift
shift/reduce conflict for INT in state 53 resolved as shift
shift/reduce conflict for FALSE in state 53 resolved as shift
shift/reduce conflict for TRUE in state 53 resolved as shift
shift/reduce conflict for WHILE in state 81 resolved as shift
shift/reduce conflict for INPUT in state 81 resolved as shift
shift/reduce conflict for OUTPUT in state 81 resolved as shift
shift/reduce conflict for IF in state 81 resolved as shift
shift/reduce conflict for RETURN in state 81 resolved as shift
shift/reduce conflict for ID in state 81 resolved as shift
shift/reduce conflict for FLOAT in state 81 resolved as shift
shift/reduce conflict for ( in state 81 resolved as shift
shift/reduce conflict for INT in state 81 resolved as shift
shift/reduce conflict for FALSE in state 81 resolved as shift
shift/reduce conflict for TRUE in state 81 resolved as shift
shift/reduce conflict for WHILE in state 84 resolved as shift
shift/reduce conflict for INPUT in state 84 resolved as shift
shift/reduce conflict for OUTPUT in state 84 resolved as shift
shift/reduce conflict for IF in state 84 resolved as shift
shift/reduce conflict for RETURN in state 84 resolved as shift
shift/reduce conflict for ID in state 84 resolved as shift
shift/reduce conflict for FLOAT in state 84 resolved as shift
shift/reduce conflict for ( in state 84 resolved as shift
shift/reduce conflict for INT in state 84 resolved as shift
shift/reduce conflict for FALSE in state 84 resolved as shift
shift/reduce conflict for TRUE in state 84 resolved as shift
shift/reduce conflict for WHILE in state 126 resolved as shift
shift/reduce conflict for INPUT in state 126 resolved as shift
shift/reduce conflict for OUTPUT in state 126 resolved as shift
shift/reduce conflict for IF in state 126 resolved as shift
shift/reduce conflict for RETURN in state 126 resolved as shift
shift/reduce conflict for ID in state 126 resolved as shift
shift/reduce conflict for FLOAT in state 126 resolved as shift
shift/reduce conflict for ( in state 126 resolved as shift
shift/reduce conflict for INT in state 126 resolved as shift
shift/reduce conflict for FALSE in state 126 resolved as shift
shift/reduce conflict for TRUE in state 126 resolved as shift
shift/reduce conflict for WHILE in state 145 resolved as shift
shift/reduce conflict for INPUT in state 145 resolved as shift
shift/reduce conflict for OUTPUT in state 145 resolved as shift
shift/reduce conflict for IF in state 145 resolved as shift
shift/reduce conflict for RETURN in state 145 resolved as shift
shift/reduce conflict for ID in state 145 resolved as shift
shift/reduce conflict for FLOAT in state 145 resolved as shift
shift/reduce conflict for ( in state 145 resolved as shift
shift/reduce conflict for INT in state 145 resolved as shift
shift/reduce conflict for FALSE in state 145 resolved as shift
shift/reduce conflict for TRUE in state 145 resolved as shift
shift/reduce conflict for WHILE in state 176 resolved as shift
shift/reduce conflict for INPUT in state 176 resolved as shift
shift/reduce conflict for OUTPUT in state 176 resolved as shift
shift/reduce conflict for IF in state 176 resolved as shift
shift/reduce conflict for RETURN in state 176 resolved as shift
shift/reduce conflict for ID in state 176 resolved as shift
shift/reduce conflict for FLOAT in state 176 resolved as shift
shift/reduce conflict for ( in state 176 resolved as shift
shift/reduce conflict for INT in state 176 resolved as shift
shift/reduce conflict for FALSE in state 176 resolved as shift
shift/reduce conflict for TRUE in state 176 resolved as shift
shift/reduce conflict for WHILE in state 177 resolved as shift
shift/reduce conflict for INPUT in state 177 resolved as shift
shift/reduce conflict for OUTPUT in state 177 resolved as shift
shift/reduce conflict for IF in state 177 resolved as shift
shift/reduce conflict for RETURN in state 177 resolved as shift
shift/reduce conflict for ID in state 177 resolved as shift
shift/reduce conflict for FLOAT in state 177 resolved as shift
shift/reduce conflict for ( in state 177 resolved as shift
shift/reduce conflict for INT in state 177 resolved as shift
shift/reduce conflict for FALSE in state 177 resolved as shift
shift/reduce conflict for TRUE in state 177 resolved as shift
shift/reduce conflict for WHILE in state 182 resolved as shift
shift/reduce conflict for INPUT in state 182 resolved as shift
shift/reduce conflict for OUTPUT in state 182 resolved as shift
shift/reduce conflict for IF in state 182 resolved as shift
shift/reduce conflict for RETURN in state 182 resolved as shift
shift/reduce conflict for ID in state 182 resolved as shift
shift/reduce conflict for FLOAT in state 182 resolved as shift
shift/reduce conflict for ( in state 182 resolved as shift
shift/reduce conflict for INT in state 182 resolved as shift
shift/reduce conflict for FALSE in state 182 resolved as shift
shift/reduce conflict for TRUE in state 182 resolved as shift
shift/reduce conflict for WHILE in state 184 resolved as shift
shift/reduce conflict for INPUT in state 184 resolved as shift
shift/reduce conflict for OUTPUT in state 184 resolved as shift
shift/reduce conflict for IF in state 184 resolved as shift
shift/reduce conflict for RETURN in state 184 resolved as shift
shift/reduce conflict for ID in state 184 resolved as shift
shift/reduce conflict for FLOAT in state 184 resolved as shift
shift/reduce conflict for ( in state 184 resolved as shift
shift/reduce conflict for INT in state 184 resolved as shift
shift/reduce conflict for FALSE in state 184 resolved as shift
shift/reduce conflict for TRUE in state 184 resolved as shift
shift/reduce conflict for WHILE in state 188 resolved as shift
shift/reduce conflict for INPUT in state 188 resolved as shift
shift/reduce conflict for OUTPUT in state 188 resolved as shift
shift/reduce conflict for IF in state 188 resolved as shift
shift/reduce conflict for RETURN in state 188 resolved as shift
shift/reduce conflict for ID in state 188 resolved as shift
shift/reduce conflict for FLOAT in state 188 resolved as shift
shift/reduce conflict for ( in state 188 resolved as shift
shift/reduce conflict for INT in state 188 resolved as shift
shift/reduce conflict for FALSE in state 188 resolved as shift
shift/reduce conflict for TRUE in state 188 resolved as shift
shift/reduce conflict for WHILE in state 191 resolved as shift
shift/reduce conflict for INPUT in state 191 resolved as shift
shift/reduce conflict for OUTPUT in state 191 resolved as shift
shift/reduce conflict for IF in state 191 resolved as shift
shift/reduce conflict for RETURN in state 191 resolved as shift
shift/reduce conflict for ID in state 191 resolved as shift
shift/reduce conflict for FLOAT in state 191 resolved as shift
shift/reduce conflict for ( in state 191 resolved as shift
shift/reduce conflict for INT in state 191 resolved as shift
shift/reduce conflict for FALSE in state 191 resolved as shift
shift/reduce conflict for TRUE in state 191 resolved as shift
shift/reduce conflict for WHILE in state 198 resolved as shift
shift/reduce conflict for INPUT in state 198 resolved as shift
shift/reduce conflict for OUTPUT in state 198 resolved as shift
shift/reduce conflict for IF in state 198 resolved as shift
shift/reduce conflict for RETURN in state 198 resolved as shift
shift/reduce conflict for ID in state 198 resolved as shift
shift/reduce conflict for FLOAT in state 198 resolved as shift
shift/reduce conflict for ( in state 198 resolved as shift
shift/reduce conflict for INT in state 198 resolved as shift
shift/reduce conflict for FALSE in state 198 resolved as shift
shift/reduce conflict for TRUE in state 198 resolved as shift
reduce/reduce conflict in state 48 resolved using rule maincontent -> <empty>
rejected rule (statement -> <empty>) in state 48
reduce/reduce conflict in state 53 resolved using rule maincontent -> <empty>
rejected rule (statement -> <empty>) in state 53
reduce/reduce conflict in state 68 resolved using rule arexp -> term
rejected rule (arexpextra -> <empty>) in state 68
reduce/reduce conflict in state 69 resolved using rule term -> factor
rejected rule (termx -> <empty>) in state 69
reduce/reduce conflict in state 81 resolved using rule funcontent -> <empty>
rejected rule (statement -> <empty>) in state 81
reduce/reduce conflict in state 84 resolved using rule maincontent -> <empty>
rejected rule (statement -> statement statement) in state 84
reduce/reduce conflict in state 84 resolved using rule statement -> <empty>
rejected rule (statement -> statement statement) in state 84
reduce/reduce conflict in state 84 resolved using rule maincontent -> <empty>
rejected rule (statement -> <empty>) in state 84
reduce/reduce conflict in state 126 resolved using rule funcontent -> <empty>
rejected rule (statement -> <empty>) in state 126
reduce/reduce conflict in state 145 resolved using rule funcontent -> <empty>
rejected rule (statement -> statement statement) in state 145
reduce/reduce conflict in state 145 resolved using rule statement -> <empty>
rejected rule (statement -> statement statement) in state 145
reduce/reduce conflict in state 145 resolved using rule funcontent -> <empty>
rejected rule (statement -> <empty>) in state 145
reduce/reduce conflict in state 176 resolved using rule statement -> <empty>
rejected rule (ifelsecont -> <empty>) in state 176
reduce/reduce conflict in state 177 resolved using rule statement -> <empty>
rejected rule (loopcont -> <empty>) in state 177
reduce/reduce conflict in state 182 resolved using rule statement -> <empty>
rejected rule (ifelsecont -> <empty>) in state 182
reduce/reduce conflict in state 184 resolved using rule statement -> <empty>
rejected rule (loopcont -> <empty>) in state 184
reduce/reduce conflict in state 188 resolved using rule statement -> statement statement
rejected rule (ifelsecont -> <empty>) in state 188
reduce/reduce conflict in state 188 resolved using rule statement -> <empty>
rejected rule (statement -> statement statement) in state 188
reduce/reduce conflict in state 191 resolved using rule statement -> statement statement
rejected rule (loopcont -> <empty>) in state 191
reduce/reduce conflict in state 191 resolved using rule statement -> <empty>
rejected rule (statement -> statement statement) in state 191
reduce/reduce conflict in state 198 resolved using rule statement -> <empty>
rejected rule (ifelsecont -> <empty>) in state 198
Rule (statement -> statement statement) is never reduced
Rule (ifelsecont -> <empty>) is never reduced
Rule (loopcont -> <empty>) is never reduced